/*
 * Generated by gdbus-codegen 2.48.2. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#ifndef __OPENBMC_INTF_H__
#define __OPENBMC_INTF_H__

#include <gio/gio.h>

G_BEGIN_DECLS


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.Hwmon */

#define TYPE_HWMON (hwmon_get_type ())
#define HWMON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_HWMON, Hwmon))
#define IS_HWMON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_HWMON))
#define HWMON_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_HWMON, HwmonIface))

struct _Hwmon;
typedef struct _Hwmon Hwmon;
typedef struct _HwmonIface HwmonIface;

struct _HwmonIface
{
  GTypeInterface parent_iface;

  gint  (*get_poll_interval) (Hwmon *object);

  gint  (*get_scale) (Hwmon *object);

  const gchar * (*get_sysfs_path) (Hwmon *object);

};

GType hwmon_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *hwmon_interface_info (void);
guint hwmon_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus property accessors: */
gint hwmon_get_poll_interval (Hwmon *object);
void hwmon_set_poll_interval (Hwmon *object, gint value);

const gchar *hwmon_get_sysfs_path (Hwmon *object);
gchar *hwmon_dup_sysfs_path (Hwmon *object);
void hwmon_set_sysfs_path (Hwmon *object, const gchar *value);

gint hwmon_get_scale (Hwmon *object);
void hwmon_set_scale (Hwmon *object, gint value);


/* ---- */

#define TYPE_HWMON_PROXY (hwmon_proxy_get_type ())
#define HWMON_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_HWMON_PROXY, HwmonProxy))
#define HWMON_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_HWMON_PROXY, HwmonProxyClass))
#define HWMON_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_HWMON_PROXY, HwmonProxyClass))
#define IS_HWMON_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_HWMON_PROXY))
#define IS_HWMON_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_HWMON_PROXY))

typedef struct _HwmonProxy HwmonProxy;
typedef struct _HwmonProxyClass HwmonProxyClass;
typedef struct _HwmonProxyPrivate HwmonProxyPrivate;

struct _HwmonProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  HwmonProxyPrivate *priv;
};

struct _HwmonProxyClass
{
  GDBusProxyClass parent_class;
};

GType hwmon_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (HwmonProxy, g_object_unref)
#endif

void hwmon_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Hwmon *hwmon_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
Hwmon *hwmon_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void hwmon_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Hwmon *hwmon_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
Hwmon *hwmon_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_HWMON_SKELETON (hwmon_skeleton_get_type ())
#define HWMON_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_HWMON_SKELETON, HwmonSkeleton))
#define HWMON_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_HWMON_SKELETON, HwmonSkeletonClass))
#define HWMON_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_HWMON_SKELETON, HwmonSkeletonClass))
#define IS_HWMON_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_HWMON_SKELETON))
#define IS_HWMON_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_HWMON_SKELETON))

typedef struct _HwmonSkeleton HwmonSkeleton;
typedef struct _HwmonSkeletonClass HwmonSkeletonClass;
typedef struct _HwmonSkeletonPrivate HwmonSkeletonPrivate;

struct _HwmonSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  HwmonSkeletonPrivate *priv;
};

struct _HwmonSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType hwmon_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (HwmonSkeleton, g_object_unref)
#endif

Hwmon *hwmon_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.Fan */

#define TYPE_FAN (fan_get_type ())
#define FAN(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_FAN, Fan))
#define IS_FAN(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_FAN))
#define FAN_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_FAN, FanIface))

struct _Fan;
typedef struct _Fan Fan;
typedef struct _FanIface FanIface;

struct _FanIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_get_speed) (
    Fan *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_set_cooling_zone) (
    Fan *object,
    GDBusMethodInvocation *invocation,
    gint arg_cooling_zone);

  gboolean (*handle_set_speed) (
    Fan *object,
    GDBusMethodInvocation *invocation,
    gint arg_speed);

  gint  (*get_cooling_zone) (Fan *object);

  gint  (*get_pwm_num) (Fan *object);

  gint  (*get_speed) (Fan *object);

  void (*speed_changed) (
    Fan *object,
    gint arg_speed);

  void (*tach_error) (
    Fan *object);

};

GType fan_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *fan_interface_info (void);
guint fan_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void fan_complete_set_cooling_zone (
    Fan *object,
    GDBusMethodInvocation *invocation);

void fan_complete_get_speed (
    Fan *object,
    GDBusMethodInvocation *invocation,
    gint speed);

void fan_complete_set_speed (
    Fan *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void fan_emit_speed_changed (
    Fan *object,
    gint arg_speed);

void fan_emit_tach_error (
    Fan *object);



/* D-Bus method calls: */
void fan_call_set_cooling_zone (
    Fan *proxy,
    gint arg_cooling_zone,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean fan_call_set_cooling_zone_finish (
    Fan *proxy,
    GAsyncResult *res,
    GError **error);

gboolean fan_call_set_cooling_zone_sync (
    Fan *proxy,
    gint arg_cooling_zone,
    GCancellable *cancellable,
    GError **error);

void fan_call_get_speed (
    Fan *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean fan_call_get_speed_finish (
    Fan *proxy,
    gint *out_speed,
    GAsyncResult *res,
    GError **error);

gboolean fan_call_get_speed_sync (
    Fan *proxy,
    gint *out_speed,
    GCancellable *cancellable,
    GError **error);

void fan_call_set_speed (
    Fan *proxy,
    gint arg_speed,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean fan_call_set_speed_finish (
    Fan *proxy,
    GAsyncResult *res,
    GError **error);

gboolean fan_call_set_speed_sync (
    Fan *proxy,
    gint arg_speed,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gint fan_get_speed (Fan *object);
void fan_set_speed (Fan *object, gint value);

gint fan_get_cooling_zone (Fan *object);
void fan_set_cooling_zone (Fan *object, gint value);

gint fan_get_pwm_num (Fan *object);
void fan_set_pwm_num (Fan *object, gint value);


/* ---- */

#define TYPE_FAN_PROXY (fan_proxy_get_type ())
#define FAN_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_FAN_PROXY, FanProxy))
#define FAN_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_FAN_PROXY, FanProxyClass))
#define FAN_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_FAN_PROXY, FanProxyClass))
#define IS_FAN_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_FAN_PROXY))
#define IS_FAN_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_FAN_PROXY))

typedef struct _FanProxy FanProxy;
typedef struct _FanProxyClass FanProxyClass;
typedef struct _FanProxyPrivate FanProxyPrivate;

struct _FanProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  FanProxyPrivate *priv;
};

struct _FanProxyClass
{
  GDBusProxyClass parent_class;
};

GType fan_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FanProxy, g_object_unref)
#endif

void fan_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Fan *fan_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
Fan *fan_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void fan_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Fan *fan_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
Fan *fan_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_FAN_SKELETON (fan_skeleton_get_type ())
#define FAN_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_FAN_SKELETON, FanSkeleton))
#define FAN_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_FAN_SKELETON, FanSkeletonClass))
#define FAN_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_FAN_SKELETON, FanSkeletonClass))
#define IS_FAN_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_FAN_SKELETON))
#define IS_FAN_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_FAN_SKELETON))

typedef struct _FanSkeleton FanSkeleton;
typedef struct _FanSkeletonClass FanSkeletonClass;
typedef struct _FanSkeletonPrivate FanSkeletonPrivate;

struct _FanSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  FanSkeletonPrivate *priv;
};

struct _FanSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType fan_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FanSkeleton, g_object_unref)
#endif

Fan *fan_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.SensorValue */

#define TYPE_SENSOR_VALUE (sensor_value_get_type ())
#define SENSOR_VALUE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_VALUE, SensorValue))
#define IS_SENSOR_VALUE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_VALUE))
#define SENSOR_VALUE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_SENSOR_VALUE, SensorValueIface))

struct _SensorValue;
typedef struct _SensorValue SensorValue;
typedef struct _SensorValueIface SensorValueIface;

struct _SensorValueIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_get_value) (
    SensorValue *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_init) (
    SensorValue *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_set_value) (
    SensorValue *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_value);

  gint  (*get_heatbeat) (SensorValue *object);

  gint  (*get_poll_interval) (SensorValue *object);

  gboolean  (*get_settable) (SensorValue *object);

  const gchar * (*get_units) (SensorValue *object);

  GVariant * (*get_value) (SensorValue *object);

  void (*changed) (
    SensorValue *object,
    GVariant *arg_value,
    const gchar *arg_units);

  void (*error) (
    SensorValue *object);

  void (*heartbeat) (
    SensorValue *object,
    const gchar *arg_bus_name);

};

GType sensor_value_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *sensor_value_interface_info (void);
guint sensor_value_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void sensor_value_complete_init (
    SensorValue *object,
    GDBusMethodInvocation *invocation);

void sensor_value_complete_get_value (
    SensorValue *object,
    GDBusMethodInvocation *invocation,
    GVariant *value);

void sensor_value_complete_set_value (
    SensorValue *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void sensor_value_emit_changed (
    SensorValue *object,
    GVariant *arg_value,
    const gchar *arg_units);

void sensor_value_emit_error (
    SensorValue *object);

void sensor_value_emit_heartbeat (
    SensorValue *object,
    const gchar *arg_bus_name);



/* D-Bus method calls: */
void sensor_value_call_init (
    SensorValue *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean sensor_value_call_init_finish (
    SensorValue *proxy,
    GAsyncResult *res,
    GError **error);

gboolean sensor_value_call_init_sync (
    SensorValue *proxy,
    GCancellable *cancellable,
    GError **error);

void sensor_value_call_get_value (
    SensorValue *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean sensor_value_call_get_value_finish (
    SensorValue *proxy,
    GVariant **out_value,
    GAsyncResult *res,
    GError **error);

gboolean sensor_value_call_get_value_sync (
    SensorValue *proxy,
    GVariant **out_value,
    GCancellable *cancellable,
    GError **error);

void sensor_value_call_set_value (
    SensorValue *proxy,
    GVariant *arg_value,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean sensor_value_call_set_value_finish (
    SensorValue *proxy,
    GAsyncResult *res,
    GError **error);

gboolean sensor_value_call_set_value_sync (
    SensorValue *proxy,
    GVariant *arg_value,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
GVariant *sensor_value_get_value (SensorValue *object);
GVariant *sensor_value_dup_value (SensorValue *object);
void sensor_value_set_value (SensorValue *object, GVariant *value);

const gchar *sensor_value_get_units (SensorValue *object);
gchar *sensor_value_dup_units (SensorValue *object);
void sensor_value_set_units (SensorValue *object, const gchar *value);

gint sensor_value_get_poll_interval (SensorValue *object);
void sensor_value_set_poll_interval (SensorValue *object, gint value);

gint sensor_value_get_heatbeat (SensorValue *object);
void sensor_value_set_heatbeat (SensorValue *object, gint value);

gboolean sensor_value_get_settable (SensorValue *object);
void sensor_value_set_settable (SensorValue *object, gboolean value);


/* ---- */

#define TYPE_SENSOR_VALUE_PROXY (sensor_value_proxy_get_type ())
#define SENSOR_VALUE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_VALUE_PROXY, SensorValueProxy))
#define SENSOR_VALUE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_SENSOR_VALUE_PROXY, SensorValueProxyClass))
#define SENSOR_VALUE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_SENSOR_VALUE_PROXY, SensorValueProxyClass))
#define IS_SENSOR_VALUE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_VALUE_PROXY))
#define IS_SENSOR_VALUE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_SENSOR_VALUE_PROXY))

typedef struct _SensorValueProxy SensorValueProxy;
typedef struct _SensorValueProxyClass SensorValueProxyClass;
typedef struct _SensorValueProxyPrivate SensorValueProxyPrivate;

struct _SensorValueProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  SensorValueProxyPrivate *priv;
};

struct _SensorValueProxyClass
{
  GDBusProxyClass parent_class;
};

GType sensor_value_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SensorValueProxy, g_object_unref)
#endif

void sensor_value_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
SensorValue *sensor_value_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
SensorValue *sensor_value_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void sensor_value_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
SensorValue *sensor_value_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
SensorValue *sensor_value_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_SENSOR_VALUE_SKELETON (sensor_value_skeleton_get_type ())
#define SENSOR_VALUE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_VALUE_SKELETON, SensorValueSkeleton))
#define SENSOR_VALUE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_SENSOR_VALUE_SKELETON, SensorValueSkeletonClass))
#define SENSOR_VALUE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_SENSOR_VALUE_SKELETON, SensorValueSkeletonClass))
#define IS_SENSOR_VALUE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_VALUE_SKELETON))
#define IS_SENSOR_VALUE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_SENSOR_VALUE_SKELETON))

typedef struct _SensorValueSkeleton SensorValueSkeleton;
typedef struct _SensorValueSkeletonClass SensorValueSkeletonClass;
typedef struct _SensorValueSkeletonPrivate SensorValueSkeletonPrivate;

struct _SensorValueSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  SensorValueSkeletonPrivate *priv;
};

struct _SensorValueSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType sensor_value_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SensorValueSkeleton, g_object_unref)
#endif

SensorValue *sensor_value_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.SensorThreshold */

#define TYPE_SENSOR_THRESHOLD (sensor_threshold_get_type ())
#define SENSOR_THRESHOLD(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_THRESHOLD, SensorThreshold))
#define IS_SENSOR_THRESHOLD(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_THRESHOLD))
#define SENSOR_THRESHOLD_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_SENSOR_THRESHOLD, SensorThresholdIface))

struct _SensorThreshold;
typedef struct _SensorThreshold SensorThreshold;
typedef struct _SensorThresholdIface SensorThresholdIface;

struct _SensorThresholdIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_get_state) (
    SensorThreshold *object,
    GDBusMethodInvocation *invocation);

  GVariant * (*get_lower_critical) (SensorThreshold *object);

  GVariant * (*get_lower_warning) (SensorThreshold *object);

  guchar  (*get_state) (SensorThreshold *object);

  GVariant * (*get_upper_critical) (SensorThreshold *object);

  GVariant * (*get_upper_warning) (SensorThreshold *object);

  void (*critical) (
    SensorThreshold *object);

  void (*normal) (
    SensorThreshold *object);

  void (*warning) (
    SensorThreshold *object);

};

GType sensor_threshold_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *sensor_threshold_interface_info (void);
guint sensor_threshold_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void sensor_threshold_complete_get_state (
    SensorThreshold *object,
    GDBusMethodInvocation *invocation,
    guchar state);



/* D-Bus signal emissions functions: */
void sensor_threshold_emit_warning (
    SensorThreshold *object);

void sensor_threshold_emit_critical (
    SensorThreshold *object);

void sensor_threshold_emit_normal (
    SensorThreshold *object);



/* D-Bus method calls: */
void sensor_threshold_call_get_state (
    SensorThreshold *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean sensor_threshold_call_get_state_finish (
    SensorThreshold *proxy,
    guchar *out_state,
    GAsyncResult *res,
    GError **error);

gboolean sensor_threshold_call_get_state_sync (
    SensorThreshold *proxy,
    guchar *out_state,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
GVariant *sensor_threshold_get_lower_critical (SensorThreshold *object);
GVariant *sensor_threshold_dup_lower_critical (SensorThreshold *object);
void sensor_threshold_set_lower_critical (SensorThreshold *object, GVariant *value);

GVariant *sensor_threshold_get_lower_warning (SensorThreshold *object);
GVariant *sensor_threshold_dup_lower_warning (SensorThreshold *object);
void sensor_threshold_set_lower_warning (SensorThreshold *object, GVariant *value);

GVariant *sensor_threshold_get_upper_warning (SensorThreshold *object);
GVariant *sensor_threshold_dup_upper_warning (SensorThreshold *object);
void sensor_threshold_set_upper_warning (SensorThreshold *object, GVariant *value);

GVariant *sensor_threshold_get_upper_critical (SensorThreshold *object);
GVariant *sensor_threshold_dup_upper_critical (SensorThreshold *object);
void sensor_threshold_set_upper_critical (SensorThreshold *object, GVariant *value);

guchar sensor_threshold_get_state (SensorThreshold *object);
void sensor_threshold_set_state (SensorThreshold *object, guchar value);


/* ---- */

#define TYPE_SENSOR_THRESHOLD_PROXY (sensor_threshold_proxy_get_type ())
#define SENSOR_THRESHOLD_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_THRESHOLD_PROXY, SensorThresholdProxy))
#define SENSOR_THRESHOLD_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_SENSOR_THRESHOLD_PROXY, SensorThresholdProxyClass))
#define SENSOR_THRESHOLD_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_SENSOR_THRESHOLD_PROXY, SensorThresholdProxyClass))
#define IS_SENSOR_THRESHOLD_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_THRESHOLD_PROXY))
#define IS_SENSOR_THRESHOLD_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_SENSOR_THRESHOLD_PROXY))

typedef struct _SensorThresholdProxy SensorThresholdProxy;
typedef struct _SensorThresholdProxyClass SensorThresholdProxyClass;
typedef struct _SensorThresholdProxyPrivate SensorThresholdProxyPrivate;

struct _SensorThresholdProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  SensorThresholdProxyPrivate *priv;
};

struct _SensorThresholdProxyClass
{
  GDBusProxyClass parent_class;
};

GType sensor_threshold_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SensorThresholdProxy, g_object_unref)
#endif

void sensor_threshold_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
SensorThreshold *sensor_threshold_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
SensorThreshold *sensor_threshold_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void sensor_threshold_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
SensorThreshold *sensor_threshold_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
SensorThreshold *sensor_threshold_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_SENSOR_THRESHOLD_SKELETON (sensor_threshold_skeleton_get_type ())
#define SENSOR_THRESHOLD_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_THRESHOLD_SKELETON, SensorThresholdSkeleton))
#define SENSOR_THRESHOLD_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_SENSOR_THRESHOLD_SKELETON, SensorThresholdSkeletonClass))
#define SENSOR_THRESHOLD_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_SENSOR_THRESHOLD_SKELETON, SensorThresholdSkeletonClass))
#define IS_SENSOR_THRESHOLD_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_THRESHOLD_SKELETON))
#define IS_SENSOR_THRESHOLD_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_SENSOR_THRESHOLD_SKELETON))

typedef struct _SensorThresholdSkeleton SensorThresholdSkeleton;
typedef struct _SensorThresholdSkeletonClass SensorThresholdSkeletonClass;
typedef struct _SensorThresholdSkeletonPrivate SensorThresholdSkeletonPrivate;

struct _SensorThresholdSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  SensorThresholdSkeletonPrivate *priv;
};

struct _SensorThresholdSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType sensor_threshold_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SensorThresholdSkeleton, g_object_unref)
#endif

SensorThreshold *sensor_threshold_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.SensorI2c */

#define TYPE_SENSOR_I2C (sensor_i2c_get_type ())
#define SENSOR_I2C(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_I2C, SensorI2c))
#define IS_SENSOR_I2C(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_I2C))
#define SENSOR_I2C_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_SENSOR_I2C, SensorI2cIface))

struct _SensorI2c;
typedef struct _SensorI2c SensorI2c;
typedef struct _SensorI2cIface SensorI2cIface;

struct _SensorI2cIface
{
  GTypeInterface parent_iface;

  const gchar * (*get_address) (SensorI2c *object);

  const gchar * (*get_dev_path) (SensorI2c *object);

};

GType sensor_i2c_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *sensor_i2c_interface_info (void);
guint sensor_i2c_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus property accessors: */
const gchar *sensor_i2c_get_dev_path (SensorI2c *object);
gchar *sensor_i2c_dup_dev_path (SensorI2c *object);
void sensor_i2c_set_dev_path (SensorI2c *object, const gchar *value);

const gchar *sensor_i2c_get_address (SensorI2c *object);
gchar *sensor_i2c_dup_address (SensorI2c *object);
void sensor_i2c_set_address (SensorI2c *object, const gchar *value);


/* ---- */

#define TYPE_SENSOR_I2C_PROXY (sensor_i2c_proxy_get_type ())
#define SENSOR_I2C_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_I2C_PROXY, SensorI2cProxy))
#define SENSOR_I2C_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_SENSOR_I2C_PROXY, SensorI2cProxyClass))
#define SENSOR_I2C_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_SENSOR_I2C_PROXY, SensorI2cProxyClass))
#define IS_SENSOR_I2C_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_I2C_PROXY))
#define IS_SENSOR_I2C_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_SENSOR_I2C_PROXY))

typedef struct _SensorI2cProxy SensorI2cProxy;
typedef struct _SensorI2cProxyClass SensorI2cProxyClass;
typedef struct _SensorI2cProxyPrivate SensorI2cProxyPrivate;

struct _SensorI2cProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  SensorI2cProxyPrivate *priv;
};

struct _SensorI2cProxyClass
{
  GDBusProxyClass parent_class;
};

GType sensor_i2c_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SensorI2cProxy, g_object_unref)
#endif

void sensor_i2c_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
SensorI2c *sensor_i2c_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
SensorI2c *sensor_i2c_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void sensor_i2c_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
SensorI2c *sensor_i2c_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
SensorI2c *sensor_i2c_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_SENSOR_I2C_SKELETON (sensor_i2c_skeleton_get_type ())
#define SENSOR_I2C_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_I2C_SKELETON, SensorI2cSkeleton))
#define SENSOR_I2C_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_SENSOR_I2C_SKELETON, SensorI2cSkeletonClass))
#define SENSOR_I2C_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_SENSOR_I2C_SKELETON, SensorI2cSkeletonClass))
#define IS_SENSOR_I2C_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_I2C_SKELETON))
#define IS_SENSOR_I2C_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_SENSOR_I2C_SKELETON))

typedef struct _SensorI2cSkeleton SensorI2cSkeleton;
typedef struct _SensorI2cSkeletonClass SensorI2cSkeletonClass;
typedef struct _SensorI2cSkeletonPrivate SensorI2cSkeletonPrivate;

struct _SensorI2cSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  SensorI2cSkeletonPrivate *priv;
};

struct _SensorI2cSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType sensor_i2c_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SensorI2cSkeleton, g_object_unref)
#endif

SensorI2c *sensor_i2c_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.SensorMatch */

#define TYPE_SENSOR_MATCH (sensor_match_get_type ())
#define SENSOR_MATCH(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_MATCH, SensorMatch))
#define IS_SENSOR_MATCH(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_MATCH))
#define SENSOR_MATCH_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_SENSOR_MATCH, SensorMatchIface))

struct _SensorMatch;
typedef struct _SensorMatch SensorMatch;
typedef struct _SensorMatchIface SensorMatchIface;

struct _SensorMatchIface
{
  GTypeInterface parent_iface;


  GVariant * (*get_match_value) (SensorMatch *object);

  guchar  (*get_state) (SensorMatch *object);

  void (*sensor_match) (
    SensorMatch *object,
    guchar arg_state);

};

GType sensor_match_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *sensor_match_interface_info (void);
guint sensor_match_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus signal emissions functions: */
void sensor_match_emit_sensor_match (
    SensorMatch *object,
    guchar arg_state);



/* D-Bus property accessors: */
GVariant *sensor_match_get_match_value (SensorMatch *object);
GVariant *sensor_match_dup_match_value (SensorMatch *object);
void sensor_match_set_match_value (SensorMatch *object, GVariant *value);

guchar sensor_match_get_state (SensorMatch *object);
void sensor_match_set_state (SensorMatch *object, guchar value);


/* ---- */

#define TYPE_SENSOR_MATCH_PROXY (sensor_match_proxy_get_type ())
#define SENSOR_MATCH_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_MATCH_PROXY, SensorMatchProxy))
#define SENSOR_MATCH_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_SENSOR_MATCH_PROXY, SensorMatchProxyClass))
#define SENSOR_MATCH_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_SENSOR_MATCH_PROXY, SensorMatchProxyClass))
#define IS_SENSOR_MATCH_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_MATCH_PROXY))
#define IS_SENSOR_MATCH_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_SENSOR_MATCH_PROXY))

typedef struct _SensorMatchProxy SensorMatchProxy;
typedef struct _SensorMatchProxyClass SensorMatchProxyClass;
typedef struct _SensorMatchProxyPrivate SensorMatchProxyPrivate;

struct _SensorMatchProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  SensorMatchProxyPrivate *priv;
};

struct _SensorMatchProxyClass
{
  GDBusProxyClass parent_class;
};

GType sensor_match_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SensorMatchProxy, g_object_unref)
#endif

void sensor_match_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
SensorMatch *sensor_match_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
SensorMatch *sensor_match_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void sensor_match_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
SensorMatch *sensor_match_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
SensorMatch *sensor_match_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_SENSOR_MATCH_SKELETON (sensor_match_skeleton_get_type ())
#define SENSOR_MATCH_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SENSOR_MATCH_SKELETON, SensorMatchSkeleton))
#define SENSOR_MATCH_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_SENSOR_MATCH_SKELETON, SensorMatchSkeletonClass))
#define SENSOR_MATCH_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_SENSOR_MATCH_SKELETON, SensorMatchSkeletonClass))
#define IS_SENSOR_MATCH_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SENSOR_MATCH_SKELETON))
#define IS_SENSOR_MATCH_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_SENSOR_MATCH_SKELETON))

typedef struct _SensorMatchSkeleton SensorMatchSkeleton;
typedef struct _SensorMatchSkeletonClass SensorMatchSkeletonClass;
typedef struct _SensorMatchSkeletonPrivate SensorMatchSkeletonPrivate;

struct _SensorMatchSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  SensorMatchSkeletonPrivate *priv;
};

struct _SensorMatchSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType sensor_match_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SensorMatchSkeleton, g_object_unref)
#endif

SensorMatch *sensor_match_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.Process */

#define TYPE_PROCESS (process_get_type ())
#define PROCESS(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_PROCESS, Process))
#define IS_PROCESS(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_PROCESS))
#define PROCESS_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_PROCESS, ProcessIface))

struct _Process;
typedef struct _Process Process;
typedef struct _ProcessIface ProcessIface;

struct _ProcessIface
{
  GTypeInterface parent_iface;

  gboolean (*handle_stop) (
    Process *object,
    GDBusMethodInvocation *invocation);

};

GType process_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *process_interface_info (void);
guint process_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void process_complete_stop (
    Process *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void process_call_stop (
    Process *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean process_call_stop_finish (
    Process *proxy,
    GAsyncResult *res,
    GError **error);

gboolean process_call_stop_sync (
    Process *proxy,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define TYPE_PROCESS_PROXY (process_proxy_get_type ())
#define PROCESS_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_PROCESS_PROXY, ProcessProxy))
#define PROCESS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_PROCESS_PROXY, ProcessProxyClass))
#define PROCESS_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_PROCESS_PROXY, ProcessProxyClass))
#define IS_PROCESS_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_PROCESS_PROXY))
#define IS_PROCESS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_PROCESS_PROXY))

typedef struct _ProcessProxy ProcessProxy;
typedef struct _ProcessProxyClass ProcessProxyClass;
typedef struct _ProcessProxyPrivate ProcessProxyPrivate;

struct _ProcessProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  ProcessProxyPrivate *priv;
};

struct _ProcessProxyClass
{
  GDBusProxyClass parent_class;
};

GType process_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ProcessProxy, g_object_unref)
#endif

void process_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Process *process_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
Process *process_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void process_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Process *process_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
Process *process_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_PROCESS_SKELETON (process_skeleton_get_type ())
#define PROCESS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_PROCESS_SKELETON, ProcessSkeleton))
#define PROCESS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_PROCESS_SKELETON, ProcessSkeletonClass))
#define PROCESS_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_PROCESS_SKELETON, ProcessSkeletonClass))
#define IS_PROCESS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_PROCESS_SKELETON))
#define IS_PROCESS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_PROCESS_SKELETON))

typedef struct _ProcessSkeleton ProcessSkeleton;
typedef struct _ProcessSkeletonClass ProcessSkeletonClass;
typedef struct _ProcessSkeletonPrivate ProcessSkeletonPrivate;

struct _ProcessSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  ProcessSkeletonPrivate *priv;
};

struct _ProcessSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType process_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ProcessSkeleton, g_object_unref)
#endif

Process *process_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.SharedResource */

#define TYPE_SHARED_RESOURCE (shared_resource_get_type ())
#define SHARED_RESOURCE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SHARED_RESOURCE, SharedResource))
#define IS_SHARED_RESOURCE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SHARED_RESOURCE))
#define SHARED_RESOURCE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_SHARED_RESOURCE, SharedResourceIface))

struct _SharedResource;
typedef struct _SharedResource SharedResource;
typedef struct _SharedResourceIface SharedResourceIface;

struct _SharedResourceIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_is_locked) (
    SharedResource *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_lock) (
    SharedResource *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name);

  gboolean (*handle_unlock) (
    SharedResource *object,
    GDBusMethodInvocation *invocation);

  gboolean  (*get_lock) (SharedResource *object);

  const gchar * (*get_name) (SharedResource *object);

};

GType shared_resource_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *shared_resource_interface_info (void);
guint shared_resource_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void shared_resource_complete_lock (
    SharedResource *object,
    GDBusMethodInvocation *invocation);

void shared_resource_complete_unlock (
    SharedResource *object,
    GDBusMethodInvocation *invocation);

void shared_resource_complete_is_locked (
    SharedResource *object,
    GDBusMethodInvocation *invocation,
    gboolean lock,
    const gchar *name);



/* D-Bus method calls: */
void shared_resource_call_lock (
    SharedResource *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean shared_resource_call_lock_finish (
    SharedResource *proxy,
    GAsyncResult *res,
    GError **error);

gboolean shared_resource_call_lock_sync (
    SharedResource *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GError **error);

void shared_resource_call_unlock (
    SharedResource *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean shared_resource_call_unlock_finish (
    SharedResource *proxy,
    GAsyncResult *res,
    GError **error);

gboolean shared_resource_call_unlock_sync (
    SharedResource *proxy,
    GCancellable *cancellable,
    GError **error);

void shared_resource_call_is_locked (
    SharedResource *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean shared_resource_call_is_locked_finish (
    SharedResource *proxy,
    gboolean *out_lock,
    gchar **out_name,
    GAsyncResult *res,
    GError **error);

gboolean shared_resource_call_is_locked_sync (
    SharedResource *proxy,
    gboolean *out_lock,
    gchar **out_name,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gboolean shared_resource_get_lock (SharedResource *object);
void shared_resource_set_lock (SharedResource *object, gboolean value);

const gchar *shared_resource_get_name (SharedResource *object);
gchar *shared_resource_dup_name (SharedResource *object);
void shared_resource_set_name (SharedResource *object, const gchar *value);


/* ---- */

#define TYPE_SHARED_RESOURCE_PROXY (shared_resource_proxy_get_type ())
#define SHARED_RESOURCE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SHARED_RESOURCE_PROXY, SharedResourceProxy))
#define SHARED_RESOURCE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_SHARED_RESOURCE_PROXY, SharedResourceProxyClass))
#define SHARED_RESOURCE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_SHARED_RESOURCE_PROXY, SharedResourceProxyClass))
#define IS_SHARED_RESOURCE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SHARED_RESOURCE_PROXY))
#define IS_SHARED_RESOURCE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_SHARED_RESOURCE_PROXY))

typedef struct _SharedResourceProxy SharedResourceProxy;
typedef struct _SharedResourceProxyClass SharedResourceProxyClass;
typedef struct _SharedResourceProxyPrivate SharedResourceProxyPrivate;

struct _SharedResourceProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  SharedResourceProxyPrivate *priv;
};

struct _SharedResourceProxyClass
{
  GDBusProxyClass parent_class;
};

GType shared_resource_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SharedResourceProxy, g_object_unref)
#endif

void shared_resource_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
SharedResource *shared_resource_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
SharedResource *shared_resource_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void shared_resource_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
SharedResource *shared_resource_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
SharedResource *shared_resource_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_SHARED_RESOURCE_SKELETON (shared_resource_skeleton_get_type ())
#define SHARED_RESOURCE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_SHARED_RESOURCE_SKELETON, SharedResourceSkeleton))
#define SHARED_RESOURCE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_SHARED_RESOURCE_SKELETON, SharedResourceSkeletonClass))
#define SHARED_RESOURCE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_SHARED_RESOURCE_SKELETON, SharedResourceSkeletonClass))
#define IS_SHARED_RESOURCE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_SHARED_RESOURCE_SKELETON))
#define IS_SHARED_RESOURCE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_SHARED_RESOURCE_SKELETON))

typedef struct _SharedResourceSkeleton SharedResourceSkeleton;
typedef struct _SharedResourceSkeletonClass SharedResourceSkeletonClass;
typedef struct _SharedResourceSkeletonPrivate SharedResourceSkeletonPrivate;

struct _SharedResourceSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  SharedResourceSkeletonPrivate *priv;
};

struct _SharedResourceSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType shared_resource_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (SharedResourceSkeleton, g_object_unref)
#endif

SharedResource *shared_resource_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.Control */

#define TYPE_CONTROL (control_get_type ())
#define CONTROL(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL, Control))
#define IS_CONTROL(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL))
#define CONTROL_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_CONTROL, ControlIface))

struct _Control;
typedef struct _Control Control;
typedef struct _ControlIface ControlIface;

struct _ControlIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_init) (
    Control *object,
    GDBusMethodInvocation *invocation);

  gint  (*get_heatbeat) (Control *object);

  gint  (*get_poll_interval) (Control *object);

  void (*heartbeat) (
    Control *object,
    const gchar *arg_bus_name);

  void (*started) (
    Control *object);

};

GType control_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *control_interface_info (void);
guint control_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void control_complete_init (
    Control *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void control_emit_heartbeat (
    Control *object,
    const gchar *arg_bus_name);

void control_emit_started (
    Control *object);



/* D-Bus method calls: */
void control_call_init (
    Control *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean control_call_init_finish (
    Control *proxy,
    GAsyncResult *res,
    GError **error);

gboolean control_call_init_sync (
    Control *proxy,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gint control_get_poll_interval (Control *object);
void control_set_poll_interval (Control *object, gint value);

gint control_get_heatbeat (Control *object);
void control_set_heatbeat (Control *object, gint value);


/* ---- */

#define TYPE_CONTROL_PROXY (control_proxy_get_type ())
#define CONTROL_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_PROXY, ControlProxy))
#define CONTROL_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTROL_PROXY, ControlProxyClass))
#define CONTROL_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTROL_PROXY, ControlProxyClass))
#define IS_CONTROL_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_PROXY))
#define IS_CONTROL_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTROL_PROXY))

typedef struct _ControlProxy ControlProxy;
typedef struct _ControlProxyClass ControlProxyClass;
typedef struct _ControlProxyPrivate ControlProxyPrivate;

struct _ControlProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  ControlProxyPrivate *priv;
};

struct _ControlProxyClass
{
  GDBusProxyClass parent_class;
};

GType control_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ControlProxy, g_object_unref)
#endif

void control_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Control *control_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
Control *control_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void control_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Control *control_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
Control *control_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_CONTROL_SKELETON (control_skeleton_get_type ())
#define CONTROL_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_SKELETON, ControlSkeleton))
#define CONTROL_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTROL_SKELETON, ControlSkeletonClass))
#define CONTROL_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTROL_SKELETON, ControlSkeletonClass))
#define IS_CONTROL_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_SKELETON))
#define IS_CONTROL_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTROL_SKELETON))

typedef struct _ControlSkeleton ControlSkeleton;
typedef struct _ControlSkeletonClass ControlSkeletonClass;
typedef struct _ControlSkeletonPrivate ControlSkeletonPrivate;

struct _ControlSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  ControlSkeletonPrivate *priv;
};

struct _ControlSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType control_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ControlSkeleton, g_object_unref)
#endif

Control *control_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.control.Bmc */

#define TYPE_CONTROL_BMC (control_bmc_get_type ())
#define CONTROL_BMC(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_BMC, ControlBmc))
#define IS_CONTROL_BMC(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_BMC))
#define CONTROL_BMC_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_CONTROL_BMC, ControlBmcIface))

struct _ControlBmc;
typedef struct _ControlBmc ControlBmc;
typedef struct _ControlBmcIface ControlBmcIface;

struct _ControlBmcIface
{
  GTypeInterface parent_iface;

  gboolean (*handle_cold_reset) (
    ControlBmc *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_warm_reset) (
    ControlBmc *object,
    GDBusMethodInvocation *invocation);

};

GType control_bmc_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *control_bmc_interface_info (void);
guint control_bmc_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void control_bmc_complete_cold_reset (
    ControlBmc *object,
    GDBusMethodInvocation *invocation);

void control_bmc_complete_warm_reset (
    ControlBmc *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void control_bmc_call_cold_reset (
    ControlBmc *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean control_bmc_call_cold_reset_finish (
    ControlBmc *proxy,
    GAsyncResult *res,
    GError **error);

gboolean control_bmc_call_cold_reset_sync (
    ControlBmc *proxy,
    GCancellable *cancellable,
    GError **error);

void control_bmc_call_warm_reset (
    ControlBmc *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean control_bmc_call_warm_reset_finish (
    ControlBmc *proxy,
    GAsyncResult *res,
    GError **error);

gboolean control_bmc_call_warm_reset_sync (
    ControlBmc *proxy,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define TYPE_CONTROL_BMC_PROXY (control_bmc_proxy_get_type ())
#define CONTROL_BMC_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_BMC_PROXY, ControlBmcProxy))
#define CONTROL_BMC_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTROL_BMC_PROXY, ControlBmcProxyClass))
#define CONTROL_BMC_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTROL_BMC_PROXY, ControlBmcProxyClass))
#define IS_CONTROL_BMC_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_BMC_PROXY))
#define IS_CONTROL_BMC_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTROL_BMC_PROXY))

typedef struct _ControlBmcProxy ControlBmcProxy;
typedef struct _ControlBmcProxyClass ControlBmcProxyClass;
typedef struct _ControlBmcProxyPrivate ControlBmcProxyPrivate;

struct _ControlBmcProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  ControlBmcProxyPrivate *priv;
};

struct _ControlBmcProxyClass
{
  GDBusProxyClass parent_class;
};

GType control_bmc_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ControlBmcProxy, g_object_unref)
#endif

void control_bmc_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
ControlBmc *control_bmc_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
ControlBmc *control_bmc_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void control_bmc_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
ControlBmc *control_bmc_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
ControlBmc *control_bmc_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_CONTROL_BMC_SKELETON (control_bmc_skeleton_get_type ())
#define CONTROL_BMC_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_BMC_SKELETON, ControlBmcSkeleton))
#define CONTROL_BMC_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTROL_BMC_SKELETON, ControlBmcSkeletonClass))
#define CONTROL_BMC_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTROL_BMC_SKELETON, ControlBmcSkeletonClass))
#define IS_CONTROL_BMC_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_BMC_SKELETON))
#define IS_CONTROL_BMC_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTROL_BMC_SKELETON))

typedef struct _ControlBmcSkeleton ControlBmcSkeleton;
typedef struct _ControlBmcSkeletonClass ControlBmcSkeletonClass;
typedef struct _ControlBmcSkeletonPrivate ControlBmcSkeletonPrivate;

struct _ControlBmcSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  ControlBmcSkeletonPrivate *priv;
};

struct _ControlBmcSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType control_bmc_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ControlBmcSkeleton, g_object_unref)
#endif

ControlBmc *control_bmc_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.control.Host */

#define TYPE_CONTROL_HOST (control_host_get_type ())
#define CONTROL_HOST(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_HOST, ControlHost))
#define IS_CONTROL_HOST(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_HOST))
#define CONTROL_HOST_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_CONTROL_HOST, ControlHostIface))

struct _ControlHost;
typedef struct _ControlHost ControlHost;
typedef struct _ControlHostIface ControlHostIface;

struct _ControlHostIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_boot) (
    ControlHost *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_reboot) (
    ControlHost *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_shutdown) (
    ControlHost *object,
    GDBusMethodInvocation *invocation);

  gint  (*get_debug_mode) (ControlHost *object);

  const gchar * (*get_flash_side) (ControlHost *object);

  void (*booted) (
    ControlHost *object);

};

GType control_host_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *control_host_interface_info (void);
guint control_host_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void control_host_complete_boot (
    ControlHost *object,
    GDBusMethodInvocation *invocation);

void control_host_complete_shutdown (
    ControlHost *object,
    GDBusMethodInvocation *invocation);

void control_host_complete_reboot (
    ControlHost *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void control_host_emit_booted (
    ControlHost *object);



/* D-Bus method calls: */
void control_host_call_boot (
    ControlHost *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean control_host_call_boot_finish (
    ControlHost *proxy,
    GAsyncResult *res,
    GError **error);

gboolean control_host_call_boot_sync (
    ControlHost *proxy,
    GCancellable *cancellable,
    GError **error);

void control_host_call_shutdown (
    ControlHost *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean control_host_call_shutdown_finish (
    ControlHost *proxy,
    GAsyncResult *res,
    GError **error);

gboolean control_host_call_shutdown_sync (
    ControlHost *proxy,
    GCancellable *cancellable,
    GError **error);

void control_host_call_reboot (
    ControlHost *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean control_host_call_reboot_finish (
    ControlHost *proxy,
    GAsyncResult *res,
    GError **error);

gboolean control_host_call_reboot_sync (
    ControlHost *proxy,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gint control_host_get_debug_mode (ControlHost *object);
void control_host_set_debug_mode (ControlHost *object, gint value);

const gchar *control_host_get_flash_side (ControlHost *object);
gchar *control_host_dup_flash_side (ControlHost *object);
void control_host_set_flash_side (ControlHost *object, const gchar *value);


/* ---- */

#define TYPE_CONTROL_HOST_PROXY (control_host_proxy_get_type ())
#define CONTROL_HOST_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_HOST_PROXY, ControlHostProxy))
#define CONTROL_HOST_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTROL_HOST_PROXY, ControlHostProxyClass))
#define CONTROL_HOST_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTROL_HOST_PROXY, ControlHostProxyClass))
#define IS_CONTROL_HOST_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_HOST_PROXY))
#define IS_CONTROL_HOST_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTROL_HOST_PROXY))

typedef struct _ControlHostProxy ControlHostProxy;
typedef struct _ControlHostProxyClass ControlHostProxyClass;
typedef struct _ControlHostProxyPrivate ControlHostProxyPrivate;

struct _ControlHostProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  ControlHostProxyPrivate *priv;
};

struct _ControlHostProxyClass
{
  GDBusProxyClass parent_class;
};

GType control_host_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ControlHostProxy, g_object_unref)
#endif

void control_host_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
ControlHost *control_host_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
ControlHost *control_host_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void control_host_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
ControlHost *control_host_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
ControlHost *control_host_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_CONTROL_HOST_SKELETON (control_host_skeleton_get_type ())
#define CONTROL_HOST_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_HOST_SKELETON, ControlHostSkeleton))
#define CONTROL_HOST_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTROL_HOST_SKELETON, ControlHostSkeletonClass))
#define CONTROL_HOST_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTROL_HOST_SKELETON, ControlHostSkeletonClass))
#define IS_CONTROL_HOST_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_HOST_SKELETON))
#define IS_CONTROL_HOST_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTROL_HOST_SKELETON))

typedef struct _ControlHostSkeleton ControlHostSkeleton;
typedef struct _ControlHostSkeletonClass ControlHostSkeletonClass;
typedef struct _ControlHostSkeletonPrivate ControlHostSkeletonPrivate;

struct _ControlHostSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  ControlHostSkeletonPrivate *priv;
};

struct _ControlHostSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType control_host_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ControlHostSkeleton, g_object_unref)
#endif

ControlHost *control_host_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.control.Power */

#define TYPE_CONTROL_POWER (control_power_get_type ())
#define CONTROL_POWER(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_POWER, ControlPower))
#define IS_CONTROL_POWER(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_POWER))
#define CONTROL_POWER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_CONTROL_POWER, ControlPowerIface))

struct _ControlPower;
typedef struct _ControlPower ControlPower;
typedef struct _ControlPowerIface ControlPowerIface;

struct _ControlPowerIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_get_power_state) (
    ControlPower *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_set_power_state) (
    ControlPower *object,
    GDBusMethodInvocation *invocation,
    gint arg_state);

  gint  (*get_pgood) (ControlPower *object);

  gint  (*get_pgood_timeout) (ControlPower *object);

  gint  (*get_state) (ControlPower *object);

  void (*power_good) (
    ControlPower *object);

  void (*power_lost) (
    ControlPower *object);

};

GType control_power_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *control_power_interface_info (void);
guint control_power_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void control_power_complete_set_power_state (
    ControlPower *object,
    GDBusMethodInvocation *invocation);

void control_power_complete_get_power_state (
    ControlPower *object,
    GDBusMethodInvocation *invocation,
    gint state);



/* D-Bus signal emissions functions: */
void control_power_emit_power_good (
    ControlPower *object);

void control_power_emit_power_lost (
    ControlPower *object);



/* D-Bus method calls: */
void control_power_call_set_power_state (
    ControlPower *proxy,
    gint arg_state,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean control_power_call_set_power_state_finish (
    ControlPower *proxy,
    GAsyncResult *res,
    GError **error);

gboolean control_power_call_set_power_state_sync (
    ControlPower *proxy,
    gint arg_state,
    GCancellable *cancellable,
    GError **error);

void control_power_call_get_power_state (
    ControlPower *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean control_power_call_get_power_state_finish (
    ControlPower *proxy,
    gint *out_state,
    GAsyncResult *res,
    GError **error);

gboolean control_power_call_get_power_state_sync (
    ControlPower *proxy,
    gint *out_state,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gint control_power_get_pgood (ControlPower *object);
void control_power_set_pgood (ControlPower *object, gint value);

gint control_power_get_state (ControlPower *object);
void control_power_set_state (ControlPower *object, gint value);

gint control_power_get_pgood_timeout (ControlPower *object);
void control_power_set_pgood_timeout (ControlPower *object, gint value);


/* ---- */

#define TYPE_CONTROL_POWER_PROXY (control_power_proxy_get_type ())
#define CONTROL_POWER_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_POWER_PROXY, ControlPowerProxy))
#define CONTROL_POWER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTROL_POWER_PROXY, ControlPowerProxyClass))
#define CONTROL_POWER_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTROL_POWER_PROXY, ControlPowerProxyClass))
#define IS_CONTROL_POWER_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_POWER_PROXY))
#define IS_CONTROL_POWER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTROL_POWER_PROXY))

typedef struct _ControlPowerProxy ControlPowerProxy;
typedef struct _ControlPowerProxyClass ControlPowerProxyClass;
typedef struct _ControlPowerProxyPrivate ControlPowerProxyPrivate;

struct _ControlPowerProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  ControlPowerProxyPrivate *priv;
};

struct _ControlPowerProxyClass
{
  GDBusProxyClass parent_class;
};

GType control_power_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ControlPowerProxy, g_object_unref)
#endif

void control_power_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
ControlPower *control_power_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
ControlPower *control_power_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void control_power_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
ControlPower *control_power_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
ControlPower *control_power_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_CONTROL_POWER_SKELETON (control_power_skeleton_get_type ())
#define CONTROL_POWER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_POWER_SKELETON, ControlPowerSkeleton))
#define CONTROL_POWER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTROL_POWER_SKELETON, ControlPowerSkeletonClass))
#define CONTROL_POWER_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTROL_POWER_SKELETON, ControlPowerSkeletonClass))
#define IS_CONTROL_POWER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_POWER_SKELETON))
#define IS_CONTROL_POWER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTROL_POWER_SKELETON))

typedef struct _ControlPowerSkeleton ControlPowerSkeleton;
typedef struct _ControlPowerSkeletonClass ControlPowerSkeletonClass;
typedef struct _ControlPowerSkeletonPrivate ControlPowerSkeletonPrivate;

struct _ControlPowerSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  ControlPowerSkeletonPrivate *priv;
};

struct _ControlPowerSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType control_power_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ControlPowerSkeleton, g_object_unref)
#endif

ControlPower *control_power_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.control.Checkstop */

#define TYPE_CONTROL_CHECKSTOP (control_checkstop_get_type ())
#define CONTROL_CHECKSTOP(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_CHECKSTOP, ControlCheckstop))
#define IS_CONTROL_CHECKSTOP(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_CHECKSTOP))
#define CONTROL_CHECKSTOP_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_CONTROL_CHECKSTOP, ControlCheckstopIface))

struct _ControlCheckstop;
typedef struct _ControlCheckstop ControlCheckstop;
typedef struct _ControlCheckstopIface ControlCheckstopIface;

struct _ControlCheckstopIface
{
  GTypeInterface parent_iface;
};

GType control_checkstop_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *control_checkstop_interface_info (void);
guint control_checkstop_override_properties (GObjectClass *klass, guint property_id_begin);


/* ---- */

#define TYPE_CONTROL_CHECKSTOP_PROXY (control_checkstop_proxy_get_type ())
#define CONTROL_CHECKSTOP_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_CHECKSTOP_PROXY, ControlCheckstopProxy))
#define CONTROL_CHECKSTOP_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTROL_CHECKSTOP_PROXY, ControlCheckstopProxyClass))
#define CONTROL_CHECKSTOP_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTROL_CHECKSTOP_PROXY, ControlCheckstopProxyClass))
#define IS_CONTROL_CHECKSTOP_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_CHECKSTOP_PROXY))
#define IS_CONTROL_CHECKSTOP_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTROL_CHECKSTOP_PROXY))

typedef struct _ControlCheckstopProxy ControlCheckstopProxy;
typedef struct _ControlCheckstopProxyClass ControlCheckstopProxyClass;
typedef struct _ControlCheckstopProxyPrivate ControlCheckstopProxyPrivate;

struct _ControlCheckstopProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  ControlCheckstopProxyPrivate *priv;
};

struct _ControlCheckstopProxyClass
{
  GDBusProxyClass parent_class;
};

GType control_checkstop_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ControlCheckstopProxy, g_object_unref)
#endif

void control_checkstop_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
ControlCheckstop *control_checkstop_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
ControlCheckstop *control_checkstop_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void control_checkstop_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
ControlCheckstop *control_checkstop_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
ControlCheckstop *control_checkstop_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_CONTROL_CHECKSTOP_SKELETON (control_checkstop_skeleton_get_type ())
#define CONTROL_CHECKSTOP_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTROL_CHECKSTOP_SKELETON, ControlCheckstopSkeleton))
#define CONTROL_CHECKSTOP_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTROL_CHECKSTOP_SKELETON, ControlCheckstopSkeletonClass))
#define CONTROL_CHECKSTOP_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTROL_CHECKSTOP_SKELETON, ControlCheckstopSkeletonClass))
#define IS_CONTROL_CHECKSTOP_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTROL_CHECKSTOP_SKELETON))
#define IS_CONTROL_CHECKSTOP_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTROL_CHECKSTOP_SKELETON))

typedef struct _ControlCheckstopSkeleton ControlCheckstopSkeleton;
typedef struct _ControlCheckstopSkeletonClass ControlCheckstopSkeletonClass;
typedef struct _ControlCheckstopSkeletonPrivate ControlCheckstopSkeletonPrivate;

struct _ControlCheckstopSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  ControlCheckstopSkeletonPrivate *priv;
};

struct _ControlCheckstopSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType control_checkstop_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ControlCheckstopSkeleton, g_object_unref)
#endif

ControlCheckstop *control_checkstop_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.Watchdog */

#define TYPE_WATCHDOG (watchdog_get_type ())
#define WATCHDOG(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_WATCHDOG, Watchdog))
#define IS_WATCHDOG(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_WATCHDOG))
#define WATCHDOG_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_WATCHDOG, WatchdogIface))

struct _Watchdog;
typedef struct _Watchdog Watchdog;
typedef struct _WatchdogIface WatchdogIface;

struct _WatchdogIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_poke) (
    Watchdog *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_set) (
    Watchdog *object,
    GDBusMethodInvocation *invocation,
    gint arg_interval);

  gboolean (*handle_start) (
    Watchdog *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_stop) (
    Watchdog *object,
    GDBusMethodInvocation *invocation);

  gint  (*get_poll_interval) (Watchdog *object);

  gint  (*get_watchdog) (Watchdog *object);

  void (*watchdog_error) (
    Watchdog *object);

};

GType watchdog_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *watchdog_interface_info (void);
guint watchdog_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void watchdog_complete_start (
    Watchdog *object,
    GDBusMethodInvocation *invocation);

void watchdog_complete_poke (
    Watchdog *object,
    GDBusMethodInvocation *invocation);

void watchdog_complete_stop (
    Watchdog *object,
    GDBusMethodInvocation *invocation);

void watchdog_complete_set (
    Watchdog *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void watchdog_emit_watchdog_error (
    Watchdog *object);



/* D-Bus method calls: */
void watchdog_call_start (
    Watchdog *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean watchdog_call_start_finish (
    Watchdog *proxy,
    GAsyncResult *res,
    GError **error);

gboolean watchdog_call_start_sync (
    Watchdog *proxy,
    GCancellable *cancellable,
    GError **error);

void watchdog_call_poke (
    Watchdog *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean watchdog_call_poke_finish (
    Watchdog *proxy,
    GAsyncResult *res,
    GError **error);

gboolean watchdog_call_poke_sync (
    Watchdog *proxy,
    GCancellable *cancellable,
    GError **error);

void watchdog_call_stop (
    Watchdog *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean watchdog_call_stop_finish (
    Watchdog *proxy,
    GAsyncResult *res,
    GError **error);

gboolean watchdog_call_stop_sync (
    Watchdog *proxy,
    GCancellable *cancellable,
    GError **error);

void watchdog_call_set (
    Watchdog *proxy,
    gint arg_interval,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean watchdog_call_set_finish (
    Watchdog *proxy,
    GAsyncResult *res,
    GError **error);

gboolean watchdog_call_set_sync (
    Watchdog *proxy,
    gint arg_interval,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gint watchdog_get_watchdog (Watchdog *object);
void watchdog_set_watchdog (Watchdog *object, gint value);

gint watchdog_get_poll_interval (Watchdog *object);
void watchdog_set_poll_interval (Watchdog *object, gint value);


/* ---- */

#define TYPE_WATCHDOG_PROXY (watchdog_proxy_get_type ())
#define WATCHDOG_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_WATCHDOG_PROXY, WatchdogProxy))
#define WATCHDOG_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_WATCHDOG_PROXY, WatchdogProxyClass))
#define WATCHDOG_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_WATCHDOG_PROXY, WatchdogProxyClass))
#define IS_WATCHDOG_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_WATCHDOG_PROXY))
#define IS_WATCHDOG_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_WATCHDOG_PROXY))

typedef struct _WatchdogProxy WatchdogProxy;
typedef struct _WatchdogProxyClass WatchdogProxyClass;
typedef struct _WatchdogProxyPrivate WatchdogProxyPrivate;

struct _WatchdogProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  WatchdogProxyPrivate *priv;
};

struct _WatchdogProxyClass
{
  GDBusProxyClass parent_class;
};

GType watchdog_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (WatchdogProxy, g_object_unref)
#endif

void watchdog_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Watchdog *watchdog_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
Watchdog *watchdog_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void watchdog_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Watchdog *watchdog_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
Watchdog *watchdog_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_WATCHDOG_SKELETON (watchdog_skeleton_get_type ())
#define WATCHDOG_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_WATCHDOG_SKELETON, WatchdogSkeleton))
#define WATCHDOG_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_WATCHDOG_SKELETON, WatchdogSkeletonClass))
#define WATCHDOG_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_WATCHDOG_SKELETON, WatchdogSkeletonClass))
#define IS_WATCHDOG_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_WATCHDOG_SKELETON))
#define IS_WATCHDOG_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_WATCHDOG_SKELETON))

typedef struct _WatchdogSkeleton WatchdogSkeleton;
typedef struct _WatchdogSkeletonClass WatchdogSkeletonClass;
typedef struct _WatchdogSkeletonPrivate WatchdogSkeletonPrivate;

struct _WatchdogSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  WatchdogSkeletonPrivate *priv;
};

struct _WatchdogSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType watchdog_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (WatchdogSkeleton, g_object_unref)
#endif

Watchdog *watchdog_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.EventLog */

#define TYPE_EVENT_LOG (event_log_get_type ())
#define EVENT_LOG(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_EVENT_LOG, EventLog))
#define IS_EVENT_LOG(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_EVENT_LOG))
#define EVENT_LOG_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_EVENT_LOG, EventLogIface))

struct _EventLog;
typedef struct _EventLog EventLog;
typedef struct _EventLogIface EventLogIface;

struct _EventLogIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_get_event_log) (
    EventLog *object,
    GDBusMethodInvocation *invocation);

  void (*event_log) (
    EventLog *object,
    gint arg_priority,
    const gchar *arg_message,
    gint arg_rc);

};

GType event_log_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *event_log_interface_info (void);
guint event_log_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void event_log_complete_get_event_log (
    EventLog *object,
    GDBusMethodInvocation *invocation,
    GVariant *log);



/* D-Bus signal emissions functions: */
void event_log_emit_event_log (
    EventLog *object,
    gint arg_priority,
    const gchar *arg_message,
    gint arg_rc);



/* D-Bus method calls: */
void event_log_call_get_event_log (
    EventLog *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean event_log_call_get_event_log_finish (
    EventLog *proxy,
    GVariant **out_log,
    GAsyncResult *res,
    GError **error);

gboolean event_log_call_get_event_log_sync (
    EventLog *proxy,
    GVariant **out_log,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define TYPE_EVENT_LOG_PROXY (event_log_proxy_get_type ())
#define EVENT_LOG_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_EVENT_LOG_PROXY, EventLogProxy))
#define EVENT_LOG_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_EVENT_LOG_PROXY, EventLogProxyClass))
#define EVENT_LOG_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_EVENT_LOG_PROXY, EventLogProxyClass))
#define IS_EVENT_LOG_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_EVENT_LOG_PROXY))
#define IS_EVENT_LOG_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_EVENT_LOG_PROXY))

typedef struct _EventLogProxy EventLogProxy;
typedef struct _EventLogProxyClass EventLogProxyClass;
typedef struct _EventLogProxyPrivate EventLogProxyPrivate;

struct _EventLogProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  EventLogProxyPrivate *priv;
};

struct _EventLogProxyClass
{
  GDBusProxyClass parent_class;
};

GType event_log_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (EventLogProxy, g_object_unref)
#endif

void event_log_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
EventLog *event_log_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
EventLog *event_log_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void event_log_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
EventLog *event_log_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
EventLog *event_log_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_EVENT_LOG_SKELETON (event_log_skeleton_get_type ())
#define EVENT_LOG_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_EVENT_LOG_SKELETON, EventLogSkeleton))
#define EVENT_LOG_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_EVENT_LOG_SKELETON, EventLogSkeletonClass))
#define EVENT_LOG_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_EVENT_LOG_SKELETON, EventLogSkeletonClass))
#define IS_EVENT_LOG_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_EVENT_LOG_SKELETON))
#define IS_EVENT_LOG_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_EVENT_LOG_SKELETON))

typedef struct _EventLogSkeleton EventLogSkeleton;
typedef struct _EventLogSkeletonClass EventLogSkeletonClass;
typedef struct _EventLogSkeletonPrivate EventLogSkeletonPrivate;

struct _EventLogSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  EventLogSkeletonPrivate *priv;
};

struct _EventLogSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType event_log_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (EventLogSkeleton, g_object_unref)
#endif

EventLog *event_log_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.Flash */

#define TYPE_FLASH (flash_get_type ())
#define FLASH(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_FLASH, Flash))
#define IS_FLASH(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_FLASH))
#define FLASH_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_FLASH, FlashIface))

struct _Flash;
typedef struct _Flash Flash;
typedef struct _FlashIface FlashIface;

struct _FlashIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_done) (
    Flash *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_error) (
    Flash *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_message);

  gboolean (*handle_init) (
    Flash *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_update) (
    Flash *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_filename);

  gboolean (*handle_update_via_tftp) (
    Flash *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_url,
    const gchar *arg_filename);

  const gchar * (*get_filename) (Flash *object);

  const gchar * (*get_flasher_instance) (Flash *object);

  const gchar * (*get_flasher_name) (Flash *object);

  const gchar * (*get_flasher_path) (Flash *object);

  const gchar * (*get_status) (Flash *object);

  void (*download) (
    Flash *object,
    const gchar *arg_url,
    const gchar *arg_filename);

  void (*updated) (
    Flash *object);

};

GType flash_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *flash_interface_info (void);
guint flash_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void flash_complete_update (
    Flash *object,
    GDBusMethodInvocation *invocation);

void flash_complete_error (
    Flash *object,
    GDBusMethodInvocation *invocation);

void flash_complete_done (
    Flash *object,
    GDBusMethodInvocation *invocation);

void flash_complete_update_via_tftp (
    Flash *object,
    GDBusMethodInvocation *invocation);

void flash_complete_init (
    Flash *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void flash_emit_updated (
    Flash *object);

void flash_emit_download (
    Flash *object,
    const gchar *arg_url,
    const gchar *arg_filename);



/* D-Bus method calls: */
void flash_call_update (
    Flash *proxy,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean flash_call_update_finish (
    Flash *proxy,
    GAsyncResult *res,
    GError **error);

gboolean flash_call_update_sync (
    Flash *proxy,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GError **error);

void flash_call_error (
    Flash *proxy,
    const gchar *arg_message,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean flash_call_error_finish (
    Flash *proxy,
    GAsyncResult *res,
    GError **error);

gboolean flash_call_error_sync (
    Flash *proxy,
    const gchar *arg_message,
    GCancellable *cancellable,
    GError **error);

void flash_call_done (
    Flash *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean flash_call_done_finish (
    Flash *proxy,
    GAsyncResult *res,
    GError **error);

gboolean flash_call_done_sync (
    Flash *proxy,
    GCancellable *cancellable,
    GError **error);

void flash_call_update_via_tftp (
    Flash *proxy,
    const gchar *arg_url,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean flash_call_update_via_tftp_finish (
    Flash *proxy,
    GAsyncResult *res,
    GError **error);

gboolean flash_call_update_via_tftp_sync (
    Flash *proxy,
    const gchar *arg_url,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GError **error);

void flash_call_init (
    Flash *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean flash_call_init_finish (
    Flash *proxy,
    GAsyncResult *res,
    GError **error);

gboolean flash_call_init_sync (
    Flash *proxy,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *flash_get_filename (Flash *object);
gchar *flash_dup_filename (Flash *object);
void flash_set_filename (Flash *object, const gchar *value);

const gchar *flash_get_flasher_path (Flash *object);
gchar *flash_dup_flasher_path (Flash *object);
void flash_set_flasher_path (Flash *object, const gchar *value);

const gchar *flash_get_flasher_name (Flash *object);
gchar *flash_dup_flasher_name (Flash *object);
void flash_set_flasher_name (Flash *object, const gchar *value);

const gchar *flash_get_flasher_instance (Flash *object);
gchar *flash_dup_flasher_instance (Flash *object);
void flash_set_flasher_instance (Flash *object, const gchar *value);

const gchar *flash_get_status (Flash *object);
gchar *flash_dup_status (Flash *object);
void flash_set_status (Flash *object, const gchar *value);


/* ---- */

#define TYPE_FLASH_PROXY (flash_proxy_get_type ())
#define FLASH_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_FLASH_PROXY, FlashProxy))
#define FLASH_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_FLASH_PROXY, FlashProxyClass))
#define FLASH_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_FLASH_PROXY, FlashProxyClass))
#define IS_FLASH_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_FLASH_PROXY))
#define IS_FLASH_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_FLASH_PROXY))

typedef struct _FlashProxy FlashProxy;
typedef struct _FlashProxyClass FlashProxyClass;
typedef struct _FlashProxyPrivate FlashProxyPrivate;

struct _FlashProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  FlashProxyPrivate *priv;
};

struct _FlashProxyClass
{
  GDBusProxyClass parent_class;
};

GType flash_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FlashProxy, g_object_unref)
#endif

void flash_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Flash *flash_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
Flash *flash_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void flash_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Flash *flash_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
Flash *flash_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_FLASH_SKELETON (flash_skeleton_get_type ())
#define FLASH_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_FLASH_SKELETON, FlashSkeleton))
#define FLASH_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_FLASH_SKELETON, FlashSkeletonClass))
#define FLASH_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_FLASH_SKELETON, FlashSkeletonClass))
#define IS_FLASH_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_FLASH_SKELETON))
#define IS_FLASH_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_FLASH_SKELETON))

typedef struct _FlashSkeleton FlashSkeleton;
typedef struct _FlashSkeletonClass FlashSkeletonClass;
typedef struct _FlashSkeletonPrivate FlashSkeletonPrivate;

struct _FlashSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  FlashSkeletonPrivate *priv;
};

struct _FlashSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType flash_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FlashSkeleton, g_object_unref)
#endif

Flash *flash_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.FlashControl */

#define TYPE_FLASH_CONTROL (flash_control_get_type ())
#define FLASH_CONTROL(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_FLASH_CONTROL, FlashControl))
#define IS_FLASH_CONTROL(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_FLASH_CONTROL))
#define FLASH_CONTROL_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_FLASH_CONTROL, FlashControlIface))

struct _FlashControl;
typedef struct _FlashControl FlashControl;
typedef struct _FlashControlIface FlashControlIface;

struct _FlashControlIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_flash) (
    FlashControl *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type,
    const gchar *arg_filename);

  const gchar * (*get_filename) (FlashControl *object);

  const gchar * (*get_type_) (FlashControl *object);

  void (*done) (
    FlashControl *object,
    const gchar *arg_filename);

  void (*error) (
    FlashControl *object,
    const gchar *arg_filename);

  void (*progress) (
    FlashControl *object,
    const gchar *arg_filename,
    guchar arg_progress);

};

GType flash_control_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *flash_control_interface_info (void);
guint flash_control_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void flash_control_complete_flash (
    FlashControl *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void flash_control_emit_done (
    FlashControl *object,
    const gchar *arg_filename);

void flash_control_emit_error (
    FlashControl *object,
    const gchar *arg_filename);

void flash_control_emit_progress (
    FlashControl *object,
    const gchar *arg_filename,
    guchar arg_progress);



/* D-Bus method calls: */
void flash_control_call_flash (
    FlashControl *proxy,
    const gchar *arg_type,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean flash_control_call_flash_finish (
    FlashControl *proxy,
    GAsyncResult *res,
    GError **error);

gboolean flash_control_call_flash_sync (
    FlashControl *proxy,
    const gchar *arg_type,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *flash_control_get_filename (FlashControl *object);
gchar *flash_control_dup_filename (FlashControl *object);
void flash_control_set_filename (FlashControl *object, const gchar *value);

const gchar *flash_control_get_type_ (FlashControl *object);
gchar *flash_control_dup_type_ (FlashControl *object);
void flash_control_set_type_ (FlashControl *object, const gchar *value);


/* ---- */

#define TYPE_FLASH_CONTROL_PROXY (flash_control_proxy_get_type ())
#define FLASH_CONTROL_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_FLASH_CONTROL_PROXY, FlashControlProxy))
#define FLASH_CONTROL_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_FLASH_CONTROL_PROXY, FlashControlProxyClass))
#define FLASH_CONTROL_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_FLASH_CONTROL_PROXY, FlashControlProxyClass))
#define IS_FLASH_CONTROL_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_FLASH_CONTROL_PROXY))
#define IS_FLASH_CONTROL_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_FLASH_CONTROL_PROXY))

typedef struct _FlashControlProxy FlashControlProxy;
typedef struct _FlashControlProxyClass FlashControlProxyClass;
typedef struct _FlashControlProxyPrivate FlashControlProxyPrivate;

struct _FlashControlProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  FlashControlProxyPrivate *priv;
};

struct _FlashControlProxyClass
{
  GDBusProxyClass parent_class;
};

GType flash_control_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FlashControlProxy, g_object_unref)
#endif

void flash_control_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
FlashControl *flash_control_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
FlashControl *flash_control_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void flash_control_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
FlashControl *flash_control_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
FlashControl *flash_control_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_FLASH_CONTROL_SKELETON (flash_control_skeleton_get_type ())
#define FLASH_CONTROL_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_FLASH_CONTROL_SKELETON, FlashControlSkeleton))
#define FLASH_CONTROL_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_FLASH_CONTROL_SKELETON, FlashControlSkeletonClass))
#define FLASH_CONTROL_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_FLASH_CONTROL_SKELETON, FlashControlSkeletonClass))
#define IS_FLASH_CONTROL_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_FLASH_CONTROL_SKELETON))
#define IS_FLASH_CONTROL_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_FLASH_CONTROL_SKELETON))

typedef struct _FlashControlSkeleton FlashControlSkeleton;
typedef struct _FlashControlSkeletonClass FlashControlSkeletonClass;
typedef struct _FlashControlSkeletonPrivate FlashControlSkeletonPrivate;

struct _FlashControlSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  FlashControlSkeletonPrivate *priv;
};

struct _FlashControlSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType flash_control_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FlashControlSkeleton, g_object_unref)
#endif

FlashControl *flash_control_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.Button */

#define TYPE_BUTTON (button_get_type ())
#define BUTTON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_BUTTON, Button))
#define IS_BUTTON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_BUTTON))
#define BUTTON_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_BUTTON, ButtonIface))

struct _Button;
typedef struct _Button Button;
typedef struct _ButtonIface ButtonIface;

struct _ButtonIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_is_on) (
    Button *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_sim_long_press) (
    Button *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_sim_press) (
    Button *object,
    GDBusMethodInvocation *invocation);

  gboolean  (*get_state) (Button *object);

  guint64  (*get_timer) (Button *object);

  void (*pressed) (
    Button *object);

  void (*pressed_long) (
    Button *object);

  void (*released) (
    Button *object);

};

GType button_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *button_interface_info (void);
guint button_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void button_complete_is_on (
    Button *object,
    GDBusMethodInvocation *invocation,
    gboolean state);

void button_complete_sim_press (
    Button *object,
    GDBusMethodInvocation *invocation);

void button_complete_sim_long_press (
    Button *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void button_emit_released (
    Button *object);

void button_emit_pressed (
    Button *object);

void button_emit_pressed_long (
    Button *object);



/* D-Bus method calls: */
void button_call_is_on (
    Button *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean button_call_is_on_finish (
    Button *proxy,
    gboolean *out_state,
    GAsyncResult *res,
    GError **error);

gboolean button_call_is_on_sync (
    Button *proxy,
    gboolean *out_state,
    GCancellable *cancellable,
    GError **error);

void button_call_sim_press (
    Button *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean button_call_sim_press_finish (
    Button *proxy,
    GAsyncResult *res,
    GError **error);

gboolean button_call_sim_press_sync (
    Button *proxy,
    GCancellable *cancellable,
    GError **error);

void button_call_sim_long_press (
    Button *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean button_call_sim_long_press_finish (
    Button *proxy,
    GAsyncResult *res,
    GError **error);

gboolean button_call_sim_long_press_sync (
    Button *proxy,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gboolean button_get_state (Button *object);
void button_set_state (Button *object, gboolean value);

guint64 button_get_timer (Button *object);
void button_set_timer (Button *object, guint64 value);


/* ---- */

#define TYPE_BUTTON_PROXY (button_proxy_get_type ())
#define BUTTON_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_BUTTON_PROXY, ButtonProxy))
#define BUTTON_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_BUTTON_PROXY, ButtonProxyClass))
#define BUTTON_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_BUTTON_PROXY, ButtonProxyClass))
#define IS_BUTTON_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_BUTTON_PROXY))
#define IS_BUTTON_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_BUTTON_PROXY))

typedef struct _ButtonProxy ButtonProxy;
typedef struct _ButtonProxyClass ButtonProxyClass;
typedef struct _ButtonProxyPrivate ButtonProxyPrivate;

struct _ButtonProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  ButtonProxyPrivate *priv;
};

struct _ButtonProxyClass
{
  GDBusProxyClass parent_class;
};

GType button_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ButtonProxy, g_object_unref)
#endif

void button_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Button *button_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
Button *button_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void button_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Button *button_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
Button *button_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_BUTTON_SKELETON (button_skeleton_get_type ())
#define BUTTON_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_BUTTON_SKELETON, ButtonSkeleton))
#define BUTTON_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_BUTTON_SKELETON, ButtonSkeletonClass))
#define BUTTON_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_BUTTON_SKELETON, ButtonSkeletonClass))
#define IS_BUTTON_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_BUTTON_SKELETON))
#define IS_BUTTON_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_BUTTON_SKELETON))

typedef struct _ButtonSkeleton ButtonSkeleton;
typedef struct _ButtonSkeletonClass ButtonSkeletonClass;
typedef struct _ButtonSkeletonPrivate ButtonSkeletonPrivate;

struct _ButtonSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  ButtonSkeletonPrivate *priv;
};

struct _ButtonSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType button_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ButtonSkeleton, g_object_unref)
#endif

Button *button_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.Led */

#define TYPE_LED (led_get_type ())
#define LED(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_LED, Led))
#define IS_LED(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_LED))
#define LED_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_LED, LedIface))

struct _Led;
typedef struct _Led Led;
typedef struct _LedIface LedIface;

struct _LedIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_set_blink_fast) (
    Led *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_set_blink_slow) (
    Led *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_set_off) (
    Led *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_set_on) (
    Led *object,
    GDBusMethodInvocation *invocation);

  gint  (*get_color) (Led *object);

  const gchar * (*get_function) (Led *object);

  const gchar * (*get_state) (Led *object);

};

GType led_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *led_interface_info (void);
guint led_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void led_complete_set_on (
    Led *object,
    GDBusMethodInvocation *invocation);

void led_complete_set_off (
    Led *object,
    GDBusMethodInvocation *invocation);

void led_complete_set_blink_slow (
    Led *object,
    GDBusMethodInvocation *invocation);

void led_complete_set_blink_fast (
    Led *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void led_call_set_on (
    Led *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean led_call_set_on_finish (
    Led *proxy,
    GAsyncResult *res,
    GError **error);

gboolean led_call_set_on_sync (
    Led *proxy,
    GCancellable *cancellable,
    GError **error);

void led_call_set_off (
    Led *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean led_call_set_off_finish (
    Led *proxy,
    GAsyncResult *res,
    GError **error);

gboolean led_call_set_off_sync (
    Led *proxy,
    GCancellable *cancellable,
    GError **error);

void led_call_set_blink_slow (
    Led *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean led_call_set_blink_slow_finish (
    Led *proxy,
    GAsyncResult *res,
    GError **error);

gboolean led_call_set_blink_slow_sync (
    Led *proxy,
    GCancellable *cancellable,
    GError **error);

void led_call_set_blink_fast (
    Led *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean led_call_set_blink_fast_finish (
    Led *proxy,
    GAsyncResult *res,
    GError **error);

gboolean led_call_set_blink_fast_sync (
    Led *proxy,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gint led_get_color (Led *object);
void led_set_color (Led *object, gint value);

const gchar *led_get_function (Led *object);
gchar *led_dup_function (Led *object);
void led_set_function (Led *object, const gchar *value);

const gchar *led_get_state (Led *object);
gchar *led_dup_state (Led *object);
void led_set_state (Led *object, const gchar *value);


/* ---- */

#define TYPE_LED_PROXY (led_proxy_get_type ())
#define LED_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_LED_PROXY, LedProxy))
#define LED_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_LED_PROXY, LedProxyClass))
#define LED_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_LED_PROXY, LedProxyClass))
#define IS_LED_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_LED_PROXY))
#define IS_LED_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_LED_PROXY))

typedef struct _LedProxy LedProxy;
typedef struct _LedProxyClass LedProxyClass;
typedef struct _LedProxyPrivate LedProxyPrivate;

struct _LedProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  LedProxyPrivate *priv;
};

struct _LedProxyClass
{
  GDBusProxyClass parent_class;
};

GType led_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (LedProxy, g_object_unref)
#endif

void led_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Led *led_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
Led *led_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void led_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
Led *led_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
Led *led_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_LED_SKELETON (led_skeleton_get_type ())
#define LED_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_LED_SKELETON, LedSkeleton))
#define LED_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_LED_SKELETON, LedSkeletonClass))
#define LED_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_LED_SKELETON, LedSkeletonClass))
#define IS_LED_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_LED_SKELETON))
#define IS_LED_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_LED_SKELETON))

typedef struct _LedSkeleton LedSkeleton;
typedef struct _LedSkeletonClass LedSkeletonClass;
typedef struct _LedSkeletonPrivate LedSkeletonPrivate;

struct _LedSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  LedSkeletonPrivate *priv;
};

struct _LedSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType led_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (LedSkeleton, g_object_unref)
#endif

Led *led_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.openbmc.HostIpmi */

#define TYPE_HOST_IPMI (host_ipmi_get_type ())
#define HOST_IPMI(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_HOST_IPMI, HostIpmi))
#define IS_HOST_IPMI(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_HOST_IPMI))
#define HOST_IPMI_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_HOST_IPMI, HostIpmiIface))

struct _HostIpmi;
typedef struct _HostIpmi HostIpmi;
typedef struct _HostIpmiIface HostIpmiIface;

struct _HostIpmiIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_send_message) (
    HostIpmi *object,
    GDBusMethodInvocation *invocation,
    guchar arg_seq,
    guchar arg_netfn,
    guchar arg_cmd,
    const gchar *arg_data);

  void (*received_message) (
    HostIpmi *object,
    guchar arg_seq,
    guchar arg_netfn,
    guchar arg_cmd,
    const gchar *arg_data);

};

GType host_ipmi_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *host_ipmi_interface_info (void);
guint host_ipmi_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void host_ipmi_complete_send_message (
    HostIpmi *object,
    GDBusMethodInvocation *invocation,
    gint64 unnamed_arg4);



/* D-Bus signal emissions functions: */
void host_ipmi_emit_received_message (
    HostIpmi *object,
    guchar arg_seq,
    guchar arg_netfn,
    guchar arg_cmd,
    const gchar *arg_data);



/* D-Bus method calls: */
void host_ipmi_call_send_message (
    HostIpmi *proxy,
    guchar arg_seq,
    guchar arg_netfn,
    guchar arg_cmd,
    const gchar *arg_data,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean host_ipmi_call_send_message_finish (
    HostIpmi *proxy,
    gint64 *out_unnamed_arg4,
    GAsyncResult *res,
    GError **error);

gboolean host_ipmi_call_send_message_sync (
    HostIpmi *proxy,
    guchar arg_seq,
    guchar arg_netfn,
    guchar arg_cmd,
    const gchar *arg_data,
    gint64 *out_unnamed_arg4,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define TYPE_HOST_IPMI_PROXY (host_ipmi_proxy_get_type ())
#define HOST_IPMI_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_HOST_IPMI_PROXY, HostIpmiProxy))
#define HOST_IPMI_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_HOST_IPMI_PROXY, HostIpmiProxyClass))
#define HOST_IPMI_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_HOST_IPMI_PROXY, HostIpmiProxyClass))
#define IS_HOST_IPMI_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_HOST_IPMI_PROXY))
#define IS_HOST_IPMI_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_HOST_IPMI_PROXY))

typedef struct _HostIpmiProxy HostIpmiProxy;
typedef struct _HostIpmiProxyClass HostIpmiProxyClass;
typedef struct _HostIpmiProxyPrivate HostIpmiProxyPrivate;

struct _HostIpmiProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  HostIpmiProxyPrivate *priv;
};

struct _HostIpmiProxyClass
{
  GDBusProxyClass parent_class;
};

GType host_ipmi_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (HostIpmiProxy, g_object_unref)
#endif

void host_ipmi_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
HostIpmi *host_ipmi_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
HostIpmi *host_ipmi_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void host_ipmi_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
HostIpmi *host_ipmi_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
HostIpmi *host_ipmi_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define TYPE_HOST_IPMI_SKELETON (host_ipmi_skeleton_get_type ())
#define HOST_IPMI_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_HOST_IPMI_SKELETON, HostIpmiSkeleton))
#define HOST_IPMI_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_HOST_IPMI_SKELETON, HostIpmiSkeletonClass))
#define HOST_IPMI_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_HOST_IPMI_SKELETON, HostIpmiSkeletonClass))
#define IS_HOST_IPMI_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_HOST_IPMI_SKELETON))
#define IS_HOST_IPMI_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_HOST_IPMI_SKELETON))

typedef struct _HostIpmiSkeleton HostIpmiSkeleton;
typedef struct _HostIpmiSkeletonClass HostIpmiSkeletonClass;
typedef struct _HostIpmiSkeletonPrivate HostIpmiSkeletonPrivate;

struct _HostIpmiSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  HostIpmiSkeletonPrivate *priv;
};

struct _HostIpmiSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType host_ipmi_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (HostIpmiSkeleton, g_object_unref)
#endif

HostIpmi *host_ipmi_skeleton_new (void);


/* ---- */

#define TYPE_OBJECT (object_get_type ())
#define OBJECT(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_OBJECT, Object))
#define IS_OBJECT(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_OBJECT))
#define OBJECT_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_OBJECT, Object))

struct _Object;
typedef struct _Object Object;
typedef struct _ObjectIface ObjectIface;

struct _ObjectIface
{
  GTypeInterface parent_iface;
};

GType object_get_type (void) G_GNUC_CONST;

Hwmon *object_get_hwmon (Object *object);
Fan *object_get_fan (Object *object);
SensorValue *object_get_sensor_value (Object *object);
SensorThreshold *object_get_sensor_threshold (Object *object);
SensorI2c *object_get_sensor_i2c (Object *object);
SensorMatch *object_get_sensor_match (Object *object);
Process *object_get_process (Object *object);
SharedResource *object_get_shared_resource (Object *object);
Control *object_get_control (Object *object);
ControlBmc *object_get_control_bmc (Object *object);
ControlHost *object_get_control_host (Object *object);
ControlPower *object_get_control_power (Object *object);
ControlCheckstop *object_get_control_checkstop (Object *object);
Watchdog *object_get_watchdog (Object *object);
EventLog *object_get_event_log (Object *object);
Flash *object_get_flash (Object *object);
FlashControl *object_get_flash_control (Object *object);
Button *object_get_button (Object *object);
Led *object_get_led (Object *object);
HostIpmi *object_get_host_ipmi (Object *object);
Hwmon *object_peek_hwmon (Object *object);
Fan *object_peek_fan (Object *object);
SensorValue *object_peek_sensor_value (Object *object);
SensorThreshold *object_peek_sensor_threshold (Object *object);
SensorI2c *object_peek_sensor_i2c (Object *object);
SensorMatch *object_peek_sensor_match (Object *object);
Process *object_peek_process (Object *object);
SharedResource *object_peek_shared_resource (Object *object);
Control *object_peek_control (Object *object);
ControlBmc *object_peek_control_bmc (Object *object);
ControlHost *object_peek_control_host (Object *object);
ControlPower *object_peek_control_power (Object *object);
ControlCheckstop *object_peek_control_checkstop (Object *object);
Watchdog *object_peek_watchdog (Object *object);
EventLog *object_peek_event_log (Object *object);
Flash *object_peek_flash (Object *object);
FlashControl *object_peek_flash_control (Object *object);
Button *object_peek_button (Object *object);
Led *object_peek_led (Object *object);
HostIpmi *object_peek_host_ipmi (Object *object);

#define TYPE_OBJECT_PROXY (object_proxy_get_type ())
#define OBJECT_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_OBJECT_PROXY, ObjectProxy))
#define OBJECT_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_OBJECT_PROXY, ObjectProxyClass))
#define OBJECT_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_OBJECT_PROXY, ObjectProxyClass))
#define IS_OBJECT_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_OBJECT_PROXY))
#define IS_OBJECT_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_OBJECT_PROXY))

typedef struct _ObjectProxy ObjectProxy;
typedef struct _ObjectProxyClass ObjectProxyClass;
typedef struct _ObjectProxyPrivate ObjectProxyPrivate;

struct _ObjectProxy
{
  /*< private >*/
  GDBusObjectProxy parent_instance;
  ObjectProxyPrivate *priv;
};

struct _ObjectProxyClass
{
  GDBusObjectProxyClass parent_class;
};

GType object_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ObjectProxy, g_object_unref)
#endif

ObjectProxy *object_proxy_new (GDBusConnection *connection, const gchar *object_path);

#define TYPE_OBJECT_SKELETON (object_skeleton_get_type ())
#define OBJECT_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_OBJECT_SKELETON, ObjectSkeleton))
#define OBJECT_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_OBJECT_SKELETON, ObjectSkeletonClass))
#define OBJECT_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_OBJECT_SKELETON, ObjectSkeletonClass))
#define IS_OBJECT_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_OBJECT_SKELETON))
#define IS_OBJECT_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_OBJECT_SKELETON))

typedef struct _ObjectSkeleton ObjectSkeleton;
typedef struct _ObjectSkeletonClass ObjectSkeletonClass;
typedef struct _ObjectSkeletonPrivate ObjectSkeletonPrivate;

struct _ObjectSkeleton
{
  /*< private >*/
  GDBusObjectSkeleton parent_instance;
  ObjectSkeletonPrivate *priv;
};

struct _ObjectSkeletonClass
{
  GDBusObjectSkeletonClass parent_class;
};

GType object_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ObjectSkeleton, g_object_unref)
#endif

ObjectSkeleton *object_skeleton_new (const gchar *object_path);
void object_skeleton_set_hwmon (ObjectSkeleton *object, Hwmon *interface_);
void object_skeleton_set_fan (ObjectSkeleton *object, Fan *interface_);
void object_skeleton_set_sensor_value (ObjectSkeleton *object, SensorValue *interface_);
void object_skeleton_set_sensor_threshold (ObjectSkeleton *object, SensorThreshold *interface_);
void object_skeleton_set_sensor_i2c (ObjectSkeleton *object, SensorI2c *interface_);
void object_skeleton_set_sensor_match (ObjectSkeleton *object, SensorMatch *interface_);
void object_skeleton_set_process (ObjectSkeleton *object, Process *interface_);
void object_skeleton_set_shared_resource (ObjectSkeleton *object, SharedResource *interface_);
void object_skeleton_set_control (ObjectSkeleton *object, Control *interface_);
void object_skeleton_set_control_bmc (ObjectSkeleton *object, ControlBmc *interface_);
void object_skeleton_set_control_host (ObjectSkeleton *object, ControlHost *interface_);
void object_skeleton_set_control_power (ObjectSkeleton *object, ControlPower *interface_);
void object_skeleton_set_control_checkstop (ObjectSkeleton *object, ControlCheckstop *interface_);
void object_skeleton_set_watchdog (ObjectSkeleton *object, Watchdog *interface_);
void object_skeleton_set_event_log (ObjectSkeleton *object, EventLog *interface_);
void object_skeleton_set_flash (ObjectSkeleton *object, Flash *interface_);
void object_skeleton_set_flash_control (ObjectSkeleton *object, FlashControl *interface_);
void object_skeleton_set_button (ObjectSkeleton *object, Button *interface_);
void object_skeleton_set_led (ObjectSkeleton *object, Led *interface_);
void object_skeleton_set_host_ipmi (ObjectSkeleton *object, HostIpmi *interface_);

/* ---- */

#define TYPE_OBJECT_MANAGER_CLIENT (object_manager_client_get_type ())
#define OBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_OBJECT_MANAGER_CLIENT, ObjectManagerClient))
#define OBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_OBJECT_MANAGER_CLIENT, ObjectManagerClientClass))
#define OBJECT_MANAGER_CLIENT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_OBJECT_MANAGER_CLIENT, ObjectManagerClientClass))
#define IS_OBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_OBJECT_MANAGER_CLIENT))
#define IS_OBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_OBJECT_MANAGER_CLIENT))

typedef struct _ObjectManagerClient ObjectManagerClient;
typedef struct _ObjectManagerClientClass ObjectManagerClientClass;
typedef struct _ObjectManagerClientPrivate ObjectManagerClientPrivate;

struct _ObjectManagerClient
{
  /*< private >*/
  GDBusObjectManagerClient parent_instance;
  ObjectManagerClientPrivate *priv;
};

struct _ObjectManagerClientClass
{
  GDBusObjectManagerClientClass parent_class;
};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ObjectManagerClient, g_object_unref)
#endif

GType object_manager_client_get_type (void) G_GNUC_CONST;

GType object_manager_client_get_proxy_type (GDBusObjectManagerClient *manager, const gchar *object_path, const gchar *interface_name, gpointer user_data);

void object_manager_client_new (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data);
GDBusObjectManager *object_manager_client_new_finish (
    GAsyncResult        *res,
    GError             **error);
GDBusObjectManager *object_manager_client_new_sync (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error);

void object_manager_client_new_for_bus (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data);
GDBusObjectManager *object_manager_client_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
GDBusObjectManager *object_manager_client_new_for_bus_sync (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error);


G_END_DECLS

#endif /* __OPENBMC_INTF_H__ */
