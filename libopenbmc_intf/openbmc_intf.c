/*
 * Generated by gdbus-codegen 2.48.2. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

#include "openbmc_intf.h"

#include <string.h>
#ifdef G_OS_UNIX
#  include <gio/gunixfdlist.h>
#endif

typedef struct
{
  GDBusArgInfo parent_struct;
  gboolean use_gvariant;
} _ExtendedGDBusArgInfo;

typedef struct
{
  GDBusMethodInfo parent_struct;
  const gchar *signal_name;
  gboolean pass_fdlist;
} _ExtendedGDBusMethodInfo;

typedef struct
{
  GDBusSignalInfo parent_struct;
  const gchar *signal_name;
} _ExtendedGDBusSignalInfo;

typedef struct
{
  GDBusPropertyInfo parent_struct;
  const gchar *hyphen_name;
  gboolean use_gvariant;
} _ExtendedGDBusPropertyInfo;

typedef struct
{
  GDBusInterfaceInfo parent_struct;
  const gchar *hyphen_name;
} _ExtendedGDBusInterfaceInfo;

typedef struct
{
  const _ExtendedGDBusPropertyInfo *info;
  guint prop_id;
  GValue orig_value; /* the value before the change */
} ChangedProperty;

static void
_changed_property_free (ChangedProperty *data)
{
  g_value_unset (&data->orig_value);
  g_free (data);
}

static gboolean
_g_strv_equal0 (gchar **a, gchar **b)
{
  gboolean ret = FALSE;
  guint n;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  if (g_strv_length (a) != g_strv_length (b))
    goto out;
  for (n = 0; a[n] != NULL; n++)
    if (g_strcmp0 (a[n], b[n]) != 0)
      goto out;
  ret = TRUE;
out:
  return ret;
}

static gboolean
_g_variant_equal0 (GVariant *a, GVariant *b)
{
  gboolean ret = FALSE;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  ret = g_variant_equal (a, b);
out:
  return ret;
}

G_GNUC_UNUSED static gboolean
_g_value_equal (const GValue *a, const GValue *b)
{
  gboolean ret = FALSE;
  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
  switch (G_VALUE_TYPE (a))
    {
      case G_TYPE_BOOLEAN:
        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
        break;
      case G_TYPE_UCHAR:
        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
        break;
      case G_TYPE_INT:
        ret = (g_value_get_int (a) == g_value_get_int (b));
        break;
      case G_TYPE_UINT:
        ret = (g_value_get_uint (a) == g_value_get_uint (b));
        break;
      case G_TYPE_INT64:
        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
        break;
      case G_TYPE_UINT64:
        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
        break;
      case G_TYPE_DOUBLE:
        {
          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
          gdouble da = g_value_get_double (a);
          gdouble db = g_value_get_double (b);
          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
        }
        break;
      case G_TYPE_STRING:
        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
        break;
      case G_TYPE_VARIANT:
        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
        break;
      default:
        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
        else
          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
        break;
    }
  return ret;
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.Hwmon
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:Hwmon
 * @title: Hwmon
 * @short_description: Generated C code for the org.openbmc.Hwmon D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-Hwmon.top_of_page">org.openbmc.Hwmon</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.Hwmon ---- */

static const _ExtendedGDBusPropertyInfo _hwmon_property_info_poll_interval =
{
  {
    -1,
    (gchar *) "poll_interval",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "poll-interval",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _hwmon_property_info_sysfs_path =
{
  {
    -1,
    (gchar *) "sysfs_path",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "sysfs-path",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _hwmon_property_info_scale =
{
  {
    -1,
    (gchar *) "scale",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "scale",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _hwmon_property_info_pointers[] =
{
  &_hwmon_property_info_poll_interval,
  &_hwmon_property_info_sysfs_path,
  &_hwmon_property_info_scale,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _hwmon_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.Hwmon",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_hwmon_property_info_pointers,
    NULL
  },
  "hwmon",
};


/**
 * hwmon_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-Hwmon.top_of_page">org.openbmc.Hwmon</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
hwmon_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_hwmon_interface_info.parent_struct;
}

/**
 * hwmon_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #Hwmon interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
hwmon_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "poll-interval");
  g_object_class_override_property (klass, property_id_begin++, "sysfs-path");
  g_object_class_override_property (klass, property_id_begin++, "scale");
  return property_id_begin - 1;
}



/**
 * Hwmon:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Hwmon.top_of_page">org.openbmc.Hwmon</link>.
 */

/**
 * HwmonIface:
 * @parent_iface: The parent interface.
 * @get_poll_interval: Getter for the #Hwmon:poll-interval property.
 * @get_scale: Getter for the #Hwmon:scale property.
 * @get_sysfs_path: Getter for the #Hwmon:sysfs-path property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Hwmon.top_of_page">org.openbmc.Hwmon</link>.
 */

typedef HwmonIface HwmonInterface;
G_DEFINE_INTERFACE (Hwmon, hwmon, G_TYPE_OBJECT);

static void
hwmon_default_init (HwmonIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * Hwmon:poll-interval:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Hwmon.poll_interval">"poll_interval"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("poll-interval", "poll_interval", "poll_interval", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Hwmon:sysfs-path:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Hwmon.sysfs_path">"sysfs_path"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("sysfs-path", "sysfs_path", "sysfs_path", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Hwmon:scale:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Hwmon.scale">"scale"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("scale", "scale", "scale", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * hwmon_get_poll_interval: (skip)
 * @object: A #Hwmon.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Hwmon.poll_interval">"poll_interval"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
hwmon_get_poll_interval (Hwmon *object)
{
  return HWMON_GET_IFACE (object)->get_poll_interval (object);
}

/**
 * hwmon_set_poll_interval: (skip)
 * @object: A #Hwmon.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Hwmon.poll_interval">"poll_interval"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
hwmon_set_poll_interval (Hwmon *object, gint value)
{
  g_object_set (G_OBJECT (object), "poll-interval", value, NULL);
}

/**
 * hwmon_get_sysfs_path: (skip)
 * @object: A #Hwmon.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Hwmon.sysfs_path">"sysfs_path"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use hwmon_dup_sysfs_path() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
hwmon_get_sysfs_path (Hwmon *object)
{
  return HWMON_GET_IFACE (object)->get_sysfs_path (object);
}

/**
 * hwmon_dup_sysfs_path: (skip)
 * @object: A #Hwmon.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-Hwmon.sysfs_path">"sysfs_path"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
hwmon_dup_sysfs_path (Hwmon *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "sysfs-path", &value, NULL);
  return value;
}

/**
 * hwmon_set_sysfs_path: (skip)
 * @object: A #Hwmon.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Hwmon.sysfs_path">"sysfs_path"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
hwmon_set_sysfs_path (Hwmon *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "sysfs-path", value, NULL);
}

/**
 * hwmon_get_scale: (skip)
 * @object: A #Hwmon.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Hwmon.scale">"scale"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
hwmon_get_scale (Hwmon *object)
{
  return HWMON_GET_IFACE (object)->get_scale (object);
}

/**
 * hwmon_set_scale: (skip)
 * @object: A #Hwmon.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Hwmon.scale">"scale"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
hwmon_set_scale (Hwmon *object, gint value)
{
  g_object_set (G_OBJECT (object), "scale", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * HwmonProxy:
 *
 * The #HwmonProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * HwmonProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #HwmonProxy.
 */

struct _HwmonProxyPrivate
{
  GData *qdata;
};

static void hwmon_proxy_iface_init (HwmonIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (HwmonProxy, hwmon_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (HwmonProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_HWMON, hwmon_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (HwmonProxy, hwmon_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_HWMON, hwmon_proxy_iface_init));

#endif
static void
hwmon_proxy_finalize (GObject *object)
{
  HwmonProxy *proxy = HWMON_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (hwmon_proxy_parent_class)->finalize (object);
}

static void
hwmon_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _hwmon_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
hwmon_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.Hwmon: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
hwmon_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _hwmon_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.Hwmon", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) hwmon_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
hwmon_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_hwmon_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_HWMON);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_HWMON);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
hwmon_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  HwmonProxy *proxy = HWMON_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_hwmon_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_hwmon_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gint 
hwmon_proxy_get_poll_interval (Hwmon *object)
{
  HwmonProxy *proxy = HWMON_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "poll_interval");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
hwmon_proxy_get_sysfs_path (Hwmon *object)
{
  HwmonProxy *proxy = HWMON_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "sysfs_path");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
hwmon_proxy_get_scale (Hwmon *object)
{
  HwmonProxy *proxy = HWMON_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "scale");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
hwmon_proxy_init (HwmonProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = hwmon_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_HWMON_PROXY, HwmonProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), hwmon_interface_info ());
}

static void
hwmon_proxy_class_init (HwmonProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = hwmon_proxy_finalize;
  gobject_class->get_property = hwmon_proxy_get_property;
  gobject_class->set_property = hwmon_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = hwmon_proxy_g_signal;
  proxy_class->g_properties_changed = hwmon_proxy_g_properties_changed;

  hwmon_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (HwmonProxyPrivate));
#endif
}

static void
hwmon_proxy_iface_init (HwmonIface *iface)
{
  iface->get_poll_interval = hwmon_proxy_get_poll_interval;
  iface->get_sysfs_path = hwmon_proxy_get_sysfs_path;
  iface->get_scale = hwmon_proxy_get_scale;
}

/**
 * hwmon_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Hwmon.top_of_page">org.openbmc.Hwmon</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call hwmon_proxy_new_finish() to get the result of the operation.
 *
 * See hwmon_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
hwmon_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_HWMON_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Hwmon", NULL);
}

/**
 * hwmon_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to hwmon_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with hwmon_proxy_new().
 *
 * Returns: (transfer full) (type HwmonProxy): The constructed proxy object or %NULL if @error is set.
 */
Hwmon *
hwmon_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return HWMON (ret);
  else
    return NULL;
}

/**
 * hwmon_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Hwmon.top_of_page">org.openbmc.Hwmon</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See hwmon_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type HwmonProxy): The constructed proxy object or %NULL if @error is set.
 */
Hwmon *
hwmon_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_HWMON_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Hwmon", NULL);
  if (ret != NULL)
    return HWMON (ret);
  else
    return NULL;
}


/**
 * hwmon_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like hwmon_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call hwmon_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See hwmon_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
hwmon_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_HWMON_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Hwmon", NULL);
}

/**
 * hwmon_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to hwmon_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with hwmon_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type HwmonProxy): The constructed proxy object or %NULL if @error is set.
 */
Hwmon *
hwmon_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return HWMON (ret);
  else
    return NULL;
}

/**
 * hwmon_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like hwmon_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See hwmon_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type HwmonProxy): The constructed proxy object or %NULL if @error is set.
 */
Hwmon *
hwmon_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_HWMON_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Hwmon", NULL);
  if (ret != NULL)
    return HWMON (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * HwmonSkeleton:
 *
 * The #HwmonSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * HwmonSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #HwmonSkeleton.
 */

struct _HwmonSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_hwmon_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_HWMON);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_HWMON);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_hwmon_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_hwmon_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_hwmon_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_hwmon_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _hwmon_skeleton_vtable =
{
  _hwmon_skeleton_handle_method_call,
  _hwmon_skeleton_handle_get_property,
  _hwmon_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
hwmon_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return hwmon_interface_info ();
}

static GDBusInterfaceVTable *
hwmon_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_hwmon_skeleton_vtable;
}

static GVariant *
hwmon_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_hwmon_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _hwmon_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _hwmon_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _hwmon_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Hwmon", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _hwmon_emit_changed (gpointer user_data);

static void
hwmon_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _hwmon_emit_changed (skeleton);
}

static void hwmon_skeleton_iface_init (HwmonIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (HwmonSkeleton, hwmon_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (HwmonSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_HWMON, hwmon_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (HwmonSkeleton, hwmon_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_HWMON, hwmon_skeleton_iface_init));

#endif
static void
hwmon_skeleton_finalize (GObject *object)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (object);
  guint n;
  for (n = 0; n < 3; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (hwmon_skeleton_parent_class)->finalize (object);
}

static void
hwmon_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_hwmon_emit_changed (gpointer user_data)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.Hwmon",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_hwmon_schedule_emit_changed (HwmonSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
hwmon_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _hwmon_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _hwmon_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
hwmon_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _hwmon_schedule_emit_changed (skeleton, _hwmon_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
hwmon_skeleton_init (HwmonSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = hwmon_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_HWMON_SKELETON, HwmonSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 3);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_INT);
}

static gint 
hwmon_skeleton_get_poll_interval (Hwmon *object)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
hwmon_skeleton_get_sysfs_path (Hwmon *object)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
hwmon_skeleton_get_scale (Hwmon *object)
{
  HwmonSkeleton *skeleton = HWMON_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
hwmon_skeleton_class_init (HwmonSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = hwmon_skeleton_finalize;
  gobject_class->get_property = hwmon_skeleton_get_property;
  gobject_class->set_property = hwmon_skeleton_set_property;
  gobject_class->notify       = hwmon_skeleton_notify;


  hwmon_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = hwmon_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = hwmon_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = hwmon_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = hwmon_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (HwmonSkeletonPrivate));
#endif
}

static void
hwmon_skeleton_iface_init (HwmonIface *iface)
{
  iface->get_poll_interval = hwmon_skeleton_get_poll_interval;
  iface->get_sysfs_path = hwmon_skeleton_get_sysfs_path;
  iface->get_scale = hwmon_skeleton_get_scale;
}

/**
 * hwmon_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Hwmon.top_of_page">org.openbmc.Hwmon</link>.
 *
 * Returns: (transfer full) (type HwmonSkeleton): The skeleton object.
 */
Hwmon *
hwmon_skeleton_new (void)
{
  return HWMON (g_object_new (TYPE_HWMON_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.Fan
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:Fan
 * @title: Fan
 * @short_description: Generated C code for the org.openbmc.Fan D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-Fan.top_of_page">org.openbmc.Fan</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.Fan ---- */

static const _ExtendedGDBusArgInfo _fan_method_info_set_cooling_zone_IN_ARG_cooling_zone =
{
  {
    -1,
    (gchar *) "cooling_zone",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _fan_method_info_set_cooling_zone_IN_ARG_pointers[] =
{
  &_fan_method_info_set_cooling_zone_IN_ARG_cooling_zone,
  NULL
};

static const _ExtendedGDBusMethodInfo _fan_method_info_set_cooling_zone =
{
  {
    -1,
    (gchar *) "setCoolingZone",
    (GDBusArgInfo **) &_fan_method_info_set_cooling_zone_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set-cooling-zone",
  FALSE
};

static const _ExtendedGDBusArgInfo _fan_method_info_get_speed_OUT_ARG_speed =
{
  {
    -1,
    (gchar *) "speed",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _fan_method_info_get_speed_OUT_ARG_pointers[] =
{
  &_fan_method_info_get_speed_OUT_ARG_speed,
  NULL
};

static const _ExtendedGDBusMethodInfo _fan_method_info_get_speed =
{
  {
    -1,
    (gchar *) "getSpeed",
    NULL,
    (GDBusArgInfo **) &_fan_method_info_get_speed_OUT_ARG_pointers,
    NULL
  },
  "handle-get-speed",
  FALSE
};

static const _ExtendedGDBusArgInfo _fan_method_info_set_speed_IN_ARG_speed =
{
  {
    -1,
    (gchar *) "speed",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _fan_method_info_set_speed_IN_ARG_pointers[] =
{
  &_fan_method_info_set_speed_IN_ARG_speed,
  NULL
};

static const _ExtendedGDBusMethodInfo _fan_method_info_set_speed =
{
  {
    -1,
    (gchar *) "setSpeed",
    (GDBusArgInfo **) &_fan_method_info_set_speed_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set-speed",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _fan_method_info_pointers[] =
{
  &_fan_method_info_set_cooling_zone,
  &_fan_method_info_get_speed,
  &_fan_method_info_set_speed,
  NULL
};

static const _ExtendedGDBusArgInfo _fan_signal_info_speed_changed_ARG_speed =
{
  {
    -1,
    (gchar *) "speed",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _fan_signal_info_speed_changed_ARG_pointers[] =
{
  &_fan_signal_info_speed_changed_ARG_speed,
  NULL
};

static const _ExtendedGDBusSignalInfo _fan_signal_info_speed_changed =
{
  {
    -1,
    (gchar *) "SpeedChanged",
    (GDBusArgInfo **) &_fan_signal_info_speed_changed_ARG_pointers,
    NULL
  },
  "speed-changed"
};

static const _ExtendedGDBusSignalInfo _fan_signal_info_tach_error =
{
  {
    -1,
    (gchar *) "TachError",
    NULL,
    NULL
  },
  "tach-error"
};

static const _ExtendedGDBusSignalInfo * const _fan_signal_info_pointers[] =
{
  &_fan_signal_info_speed_changed,
  &_fan_signal_info_tach_error,
  NULL
};

static const _ExtendedGDBusPropertyInfo _fan_property_info_speed =
{
  {
    -1,
    (gchar *) "speed",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "speed",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _fan_property_info_cooling_zone =
{
  {
    -1,
    (gchar *) "cooling_zone",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "cooling-zone",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _fan_property_info_pwm_num =
{
  {
    -1,
    (gchar *) "pwm_num",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "pwm-num",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _fan_property_info_pointers[] =
{
  &_fan_property_info_speed,
  &_fan_property_info_cooling_zone,
  &_fan_property_info_pwm_num,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _fan_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.Fan",
    (GDBusMethodInfo **) &_fan_method_info_pointers,
    (GDBusSignalInfo **) &_fan_signal_info_pointers,
    (GDBusPropertyInfo **) &_fan_property_info_pointers,
    NULL
  },
  "fan",
};


/**
 * fan_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-Fan.top_of_page">org.openbmc.Fan</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
fan_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_fan_interface_info.parent_struct;
}

/**
 * fan_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #Fan interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
fan_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "speed");
  g_object_class_override_property (klass, property_id_begin++, "cooling-zone");
  g_object_class_override_property (klass, property_id_begin++, "pwm-num");
  return property_id_begin - 1;
}



/**
 * Fan:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Fan.top_of_page">org.openbmc.Fan</link>.
 */

/**
 * FanIface:
 * @parent_iface: The parent interface.
 * @handle_get_speed: Handler for the #Fan::handle-get-speed signal.
 * @handle_set_cooling_zone: Handler for the #Fan::handle-set-cooling-zone signal.
 * @handle_set_speed: Handler for the #Fan::handle-set-speed signal.
 * @get_cooling_zone: Getter for the #Fan:cooling-zone property.
 * @get_pwm_num: Getter for the #Fan:pwm-num property.
 * @get_speed: Getter for the #Fan:speed property.
 * @speed_changed: Handler for the #Fan::speed-changed signal.
 * @tach_error: Handler for the #Fan::tach-error signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Fan.top_of_page">org.openbmc.Fan</link>.
 */

typedef FanIface FanInterface;
G_DEFINE_INTERFACE (Fan, fan, G_TYPE_OBJECT);

static void
fan_default_init (FanIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * Fan::handle-set-cooling-zone:
   * @object: A #Fan.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_cooling_zone: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Fan.setCoolingZone">setCoolingZone()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call fan_complete_set_cooling_zone() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-cooling-zone",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FanIface, handle_set_cooling_zone),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);

  /**
   * Fan::handle-get-speed:
   * @object: A #Fan.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Fan.getSpeed">getSpeed()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call fan_complete_get_speed() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-speed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FanIface, handle_get_speed),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * Fan::handle-set-speed:
   * @object: A #Fan.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_speed: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Fan.setSpeed">setSpeed()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call fan_complete_set_speed() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-speed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FanIface, handle_set_speed),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);

  /* GObject signals for received D-Bus signals: */
  /**
   * Fan::speed-changed:
   * @object: A #Fan.
   * @arg_speed: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-Fan.SpeedChanged">"SpeedChanged"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("speed-changed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FanIface, speed_changed),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_INT);

  /**
   * Fan::tach-error:
   * @object: A #Fan.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-Fan.TachError">"TachError"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("tach-error",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FanIface, tach_error),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * Fan:speed:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Fan.speed">"speed"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("speed", "speed", "speed", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Fan:cooling-zone:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Fan.cooling_zone">"cooling_zone"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("cooling-zone", "cooling_zone", "cooling_zone", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Fan:pwm-num:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Fan.pwm_num">"pwm_num"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("pwm-num", "pwm_num", "pwm_num", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * fan_get_speed: (skip)
 * @object: A #Fan.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Fan.speed">"speed"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
fan_get_speed (Fan *object)
{
  return FAN_GET_IFACE (object)->get_speed (object);
}

/**
 * fan_set_speed: (skip)
 * @object: A #Fan.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Fan.speed">"speed"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
fan_set_speed (Fan *object, gint value)
{
  g_object_set (G_OBJECT (object), "speed", value, NULL);
}

/**
 * fan_get_cooling_zone: (skip)
 * @object: A #Fan.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Fan.cooling_zone">"cooling_zone"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
fan_get_cooling_zone (Fan *object)
{
  return FAN_GET_IFACE (object)->get_cooling_zone (object);
}

/**
 * fan_set_cooling_zone: (skip)
 * @object: A #Fan.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Fan.cooling_zone">"cooling_zone"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
fan_set_cooling_zone (Fan *object, gint value)
{
  g_object_set (G_OBJECT (object), "cooling-zone", value, NULL);
}

/**
 * fan_get_pwm_num: (skip)
 * @object: A #Fan.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Fan.pwm_num">"pwm_num"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
fan_get_pwm_num (Fan *object)
{
  return FAN_GET_IFACE (object)->get_pwm_num (object);
}

/**
 * fan_set_pwm_num: (skip)
 * @object: A #Fan.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Fan.pwm_num">"pwm_num"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
fan_set_pwm_num (Fan *object, gint value)
{
  g_object_set (G_OBJECT (object), "pwm-num", value, NULL);
}

/**
 * fan_emit_speed_changed:
 * @object: A #Fan.
 * @arg_speed: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-Fan.SpeedChanged">"SpeedChanged"</link> D-Bus signal.
 */
void
fan_emit_speed_changed (
    Fan *object,
    gint arg_speed)
{
  g_signal_emit_by_name (object, "speed-changed", arg_speed);
}

/**
 * fan_emit_tach_error:
 * @object: A #Fan.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-Fan.TachError">"TachError"</link> D-Bus signal.
 */
void
fan_emit_tach_error (
    Fan *object)
{
  g_signal_emit_by_name (object, "tach-error");
}

/**
 * fan_call_set_cooling_zone:
 * @proxy: A #FanProxy.
 * @arg_cooling_zone: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Fan.setCoolingZone">setCoolingZone()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call fan_call_set_cooling_zone_finish() to get the result of the operation.
 *
 * See fan_call_set_cooling_zone_sync() for the synchronous, blocking version of this method.
 */
void
fan_call_set_cooling_zone (
    Fan *proxy,
    gint arg_cooling_zone,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setCoolingZone",
    g_variant_new ("(i)",
                   arg_cooling_zone),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * fan_call_set_cooling_zone_finish:
 * @proxy: A #FanProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to fan_call_set_cooling_zone().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with fan_call_set_cooling_zone().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
fan_call_set_cooling_zone_finish (
    Fan *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * fan_call_set_cooling_zone_sync:
 * @proxy: A #FanProxy.
 * @arg_cooling_zone: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Fan.setCoolingZone">setCoolingZone()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See fan_call_set_cooling_zone() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
fan_call_set_cooling_zone_sync (
    Fan *proxy,
    gint arg_cooling_zone,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setCoolingZone",
    g_variant_new ("(i)",
                   arg_cooling_zone),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * fan_call_get_speed:
 * @proxy: A #FanProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Fan.getSpeed">getSpeed()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call fan_call_get_speed_finish() to get the result of the operation.
 *
 * See fan_call_get_speed_sync() for the synchronous, blocking version of this method.
 */
void
fan_call_get_speed (
    Fan *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getSpeed",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * fan_call_get_speed_finish:
 * @proxy: A #FanProxy.
 * @out_speed: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to fan_call_get_speed().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with fan_call_get_speed().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
fan_call_get_speed_finish (
    Fan *proxy,
    gint *out_speed,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_speed);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * fan_call_get_speed_sync:
 * @proxy: A #FanProxy.
 * @out_speed: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Fan.getSpeed">getSpeed()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See fan_call_get_speed() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
fan_call_get_speed_sync (
    Fan *proxy,
    gint *out_speed,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getSpeed",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_speed);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * fan_call_set_speed:
 * @proxy: A #FanProxy.
 * @arg_speed: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Fan.setSpeed">setSpeed()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call fan_call_set_speed_finish() to get the result of the operation.
 *
 * See fan_call_set_speed_sync() for the synchronous, blocking version of this method.
 */
void
fan_call_set_speed (
    Fan *proxy,
    gint arg_speed,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setSpeed",
    g_variant_new ("(i)",
                   arg_speed),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * fan_call_set_speed_finish:
 * @proxy: A #FanProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to fan_call_set_speed().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with fan_call_set_speed().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
fan_call_set_speed_finish (
    Fan *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * fan_call_set_speed_sync:
 * @proxy: A #FanProxy.
 * @arg_speed: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Fan.setSpeed">setSpeed()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See fan_call_set_speed() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
fan_call_set_speed_sync (
    Fan *proxy,
    gint arg_speed,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setSpeed",
    g_variant_new ("(i)",
                   arg_speed),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * fan_complete_set_cooling_zone:
 * @object: A #Fan.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Fan.setCoolingZone">setCoolingZone()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
fan_complete_set_cooling_zone (
    Fan *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * fan_complete_get_speed:
 * @object: A #Fan.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @speed: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Fan.getSpeed">getSpeed()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
fan_complete_get_speed (
    Fan *object,
    GDBusMethodInvocation *invocation,
    gint speed)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(i)",
                   speed));
}

/**
 * fan_complete_set_speed:
 * @object: A #Fan.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Fan.setSpeed">setSpeed()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
fan_complete_set_speed (
    Fan *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FanProxy:
 *
 * The #FanProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FanProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FanProxy.
 */

struct _FanProxyPrivate
{
  GData *qdata;
};

static void fan_proxy_iface_init (FanIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FanProxy, fan_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FanProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_FAN, fan_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FanProxy, fan_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_FAN, fan_proxy_iface_init));

#endif
static void
fan_proxy_finalize (GObject *object)
{
  FanProxy *proxy = FAN_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (fan_proxy_parent_class)->finalize (object);
}

static void
fan_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _fan_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
fan_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.Fan: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
fan_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _fan_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.Fan", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) fan_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
fan_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_fan_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_FAN);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_FAN);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
fan_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FanProxy *proxy = FAN_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_fan_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_fan_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gint 
fan_proxy_get_speed (Fan *object)
{
  FanProxy *proxy = FAN_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "speed");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
fan_proxy_get_cooling_zone (Fan *object)
{
  FanProxy *proxy = FAN_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "cooling_zone");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
fan_proxy_get_pwm_num (Fan *object)
{
  FanProxy *proxy = FAN_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "pwm_num");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
fan_proxy_init (FanProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = fan_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_FAN_PROXY, FanProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), fan_interface_info ());
}

static void
fan_proxy_class_init (FanProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = fan_proxy_finalize;
  gobject_class->get_property = fan_proxy_get_property;
  gobject_class->set_property = fan_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = fan_proxy_g_signal;
  proxy_class->g_properties_changed = fan_proxy_g_properties_changed;

  fan_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FanProxyPrivate));
#endif
}

static void
fan_proxy_iface_init (FanIface *iface)
{
  iface->get_speed = fan_proxy_get_speed;
  iface->get_cooling_zone = fan_proxy_get_cooling_zone;
  iface->get_pwm_num = fan_proxy_get_pwm_num;
}

/**
 * fan_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Fan.top_of_page">org.openbmc.Fan</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call fan_proxy_new_finish() to get the result of the operation.
 *
 * See fan_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
fan_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_FAN_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Fan", NULL);
}

/**
 * fan_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to fan_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with fan_proxy_new().
 *
 * Returns: (transfer full) (type FanProxy): The constructed proxy object or %NULL if @error is set.
 */
Fan *
fan_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FAN (ret);
  else
    return NULL;
}

/**
 * fan_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Fan.top_of_page">org.openbmc.Fan</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See fan_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FanProxy): The constructed proxy object or %NULL if @error is set.
 */
Fan *
fan_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_FAN_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Fan", NULL);
  if (ret != NULL)
    return FAN (ret);
  else
    return NULL;
}


/**
 * fan_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like fan_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call fan_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See fan_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
fan_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_FAN_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Fan", NULL);
}

/**
 * fan_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to fan_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with fan_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FanProxy): The constructed proxy object or %NULL if @error is set.
 */
Fan *
fan_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FAN (ret);
  else
    return NULL;
}

/**
 * fan_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like fan_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See fan_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FanProxy): The constructed proxy object or %NULL if @error is set.
 */
Fan *
fan_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_FAN_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Fan", NULL);
  if (ret != NULL)
    return FAN (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FanSkeleton:
 *
 * The #FanSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FanSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FanSkeleton.
 */

struct _FanSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_fan_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FanSkeleton *skeleton = FAN_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_FAN);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_FAN);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_fan_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FanSkeleton *skeleton = FAN_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_fan_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_fan_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FanSkeleton *skeleton = FAN_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_fan_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _fan_skeleton_vtable =
{
  _fan_skeleton_handle_method_call,
  _fan_skeleton_handle_get_property,
  _fan_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
fan_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return fan_interface_info ();
}

static GDBusInterfaceVTable *
fan_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_fan_skeleton_vtable;
}

static GVariant *
fan_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FanSkeleton *skeleton = FAN_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_fan_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _fan_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _fan_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _fan_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Fan", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _fan_emit_changed (gpointer user_data);

static void
fan_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FanSkeleton *skeleton = FAN_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _fan_emit_changed (skeleton);
}

static void
_fan_on_signal_speed_changed (
    Fan *object,
    gint arg_speed)
{
  FanSkeleton *skeleton = FAN_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(i)",
                   arg_speed));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Fan", "SpeedChanged",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_fan_on_signal_tach_error (
    Fan *object)
{
  FanSkeleton *skeleton = FAN_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Fan", "TachError",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void fan_skeleton_iface_init (FanIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FanSkeleton, fan_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FanSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_FAN, fan_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FanSkeleton, fan_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_FAN, fan_skeleton_iface_init));

#endif
static void
fan_skeleton_finalize (GObject *object)
{
  FanSkeleton *skeleton = FAN_SKELETON (object);
  guint n;
  for (n = 0; n < 3; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (fan_skeleton_parent_class)->finalize (object);
}

static void
fan_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FanSkeleton *skeleton = FAN_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_fan_emit_changed (gpointer user_data)
{
  FanSkeleton *skeleton = FAN_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.Fan",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_fan_schedule_emit_changed (FanSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
fan_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FanSkeleton *skeleton = FAN_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _fan_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _fan_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
fan_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FanSkeleton *skeleton = FAN_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _fan_schedule_emit_changed (skeleton, _fan_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
fan_skeleton_init (FanSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = fan_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_FAN_SKELETON, FanSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 3);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_INT);
}

static gint 
fan_skeleton_get_speed (Fan *object)
{
  FanSkeleton *skeleton = FAN_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
fan_skeleton_get_cooling_zone (Fan *object)
{
  FanSkeleton *skeleton = FAN_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
fan_skeleton_get_pwm_num (Fan *object)
{
  FanSkeleton *skeleton = FAN_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
fan_skeleton_class_init (FanSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = fan_skeleton_finalize;
  gobject_class->get_property = fan_skeleton_get_property;
  gobject_class->set_property = fan_skeleton_set_property;
  gobject_class->notify       = fan_skeleton_notify;


  fan_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = fan_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = fan_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = fan_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = fan_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FanSkeletonPrivate));
#endif
}

static void
fan_skeleton_iface_init (FanIface *iface)
{
  iface->speed_changed = _fan_on_signal_speed_changed;
  iface->tach_error = _fan_on_signal_tach_error;
  iface->get_speed = fan_skeleton_get_speed;
  iface->get_cooling_zone = fan_skeleton_get_cooling_zone;
  iface->get_pwm_num = fan_skeleton_get_pwm_num;
}

/**
 * fan_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Fan.top_of_page">org.openbmc.Fan</link>.
 *
 * Returns: (transfer full) (type FanSkeleton): The skeleton object.
 */
Fan *
fan_skeleton_new (void)
{
  return FAN (g_object_new (TYPE_FAN_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.SensorValue
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:SensorValue
 * @title: SensorValue
 * @short_description: Generated C code for the org.openbmc.SensorValue D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-SensorValue.top_of_page">org.openbmc.SensorValue</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.SensorValue ---- */

static const _ExtendedGDBusMethodInfo _sensor_value_method_info_init =
{
  {
    -1,
    (gchar *) "init",
    NULL,
    NULL,
    NULL
  },
  "handle-init",
  FALSE
};

static const _ExtendedGDBusArgInfo _sensor_value_method_info_get_value_OUT_ARG_value =
{
  {
    -1,
    (gchar *) "value",
    (gchar *) "v",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _sensor_value_method_info_get_value_OUT_ARG_pointers[] =
{
  &_sensor_value_method_info_get_value_OUT_ARG_value,
  NULL
};

static const _ExtendedGDBusMethodInfo _sensor_value_method_info_get_value =
{
  {
    -1,
    (gchar *) "getValue",
    NULL,
    (GDBusArgInfo **) &_sensor_value_method_info_get_value_OUT_ARG_pointers,
    NULL
  },
  "handle-get-value",
  FALSE
};

static const _ExtendedGDBusArgInfo _sensor_value_method_info_set_value_IN_ARG_value =
{
  {
    -1,
    (gchar *) "value",
    (gchar *) "v",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _sensor_value_method_info_set_value_IN_ARG_pointers[] =
{
  &_sensor_value_method_info_set_value_IN_ARG_value,
  NULL
};

static const _ExtendedGDBusMethodInfo _sensor_value_method_info_set_value =
{
  {
    -1,
    (gchar *) "setValue",
    (GDBusArgInfo **) &_sensor_value_method_info_set_value_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set-value",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _sensor_value_method_info_pointers[] =
{
  &_sensor_value_method_info_init,
  &_sensor_value_method_info_get_value,
  &_sensor_value_method_info_set_value,
  NULL
};

static const _ExtendedGDBusArgInfo _sensor_value_signal_info_changed_ARG_value =
{
  {
    -1,
    (gchar *) "value",
    (gchar *) "v",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _sensor_value_signal_info_changed_ARG_units =
{
  {
    -1,
    (gchar *) "units",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _sensor_value_signal_info_changed_ARG_pointers[] =
{
  &_sensor_value_signal_info_changed_ARG_value,
  &_sensor_value_signal_info_changed_ARG_units,
  NULL
};

static const _ExtendedGDBusSignalInfo _sensor_value_signal_info_changed =
{
  {
    -1,
    (gchar *) "Changed",
    (GDBusArgInfo **) &_sensor_value_signal_info_changed_ARG_pointers,
    NULL
  },
  "changed"
};

static const _ExtendedGDBusSignalInfo _sensor_value_signal_info_error =
{
  {
    -1,
    (gchar *) "Error",
    NULL,
    NULL
  },
  "error"
};

static const _ExtendedGDBusArgInfo _sensor_value_signal_info_heartbeat_ARG_bus_name =
{
  {
    -1,
    (gchar *) "bus_name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _sensor_value_signal_info_heartbeat_ARG_pointers[] =
{
  &_sensor_value_signal_info_heartbeat_ARG_bus_name,
  NULL
};

static const _ExtendedGDBusSignalInfo _sensor_value_signal_info_heartbeat =
{
  {
    -1,
    (gchar *) "Heartbeat",
    (GDBusArgInfo **) &_sensor_value_signal_info_heartbeat_ARG_pointers,
    NULL
  },
  "heartbeat"
};

static const _ExtendedGDBusSignalInfo * const _sensor_value_signal_info_pointers[] =
{
  &_sensor_value_signal_info_changed,
  &_sensor_value_signal_info_error,
  &_sensor_value_signal_info_heartbeat,
  NULL
};

static const _ExtendedGDBusPropertyInfo _sensor_value_property_info_value =
{
  {
    -1,
    (gchar *) "value",
    (gchar *) "v",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "value",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _sensor_value_property_info_units =
{
  {
    -1,
    (gchar *) "units",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "units",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _sensor_value_property_info_poll_interval =
{
  {
    -1,
    (gchar *) "poll_interval",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "poll-interval",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _sensor_value_property_info_heatbeat =
{
  {
    -1,
    (gchar *) "heatbeat",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "heatbeat",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _sensor_value_property_info_settable =
{
  {
    -1,
    (gchar *) "settable",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "settable",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _sensor_value_property_info_pointers[] =
{
  &_sensor_value_property_info_value,
  &_sensor_value_property_info_units,
  &_sensor_value_property_info_poll_interval,
  &_sensor_value_property_info_heatbeat,
  &_sensor_value_property_info_settable,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _sensor_value_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.SensorValue",
    (GDBusMethodInfo **) &_sensor_value_method_info_pointers,
    (GDBusSignalInfo **) &_sensor_value_signal_info_pointers,
    (GDBusPropertyInfo **) &_sensor_value_property_info_pointers,
    NULL
  },
  "sensor-value",
};


/**
 * sensor_value_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-SensorValue.top_of_page">org.openbmc.SensorValue</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
sensor_value_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_sensor_value_interface_info.parent_struct;
}

/**
 * sensor_value_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #SensorValue interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
sensor_value_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "value");
  g_object_class_override_property (klass, property_id_begin++, "units");
  g_object_class_override_property (klass, property_id_begin++, "poll-interval");
  g_object_class_override_property (klass, property_id_begin++, "heatbeat");
  g_object_class_override_property (klass, property_id_begin++, "settable");
  return property_id_begin - 1;
}



/**
 * SensorValue:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorValue.top_of_page">org.openbmc.SensorValue</link>.
 */

/**
 * SensorValueIface:
 * @parent_iface: The parent interface.
 * @handle_get_value: Handler for the #SensorValue::handle-get-value signal.
 * @handle_init: Handler for the #SensorValue::handle-init signal.
 * @handle_set_value: Handler for the #SensorValue::handle-set-value signal.
 * @get_heatbeat: Getter for the #SensorValue:heatbeat property.
 * @get_poll_interval: Getter for the #SensorValue:poll-interval property.
 * @get_settable: Getter for the #SensorValue:settable property.
 * @get_units: Getter for the #SensorValue:units property.
 * @get_value: Getter for the #SensorValue:value property.
 * @changed: Handler for the #SensorValue::changed signal.
 * @error: Handler for the #SensorValue::error signal.
 * @heartbeat: Handler for the #SensorValue::heartbeat signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorValue.top_of_page">org.openbmc.SensorValue</link>.
 */

typedef SensorValueIface SensorValueInterface;
G_DEFINE_INTERFACE (SensorValue, sensor_value, G_TYPE_OBJECT);

static void
sensor_value_default_init (SensorValueIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * SensorValue::handle-init:
   * @object: A #SensorValue.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-SensorValue.init">init()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call sensor_value_complete_init() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-init",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorValueIface, handle_init),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * SensorValue::handle-get-value:
   * @object: A #SensorValue.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-SensorValue.getValue">getValue()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call sensor_value_complete_get_value() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-value",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorValueIface, handle_get_value),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * SensorValue::handle-set-value:
   * @object: A #SensorValue.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_value: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-SensorValue.setValue">setValue()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call sensor_value_complete_set_value() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-value",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorValueIface, handle_set_value),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /* GObject signals for received D-Bus signals: */
  /**
   * SensorValue::changed:
   * @object: A #SensorValue.
   * @arg_value: Argument.
   * @arg_units: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-SensorValue.Changed">"Changed"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("changed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorValueIface, changed),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_VARIANT, G_TYPE_STRING);

  /**
   * SensorValue::error:
   * @object: A #SensorValue.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-SensorValue.Error">"Error"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("error",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorValueIface, error),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * SensorValue::heartbeat:
   * @object: A #SensorValue.
   * @arg_bus_name: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-SensorValue.Heartbeat">"Heartbeat"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("heartbeat",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorValueIface, heartbeat),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /* GObject properties for D-Bus properties: */
  /**
   * SensorValue:value:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorValue.value">"value"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("value", "value", "value", G_VARIANT_TYPE ("v"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SensorValue:units:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorValue.units">"units"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("units", "units", "units", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SensorValue:poll-interval:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorValue.poll_interval">"poll_interval"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("poll-interval", "poll_interval", "poll_interval", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SensorValue:heatbeat:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorValue.heatbeat">"heatbeat"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("heatbeat", "heatbeat", "heatbeat", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SensorValue:settable:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorValue.settable">"settable"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("settable", "settable", "settable", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * sensor_value_get_value: (skip)
 * @object: A #SensorValue.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorValue.value">"value"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use sensor_value_dup_value() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
sensor_value_get_value (SensorValue *object)
{
  return SENSOR_VALUE_GET_IFACE (object)->get_value (object);
}

/**
 * sensor_value_dup_value: (skip)
 * @object: A #SensorValue.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-SensorValue.value">"value"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
sensor_value_dup_value (SensorValue *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "value", &value, NULL);
  return value;
}

/**
 * sensor_value_set_value: (skip)
 * @object: A #SensorValue.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorValue.value">"value"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
sensor_value_set_value (SensorValue *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "value", value, NULL);
}

/**
 * sensor_value_get_units: (skip)
 * @object: A #SensorValue.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorValue.units">"units"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use sensor_value_dup_units() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
sensor_value_get_units (SensorValue *object)
{
  return SENSOR_VALUE_GET_IFACE (object)->get_units (object);
}

/**
 * sensor_value_dup_units: (skip)
 * @object: A #SensorValue.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-SensorValue.units">"units"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
sensor_value_dup_units (SensorValue *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "units", &value, NULL);
  return value;
}

/**
 * sensor_value_set_units: (skip)
 * @object: A #SensorValue.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorValue.units">"units"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
sensor_value_set_units (SensorValue *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "units", value, NULL);
}

/**
 * sensor_value_get_poll_interval: (skip)
 * @object: A #SensorValue.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorValue.poll_interval">"poll_interval"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
sensor_value_get_poll_interval (SensorValue *object)
{
  return SENSOR_VALUE_GET_IFACE (object)->get_poll_interval (object);
}

/**
 * sensor_value_set_poll_interval: (skip)
 * @object: A #SensorValue.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorValue.poll_interval">"poll_interval"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
sensor_value_set_poll_interval (SensorValue *object, gint value)
{
  g_object_set (G_OBJECT (object), "poll-interval", value, NULL);
}

/**
 * sensor_value_get_heatbeat: (skip)
 * @object: A #SensorValue.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorValue.heatbeat">"heatbeat"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
sensor_value_get_heatbeat (SensorValue *object)
{
  return SENSOR_VALUE_GET_IFACE (object)->get_heatbeat (object);
}

/**
 * sensor_value_set_heatbeat: (skip)
 * @object: A #SensorValue.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorValue.heatbeat">"heatbeat"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
sensor_value_set_heatbeat (SensorValue *object, gint value)
{
  g_object_set (G_OBJECT (object), "heatbeat", value, NULL);
}

/**
 * sensor_value_get_settable: (skip)
 * @object: A #SensorValue.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorValue.settable">"settable"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
sensor_value_get_settable (SensorValue *object)
{
  return SENSOR_VALUE_GET_IFACE (object)->get_settable (object);
}

/**
 * sensor_value_set_settable: (skip)
 * @object: A #SensorValue.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorValue.settable">"settable"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
sensor_value_set_settable (SensorValue *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "settable", value, NULL);
}

/**
 * sensor_value_emit_changed:
 * @object: A #SensorValue.
 * @arg_value: Argument to pass with the signal.
 * @arg_units: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-SensorValue.Changed">"Changed"</link> D-Bus signal.
 */
void
sensor_value_emit_changed (
    SensorValue *object,
    GVariant *arg_value,
    const gchar *arg_units)
{
  g_signal_emit_by_name (object, "changed", arg_value, arg_units);
}

/**
 * sensor_value_emit_error:
 * @object: A #SensorValue.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-SensorValue.Error">"Error"</link> D-Bus signal.
 */
void
sensor_value_emit_error (
    SensorValue *object)
{
  g_signal_emit_by_name (object, "error");
}

/**
 * sensor_value_emit_heartbeat:
 * @object: A #SensorValue.
 * @arg_bus_name: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-SensorValue.Heartbeat">"Heartbeat"</link> D-Bus signal.
 */
void
sensor_value_emit_heartbeat (
    SensorValue *object,
    const gchar *arg_bus_name)
{
  g_signal_emit_by_name (object, "heartbeat", arg_bus_name);
}

/**
 * sensor_value_call_init:
 * @proxy: A #SensorValueProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-SensorValue.init">init()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_value_call_init_finish() to get the result of the operation.
 *
 * See sensor_value_call_init_sync() for the synchronous, blocking version of this method.
 */
void
sensor_value_call_init (
    SensorValue *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "init",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * sensor_value_call_init_finish:
 * @proxy: A #SensorValueProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_value_call_init().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with sensor_value_call_init().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
sensor_value_call_init_finish (
    SensorValue *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * sensor_value_call_init_sync:
 * @proxy: A #SensorValueProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-SensorValue.init">init()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See sensor_value_call_init() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
sensor_value_call_init_sync (
    SensorValue *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "init",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * sensor_value_call_get_value:
 * @proxy: A #SensorValueProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-SensorValue.getValue">getValue()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_value_call_get_value_finish() to get the result of the operation.
 *
 * See sensor_value_call_get_value_sync() for the synchronous, blocking version of this method.
 */
void
sensor_value_call_get_value (
    SensorValue *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getValue",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * sensor_value_call_get_value_finish:
 * @proxy: A #SensorValueProxy.
 * @out_value: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_value_call_get_value().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with sensor_value_call_get_value().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
sensor_value_call_get_value_finish (
    SensorValue *proxy,
    GVariant **out_value,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@v)",
                 out_value);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * sensor_value_call_get_value_sync:
 * @proxy: A #SensorValueProxy.
 * @out_value: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-SensorValue.getValue">getValue()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See sensor_value_call_get_value() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
sensor_value_call_get_value_sync (
    SensorValue *proxy,
    GVariant **out_value,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getValue",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@v)",
                 out_value);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * sensor_value_call_set_value:
 * @proxy: A #SensorValueProxy.
 * @arg_value: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-SensorValue.setValue">setValue()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_value_call_set_value_finish() to get the result of the operation.
 *
 * See sensor_value_call_set_value_sync() for the synchronous, blocking version of this method.
 */
void
sensor_value_call_set_value (
    SensorValue *proxy,
    GVariant *arg_value,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setValue",
    g_variant_new ("(@v)",
                   arg_value),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * sensor_value_call_set_value_finish:
 * @proxy: A #SensorValueProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_value_call_set_value().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with sensor_value_call_set_value().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
sensor_value_call_set_value_finish (
    SensorValue *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * sensor_value_call_set_value_sync:
 * @proxy: A #SensorValueProxy.
 * @arg_value: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-SensorValue.setValue">setValue()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See sensor_value_call_set_value() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
sensor_value_call_set_value_sync (
    SensorValue *proxy,
    GVariant *arg_value,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setValue",
    g_variant_new ("(@v)",
                   arg_value),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * sensor_value_complete_init:
 * @object: A #SensorValue.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-SensorValue.init">init()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
sensor_value_complete_init (
    SensorValue *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * sensor_value_complete_get_value:
 * @object: A #SensorValue.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @value: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-SensorValue.getValue">getValue()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
sensor_value_complete_get_value (
    SensorValue *object,
    GDBusMethodInvocation *invocation,
    GVariant *value)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@v)",
                   value));
}

/**
 * sensor_value_complete_set_value:
 * @object: A #SensorValue.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-SensorValue.setValue">setValue()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
sensor_value_complete_set_value (
    SensorValue *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * SensorValueProxy:
 *
 * The #SensorValueProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * SensorValueProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #SensorValueProxy.
 */

struct _SensorValueProxyPrivate
{
  GData *qdata;
};

static void sensor_value_proxy_iface_init (SensorValueIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (SensorValueProxy, sensor_value_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (SensorValueProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_VALUE, sensor_value_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (SensorValueProxy, sensor_value_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_VALUE, sensor_value_proxy_iface_init));

#endif
static void
sensor_value_proxy_finalize (GObject *object)
{
  SensorValueProxy *proxy = SENSOR_VALUE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (sensor_value_proxy_parent_class)->finalize (object);
}

static void
sensor_value_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  info = _sensor_value_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
sensor_value_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.SensorValue: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
sensor_value_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  info = _sensor_value_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.SensorValue", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) sensor_value_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
sensor_value_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_sensor_value_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_SENSOR_VALUE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_SENSOR_VALUE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
sensor_value_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  SensorValueProxy *proxy = SENSOR_VALUE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_value_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_value_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static GVariant *
sensor_value_proxy_get_value (SensorValue *object)
{
  SensorValueProxy *proxy = SENSOR_VALUE_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "value");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static const gchar *
sensor_value_proxy_get_units (SensorValue *object)
{
  SensorValueProxy *proxy = SENSOR_VALUE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "units");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
sensor_value_proxy_get_poll_interval (SensorValue *object)
{
  SensorValueProxy *proxy = SENSOR_VALUE_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "poll_interval");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
sensor_value_proxy_get_heatbeat (SensorValue *object)
{
  SensorValueProxy *proxy = SENSOR_VALUE_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "heatbeat");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
sensor_value_proxy_get_settable (SensorValue *object)
{
  SensorValueProxy *proxy = SENSOR_VALUE_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "settable");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
sensor_value_proxy_init (SensorValueProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = sensor_value_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_SENSOR_VALUE_PROXY, SensorValueProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), sensor_value_interface_info ());
}

static void
sensor_value_proxy_class_init (SensorValueProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = sensor_value_proxy_finalize;
  gobject_class->get_property = sensor_value_proxy_get_property;
  gobject_class->set_property = sensor_value_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = sensor_value_proxy_g_signal;
  proxy_class->g_properties_changed = sensor_value_proxy_g_properties_changed;

  sensor_value_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (SensorValueProxyPrivate));
#endif
}

static void
sensor_value_proxy_iface_init (SensorValueIface *iface)
{
  iface->get_value = sensor_value_proxy_get_value;
  iface->get_units = sensor_value_proxy_get_units;
  iface->get_poll_interval = sensor_value_proxy_get_poll_interval;
  iface->get_heatbeat = sensor_value_proxy_get_heatbeat;
  iface->get_settable = sensor_value_proxy_get_settable;
}

/**
 * sensor_value_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorValue.top_of_page">org.openbmc.SensorValue</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_value_proxy_new_finish() to get the result of the operation.
 *
 * See sensor_value_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
sensor_value_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_SENSOR_VALUE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorValue", NULL);
}

/**
 * sensor_value_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_value_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with sensor_value_proxy_new().
 *
 * Returns: (transfer full) (type SensorValueProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorValue *
sensor_value_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return SENSOR_VALUE (ret);
  else
    return NULL;
}

/**
 * sensor_value_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorValue.top_of_page">org.openbmc.SensorValue</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See sensor_value_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type SensorValueProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorValue *
sensor_value_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_SENSOR_VALUE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorValue", NULL);
  if (ret != NULL)
    return SENSOR_VALUE (ret);
  else
    return NULL;
}


/**
 * sensor_value_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like sensor_value_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_value_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See sensor_value_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
sensor_value_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_SENSOR_VALUE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorValue", NULL);
}

/**
 * sensor_value_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_value_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with sensor_value_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type SensorValueProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorValue *
sensor_value_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return SENSOR_VALUE (ret);
  else
    return NULL;
}

/**
 * sensor_value_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like sensor_value_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See sensor_value_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type SensorValueProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorValue *
sensor_value_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_SENSOR_VALUE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorValue", NULL);
  if (ret != NULL)
    return SENSOR_VALUE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * SensorValueSkeleton:
 *
 * The #SensorValueSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * SensorValueSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #SensorValueSkeleton.
 */

struct _SensorValueSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_sensor_value_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_SENSOR_VALUE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_SENSOR_VALUE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_sensor_value_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_value_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_sensor_value_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_value_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _sensor_value_skeleton_vtable =
{
  _sensor_value_skeleton_handle_method_call,
  _sensor_value_skeleton_handle_get_property,
  _sensor_value_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
sensor_value_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return sensor_value_interface_info ();
}

static GDBusInterfaceVTable *
sensor_value_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_sensor_value_skeleton_vtable;
}

static GVariant *
sensor_value_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_sensor_value_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _sensor_value_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _sensor_value_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _sensor_value_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorValue", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _sensor_value_emit_changed (gpointer user_data);

static void
sensor_value_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _sensor_value_emit_changed (skeleton);
}

static void
_sensor_value_on_signal_changed (
    SensorValue *object,
    GVariant *arg_value,
    const gchar *arg_units)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@vs)",
                   arg_value,
                   arg_units));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorValue", "Changed",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_sensor_value_on_signal_error (
    SensorValue *object)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorValue", "Error",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_sensor_value_on_signal_heartbeat (
    SensorValue *object,
    const gchar *arg_bus_name)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
                   arg_bus_name));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorValue", "Heartbeat",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void sensor_value_skeleton_iface_init (SensorValueIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (SensorValueSkeleton, sensor_value_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (SensorValueSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_VALUE, sensor_value_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (SensorValueSkeleton, sensor_value_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_VALUE, sensor_value_skeleton_iface_init));

#endif
static void
sensor_value_skeleton_finalize (GObject *object)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);
  guint n;
  for (n = 0; n < 5; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (sensor_value_skeleton_parent_class)->finalize (object);
}

static void
sensor_value_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_sensor_value_emit_changed (gpointer user_data)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.SensorValue",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_sensor_value_schedule_emit_changed (SensorValueSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
sensor_value_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _sensor_value_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _sensor_value_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
sensor_value_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _sensor_value_schedule_emit_changed (skeleton, _sensor_value_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
sensor_value_skeleton_init (SensorValueSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = sensor_value_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_SENSOR_VALUE_SKELETON, SensorValueSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 5);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_BOOLEAN);
}

static GVariant *
sensor_value_skeleton_get_value (SensorValue *object)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
sensor_value_skeleton_get_units (SensorValue *object)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
sensor_value_skeleton_get_poll_interval (SensorValue *object)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
sensor_value_skeleton_get_heatbeat (SensorValue *object)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
sensor_value_skeleton_get_settable (SensorValue *object)
{
  SensorValueSkeleton *skeleton = SENSOR_VALUE_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
sensor_value_skeleton_class_init (SensorValueSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = sensor_value_skeleton_finalize;
  gobject_class->get_property = sensor_value_skeleton_get_property;
  gobject_class->set_property = sensor_value_skeleton_set_property;
  gobject_class->notify       = sensor_value_skeleton_notify;


  sensor_value_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = sensor_value_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = sensor_value_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = sensor_value_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = sensor_value_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (SensorValueSkeletonPrivate));
#endif
}

static void
sensor_value_skeleton_iface_init (SensorValueIface *iface)
{
  iface->changed = _sensor_value_on_signal_changed;
  iface->error = _sensor_value_on_signal_error;
  iface->heartbeat = _sensor_value_on_signal_heartbeat;
  iface->get_value = sensor_value_skeleton_get_value;
  iface->get_units = sensor_value_skeleton_get_units;
  iface->get_poll_interval = sensor_value_skeleton_get_poll_interval;
  iface->get_heatbeat = sensor_value_skeleton_get_heatbeat;
  iface->get_settable = sensor_value_skeleton_get_settable;
}

/**
 * sensor_value_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorValue.top_of_page">org.openbmc.SensorValue</link>.
 *
 * Returns: (transfer full) (type SensorValueSkeleton): The skeleton object.
 */
SensorValue *
sensor_value_skeleton_new (void)
{
  return SENSOR_VALUE (g_object_new (TYPE_SENSOR_VALUE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.SensorThreshold
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:SensorThreshold
 * @title: SensorThreshold
 * @short_description: Generated C code for the org.openbmc.SensorThreshold D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-SensorThreshold.top_of_page">org.openbmc.SensorThreshold</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.SensorThreshold ---- */

static const _ExtendedGDBusArgInfo _sensor_threshold_method_info_get_state_OUT_ARG_state =
{
  {
    -1,
    (gchar *) "state",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _sensor_threshold_method_info_get_state_OUT_ARG_pointers[] =
{
  &_sensor_threshold_method_info_get_state_OUT_ARG_state,
  NULL
};

static const _ExtendedGDBusMethodInfo _sensor_threshold_method_info_get_state =
{
  {
    -1,
    (gchar *) "getState",
    NULL,
    (GDBusArgInfo **) &_sensor_threshold_method_info_get_state_OUT_ARG_pointers,
    NULL
  },
  "handle-get-state",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _sensor_threshold_method_info_pointers[] =
{
  &_sensor_threshold_method_info_get_state,
  NULL
};

static const _ExtendedGDBusSignalInfo _sensor_threshold_signal_info_warning =
{
  {
    -1,
    (gchar *) "Warning",
    NULL,
    NULL
  },
  "warning"
};

static const _ExtendedGDBusSignalInfo _sensor_threshold_signal_info_critical =
{
  {
    -1,
    (gchar *) "Critical",
    NULL,
    NULL
  },
  "critical"
};

static const _ExtendedGDBusSignalInfo _sensor_threshold_signal_info_normal =
{
  {
    -1,
    (gchar *) "Normal",
    NULL,
    NULL
  },
  "normal"
};

static const _ExtendedGDBusSignalInfo * const _sensor_threshold_signal_info_pointers[] =
{
  &_sensor_threshold_signal_info_warning,
  &_sensor_threshold_signal_info_critical,
  &_sensor_threshold_signal_info_normal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _sensor_threshold_property_info_lower_critical =
{
  {
    -1,
    (gchar *) "lower_critical",
    (gchar *) "v",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "lower-critical",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _sensor_threshold_property_info_lower_warning =
{
  {
    -1,
    (gchar *) "lower_warning",
    (gchar *) "v",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "lower-warning",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _sensor_threshold_property_info_upper_warning =
{
  {
    -1,
    (gchar *) "upper_warning",
    (gchar *) "v",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "upper-warning",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _sensor_threshold_property_info_upper_critical =
{
  {
    -1,
    (gchar *) "upper_critical",
    (gchar *) "v",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "upper-critical",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _sensor_threshold_property_info_state =
{
  {
    -1,
    (gchar *) "state",
    (gchar *) "y",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "state",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _sensor_threshold_property_info_pointers[] =
{
  &_sensor_threshold_property_info_lower_critical,
  &_sensor_threshold_property_info_lower_warning,
  &_sensor_threshold_property_info_upper_warning,
  &_sensor_threshold_property_info_upper_critical,
  &_sensor_threshold_property_info_state,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _sensor_threshold_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.SensorThreshold",
    (GDBusMethodInfo **) &_sensor_threshold_method_info_pointers,
    (GDBusSignalInfo **) &_sensor_threshold_signal_info_pointers,
    (GDBusPropertyInfo **) &_sensor_threshold_property_info_pointers,
    NULL
  },
  "sensor-threshold",
};


/**
 * sensor_threshold_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-SensorThreshold.top_of_page">org.openbmc.SensorThreshold</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
sensor_threshold_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_sensor_threshold_interface_info.parent_struct;
}

/**
 * sensor_threshold_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #SensorThreshold interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
sensor_threshold_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "lower-critical");
  g_object_class_override_property (klass, property_id_begin++, "lower-warning");
  g_object_class_override_property (klass, property_id_begin++, "upper-warning");
  g_object_class_override_property (klass, property_id_begin++, "upper-critical");
  g_object_class_override_property (klass, property_id_begin++, "state");
  return property_id_begin - 1;
}



/**
 * SensorThreshold:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorThreshold.top_of_page">org.openbmc.SensorThreshold</link>.
 */

/**
 * SensorThresholdIface:
 * @parent_iface: The parent interface.
 * @handle_get_state: Handler for the #SensorThreshold::handle-get-state signal.
 * @get_lower_critical: Getter for the #SensorThreshold:lower-critical property.
 * @get_lower_warning: Getter for the #SensorThreshold:lower-warning property.
 * @get_state: Getter for the #SensorThreshold:state property.
 * @get_upper_critical: Getter for the #SensorThreshold:upper-critical property.
 * @get_upper_warning: Getter for the #SensorThreshold:upper-warning property.
 * @critical: Handler for the #SensorThreshold::critical signal.
 * @normal: Handler for the #SensorThreshold::normal signal.
 * @warning: Handler for the #SensorThreshold::warning signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorThreshold.top_of_page">org.openbmc.SensorThreshold</link>.
 */

typedef SensorThresholdIface SensorThresholdInterface;
G_DEFINE_INTERFACE (SensorThreshold, sensor_threshold, G_TYPE_OBJECT);

static void
sensor_threshold_default_init (SensorThresholdIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * SensorThreshold::handle-get-state:
   * @object: A #SensorThreshold.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-SensorThreshold.getState">getState()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call sensor_threshold_complete_get_state() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-state",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorThresholdIface, handle_get_state),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * SensorThreshold::warning:
   * @object: A #SensorThreshold.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-SensorThreshold.Warning">"Warning"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("warning",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorThresholdIface, warning),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * SensorThreshold::critical:
   * @object: A #SensorThreshold.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-SensorThreshold.Critical">"Critical"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("critical",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorThresholdIface, critical),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * SensorThreshold::normal:
   * @object: A #SensorThreshold.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-SensorThreshold.Normal">"Normal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("normal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorThresholdIface, normal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * SensorThreshold:lower-critical:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorThreshold.lower_critical">"lower_critical"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("lower-critical", "lower_critical", "lower_critical", G_VARIANT_TYPE ("v"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SensorThreshold:lower-warning:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorThreshold.lower_warning">"lower_warning"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("lower-warning", "lower_warning", "lower_warning", G_VARIANT_TYPE ("v"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SensorThreshold:upper-warning:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorThreshold.upper_warning">"upper_warning"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("upper-warning", "upper_warning", "upper_warning", G_VARIANT_TYPE ("v"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SensorThreshold:upper-critical:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorThreshold.upper_critical">"upper_critical"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("upper-critical", "upper_critical", "upper_critical", G_VARIANT_TYPE ("v"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SensorThreshold:state:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorThreshold.state">"state"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uchar ("state", "state", "state", 0, 255, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * sensor_threshold_get_lower_critical: (skip)
 * @object: A #SensorThreshold.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorThreshold.lower_critical">"lower_critical"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use sensor_threshold_dup_lower_critical() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
sensor_threshold_get_lower_critical (SensorThreshold *object)
{
  return SENSOR_THRESHOLD_GET_IFACE (object)->get_lower_critical (object);
}

/**
 * sensor_threshold_dup_lower_critical: (skip)
 * @object: A #SensorThreshold.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-SensorThreshold.lower_critical">"lower_critical"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
sensor_threshold_dup_lower_critical (SensorThreshold *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "lower-critical", &value, NULL);
  return value;
}

/**
 * sensor_threshold_set_lower_critical: (skip)
 * @object: A #SensorThreshold.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorThreshold.lower_critical">"lower_critical"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
sensor_threshold_set_lower_critical (SensorThreshold *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "lower-critical", value, NULL);
}

/**
 * sensor_threshold_get_lower_warning: (skip)
 * @object: A #SensorThreshold.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorThreshold.lower_warning">"lower_warning"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use sensor_threshold_dup_lower_warning() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
sensor_threshold_get_lower_warning (SensorThreshold *object)
{
  return SENSOR_THRESHOLD_GET_IFACE (object)->get_lower_warning (object);
}

/**
 * sensor_threshold_dup_lower_warning: (skip)
 * @object: A #SensorThreshold.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-SensorThreshold.lower_warning">"lower_warning"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
sensor_threshold_dup_lower_warning (SensorThreshold *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "lower-warning", &value, NULL);
  return value;
}

/**
 * sensor_threshold_set_lower_warning: (skip)
 * @object: A #SensorThreshold.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorThreshold.lower_warning">"lower_warning"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
sensor_threshold_set_lower_warning (SensorThreshold *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "lower-warning", value, NULL);
}

/**
 * sensor_threshold_get_upper_warning: (skip)
 * @object: A #SensorThreshold.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorThreshold.upper_warning">"upper_warning"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use sensor_threshold_dup_upper_warning() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
sensor_threshold_get_upper_warning (SensorThreshold *object)
{
  return SENSOR_THRESHOLD_GET_IFACE (object)->get_upper_warning (object);
}

/**
 * sensor_threshold_dup_upper_warning: (skip)
 * @object: A #SensorThreshold.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-SensorThreshold.upper_warning">"upper_warning"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
sensor_threshold_dup_upper_warning (SensorThreshold *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "upper-warning", &value, NULL);
  return value;
}

/**
 * sensor_threshold_set_upper_warning: (skip)
 * @object: A #SensorThreshold.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorThreshold.upper_warning">"upper_warning"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
sensor_threshold_set_upper_warning (SensorThreshold *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "upper-warning", value, NULL);
}

/**
 * sensor_threshold_get_upper_critical: (skip)
 * @object: A #SensorThreshold.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorThreshold.upper_critical">"upper_critical"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use sensor_threshold_dup_upper_critical() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
sensor_threshold_get_upper_critical (SensorThreshold *object)
{
  return SENSOR_THRESHOLD_GET_IFACE (object)->get_upper_critical (object);
}

/**
 * sensor_threshold_dup_upper_critical: (skip)
 * @object: A #SensorThreshold.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-SensorThreshold.upper_critical">"upper_critical"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
sensor_threshold_dup_upper_critical (SensorThreshold *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "upper-critical", &value, NULL);
  return value;
}

/**
 * sensor_threshold_set_upper_critical: (skip)
 * @object: A #SensorThreshold.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorThreshold.upper_critical">"upper_critical"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
sensor_threshold_set_upper_critical (SensorThreshold *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "upper-critical", value, NULL);
}

/**
 * sensor_threshold_get_state: (skip)
 * @object: A #SensorThreshold.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorThreshold.state">"state"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guchar 
sensor_threshold_get_state (SensorThreshold *object)
{
  return SENSOR_THRESHOLD_GET_IFACE (object)->get_state (object);
}

/**
 * sensor_threshold_set_state: (skip)
 * @object: A #SensorThreshold.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorThreshold.state">"state"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
sensor_threshold_set_state (SensorThreshold *object, guchar value)
{
  g_object_set (G_OBJECT (object), "state", value, NULL);
}

/**
 * sensor_threshold_emit_warning:
 * @object: A #SensorThreshold.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-SensorThreshold.Warning">"Warning"</link> D-Bus signal.
 */
void
sensor_threshold_emit_warning (
    SensorThreshold *object)
{
  g_signal_emit_by_name (object, "warning");
}

/**
 * sensor_threshold_emit_critical:
 * @object: A #SensorThreshold.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-SensorThreshold.Critical">"Critical"</link> D-Bus signal.
 */
void
sensor_threshold_emit_critical (
    SensorThreshold *object)
{
  g_signal_emit_by_name (object, "critical");
}

/**
 * sensor_threshold_emit_normal:
 * @object: A #SensorThreshold.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-SensorThreshold.Normal">"Normal"</link> D-Bus signal.
 */
void
sensor_threshold_emit_normal (
    SensorThreshold *object)
{
  g_signal_emit_by_name (object, "normal");
}

/**
 * sensor_threshold_call_get_state:
 * @proxy: A #SensorThresholdProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-SensorThreshold.getState">getState()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_threshold_call_get_state_finish() to get the result of the operation.
 *
 * See sensor_threshold_call_get_state_sync() for the synchronous, blocking version of this method.
 */
void
sensor_threshold_call_get_state (
    SensorThreshold *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getState",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * sensor_threshold_call_get_state_finish:
 * @proxy: A #SensorThresholdProxy.
 * @out_state: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_threshold_call_get_state().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with sensor_threshold_call_get_state().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
sensor_threshold_call_get_state_finish (
    SensorThreshold *proxy,
    guchar *out_state,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(y)",
                 out_state);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * sensor_threshold_call_get_state_sync:
 * @proxy: A #SensorThresholdProxy.
 * @out_state: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-SensorThreshold.getState">getState()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See sensor_threshold_call_get_state() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
sensor_threshold_call_get_state_sync (
    SensorThreshold *proxy,
    guchar *out_state,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getState",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(y)",
                 out_state);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * sensor_threshold_complete_get_state:
 * @object: A #SensorThreshold.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @state: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-SensorThreshold.getState">getState()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
sensor_threshold_complete_get_state (
    SensorThreshold *object,
    GDBusMethodInvocation *invocation,
    guchar state)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(y)",
                   state));
}

/* ------------------------------------------------------------------------ */

/**
 * SensorThresholdProxy:
 *
 * The #SensorThresholdProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * SensorThresholdProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #SensorThresholdProxy.
 */

struct _SensorThresholdProxyPrivate
{
  GData *qdata;
};

static void sensor_threshold_proxy_iface_init (SensorThresholdIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (SensorThresholdProxy, sensor_threshold_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (SensorThresholdProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_THRESHOLD, sensor_threshold_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (SensorThresholdProxy, sensor_threshold_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_THRESHOLD, sensor_threshold_proxy_iface_init));

#endif
static void
sensor_threshold_proxy_finalize (GObject *object)
{
  SensorThresholdProxy *proxy = SENSOR_THRESHOLD_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (sensor_threshold_proxy_parent_class)->finalize (object);
}

static void
sensor_threshold_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  info = _sensor_threshold_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
sensor_threshold_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.SensorThreshold: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
sensor_threshold_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  info = _sensor_threshold_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.SensorThreshold", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) sensor_threshold_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
sensor_threshold_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_sensor_threshold_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_SENSOR_THRESHOLD);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_SENSOR_THRESHOLD);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
sensor_threshold_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  SensorThresholdProxy *proxy = SENSOR_THRESHOLD_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_threshold_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_threshold_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static GVariant *
sensor_threshold_proxy_get_lower_critical (SensorThreshold *object)
{
  SensorThresholdProxy *proxy = SENSOR_THRESHOLD_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "lower_critical");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
sensor_threshold_proxy_get_lower_warning (SensorThreshold *object)
{
  SensorThresholdProxy *proxy = SENSOR_THRESHOLD_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "lower_warning");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
sensor_threshold_proxy_get_upper_warning (SensorThreshold *object)
{
  SensorThresholdProxy *proxy = SENSOR_THRESHOLD_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "upper_warning");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static GVariant *
sensor_threshold_proxy_get_upper_critical (SensorThreshold *object)
{
  SensorThresholdProxy *proxy = SENSOR_THRESHOLD_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "upper_critical");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static guchar 
sensor_threshold_proxy_get_state (SensorThreshold *object)
{
  SensorThresholdProxy *proxy = SENSOR_THRESHOLD_PROXY (object);
  GVariant *variant;
  guchar value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "state");
  if (variant != NULL)
    {
      value = g_variant_get_byte (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
sensor_threshold_proxy_init (SensorThresholdProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = sensor_threshold_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_SENSOR_THRESHOLD_PROXY, SensorThresholdProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), sensor_threshold_interface_info ());
}

static void
sensor_threshold_proxy_class_init (SensorThresholdProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = sensor_threshold_proxy_finalize;
  gobject_class->get_property = sensor_threshold_proxy_get_property;
  gobject_class->set_property = sensor_threshold_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = sensor_threshold_proxy_g_signal;
  proxy_class->g_properties_changed = sensor_threshold_proxy_g_properties_changed;

  sensor_threshold_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (SensorThresholdProxyPrivate));
#endif
}

static void
sensor_threshold_proxy_iface_init (SensorThresholdIface *iface)
{
  iface->get_lower_critical = sensor_threshold_proxy_get_lower_critical;
  iface->get_lower_warning = sensor_threshold_proxy_get_lower_warning;
  iface->get_upper_warning = sensor_threshold_proxy_get_upper_warning;
  iface->get_upper_critical = sensor_threshold_proxy_get_upper_critical;
  iface->get_state = sensor_threshold_proxy_get_state;
}

/**
 * sensor_threshold_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorThreshold.top_of_page">org.openbmc.SensorThreshold</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_threshold_proxy_new_finish() to get the result of the operation.
 *
 * See sensor_threshold_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
sensor_threshold_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_SENSOR_THRESHOLD_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorThreshold", NULL);
}

/**
 * sensor_threshold_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_threshold_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with sensor_threshold_proxy_new().
 *
 * Returns: (transfer full) (type SensorThresholdProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorThreshold *
sensor_threshold_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return SENSOR_THRESHOLD (ret);
  else
    return NULL;
}

/**
 * sensor_threshold_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorThreshold.top_of_page">org.openbmc.SensorThreshold</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See sensor_threshold_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type SensorThresholdProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorThreshold *
sensor_threshold_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_SENSOR_THRESHOLD_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorThreshold", NULL);
  if (ret != NULL)
    return SENSOR_THRESHOLD (ret);
  else
    return NULL;
}


/**
 * sensor_threshold_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like sensor_threshold_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_threshold_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See sensor_threshold_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
sensor_threshold_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_SENSOR_THRESHOLD_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorThreshold", NULL);
}

/**
 * sensor_threshold_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_threshold_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with sensor_threshold_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type SensorThresholdProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorThreshold *
sensor_threshold_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return SENSOR_THRESHOLD (ret);
  else
    return NULL;
}

/**
 * sensor_threshold_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like sensor_threshold_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See sensor_threshold_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type SensorThresholdProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorThreshold *
sensor_threshold_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_SENSOR_THRESHOLD_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorThreshold", NULL);
  if (ret != NULL)
    return SENSOR_THRESHOLD (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * SensorThresholdSkeleton:
 *
 * The #SensorThresholdSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * SensorThresholdSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #SensorThresholdSkeleton.
 */

struct _SensorThresholdSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_sensor_threshold_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_SENSOR_THRESHOLD);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_SENSOR_THRESHOLD);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_sensor_threshold_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_threshold_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_sensor_threshold_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_threshold_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _sensor_threshold_skeleton_vtable =
{
  _sensor_threshold_skeleton_handle_method_call,
  _sensor_threshold_skeleton_handle_get_property,
  _sensor_threshold_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
sensor_threshold_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return sensor_threshold_interface_info ();
}

static GDBusInterfaceVTable *
sensor_threshold_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_sensor_threshold_skeleton_vtable;
}

static GVariant *
sensor_threshold_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_sensor_threshold_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _sensor_threshold_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _sensor_threshold_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _sensor_threshold_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorThreshold", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _sensor_threshold_emit_changed (gpointer user_data);

static void
sensor_threshold_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _sensor_threshold_emit_changed (skeleton);
}

static void
_sensor_threshold_on_signal_warning (
    SensorThreshold *object)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorThreshold", "Warning",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_sensor_threshold_on_signal_critical (
    SensorThreshold *object)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorThreshold", "Critical",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_sensor_threshold_on_signal_normal (
    SensorThreshold *object)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorThreshold", "Normal",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void sensor_threshold_skeleton_iface_init (SensorThresholdIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (SensorThresholdSkeleton, sensor_threshold_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (SensorThresholdSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_THRESHOLD, sensor_threshold_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (SensorThresholdSkeleton, sensor_threshold_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_THRESHOLD, sensor_threshold_skeleton_iface_init));

#endif
static void
sensor_threshold_skeleton_finalize (GObject *object)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);
  guint n;
  for (n = 0; n < 5; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (sensor_threshold_skeleton_parent_class)->finalize (object);
}

static void
sensor_threshold_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_sensor_threshold_emit_changed (gpointer user_data)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.SensorThreshold",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_sensor_threshold_schedule_emit_changed (SensorThresholdSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
sensor_threshold_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _sensor_threshold_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _sensor_threshold_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
sensor_threshold_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _sensor_threshold_schedule_emit_changed (skeleton, _sensor_threshold_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
sensor_threshold_skeleton_init (SensorThresholdSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = sensor_threshold_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_SENSOR_THRESHOLD_SKELETON, SensorThresholdSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 5);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_UCHAR);
}

static GVariant *
sensor_threshold_skeleton_get_lower_critical (SensorThreshold *object)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
sensor_threshold_skeleton_get_lower_warning (SensorThreshold *object)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
sensor_threshold_skeleton_get_upper_warning (SensorThreshold *object)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
sensor_threshold_skeleton_get_upper_critical (SensorThreshold *object)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static guchar 
sensor_threshold_skeleton_get_state (SensorThreshold *object)
{
  SensorThresholdSkeleton *skeleton = SENSOR_THRESHOLD_SKELETON (object);
  guchar value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_uchar (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
sensor_threshold_skeleton_class_init (SensorThresholdSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = sensor_threshold_skeleton_finalize;
  gobject_class->get_property = sensor_threshold_skeleton_get_property;
  gobject_class->set_property = sensor_threshold_skeleton_set_property;
  gobject_class->notify       = sensor_threshold_skeleton_notify;


  sensor_threshold_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = sensor_threshold_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = sensor_threshold_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = sensor_threshold_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = sensor_threshold_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (SensorThresholdSkeletonPrivate));
#endif
}

static void
sensor_threshold_skeleton_iface_init (SensorThresholdIface *iface)
{
  iface->warning = _sensor_threshold_on_signal_warning;
  iface->critical = _sensor_threshold_on_signal_critical;
  iface->normal = _sensor_threshold_on_signal_normal;
  iface->get_lower_critical = sensor_threshold_skeleton_get_lower_critical;
  iface->get_lower_warning = sensor_threshold_skeleton_get_lower_warning;
  iface->get_upper_warning = sensor_threshold_skeleton_get_upper_warning;
  iface->get_upper_critical = sensor_threshold_skeleton_get_upper_critical;
  iface->get_state = sensor_threshold_skeleton_get_state;
}

/**
 * sensor_threshold_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorThreshold.top_of_page">org.openbmc.SensorThreshold</link>.
 *
 * Returns: (transfer full) (type SensorThresholdSkeleton): The skeleton object.
 */
SensorThreshold *
sensor_threshold_skeleton_new (void)
{
  return SENSOR_THRESHOLD (g_object_new (TYPE_SENSOR_THRESHOLD_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.SensorI2c
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:SensorI2c
 * @title: SensorI2c
 * @short_description: Generated C code for the org.openbmc.SensorI2c D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-SensorI2c.top_of_page">org.openbmc.SensorI2c</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.SensorI2c ---- */

static const _ExtendedGDBusPropertyInfo _sensor_i2c_property_info_dev_path =
{
  {
    -1,
    (gchar *) "dev_path",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "dev-path",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _sensor_i2c_property_info_address =
{
  {
    -1,
    (gchar *) "address",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "address",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _sensor_i2c_property_info_pointers[] =
{
  &_sensor_i2c_property_info_dev_path,
  &_sensor_i2c_property_info_address,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _sensor_i2c_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.SensorI2c",
    NULL,
    NULL,
    (GDBusPropertyInfo **) &_sensor_i2c_property_info_pointers,
    NULL
  },
  "sensor-i2c",
};


/**
 * sensor_i2c_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-SensorI2c.top_of_page">org.openbmc.SensorI2c</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
sensor_i2c_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_sensor_i2c_interface_info.parent_struct;
}

/**
 * sensor_i2c_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #SensorI2c interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
sensor_i2c_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "dev-path");
  g_object_class_override_property (klass, property_id_begin++, "address");
  return property_id_begin - 1;
}



/**
 * SensorI2c:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorI2c.top_of_page">org.openbmc.SensorI2c</link>.
 */

/**
 * SensorI2cIface:
 * @parent_iface: The parent interface.
 * @get_address: Getter for the #SensorI2c:address property.
 * @get_dev_path: Getter for the #SensorI2c:dev-path property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorI2c.top_of_page">org.openbmc.SensorI2c</link>.
 */

typedef SensorI2cIface SensorI2cInterface;
G_DEFINE_INTERFACE (SensorI2c, sensor_i2c, G_TYPE_OBJECT);

static void
sensor_i2c_default_init (SensorI2cIface *iface)
{
  /* GObject properties for D-Bus properties: */
  /**
   * SensorI2c:dev-path:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorI2c.dev_path">"dev_path"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("dev-path", "dev_path", "dev_path", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SensorI2c:address:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorI2c.address">"address"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("address", "address", "address", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * sensor_i2c_get_dev_path: (skip)
 * @object: A #SensorI2c.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorI2c.dev_path">"dev_path"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use sensor_i2c_dup_dev_path() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
sensor_i2c_get_dev_path (SensorI2c *object)
{
  return SENSOR_I2C_GET_IFACE (object)->get_dev_path (object);
}

/**
 * sensor_i2c_dup_dev_path: (skip)
 * @object: A #SensorI2c.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-SensorI2c.dev_path">"dev_path"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
sensor_i2c_dup_dev_path (SensorI2c *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "dev-path", &value, NULL);
  return value;
}

/**
 * sensor_i2c_set_dev_path: (skip)
 * @object: A #SensorI2c.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorI2c.dev_path">"dev_path"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
sensor_i2c_set_dev_path (SensorI2c *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "dev-path", value, NULL);
}

/**
 * sensor_i2c_get_address: (skip)
 * @object: A #SensorI2c.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorI2c.address">"address"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use sensor_i2c_dup_address() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
sensor_i2c_get_address (SensorI2c *object)
{
  return SENSOR_I2C_GET_IFACE (object)->get_address (object);
}

/**
 * sensor_i2c_dup_address: (skip)
 * @object: A #SensorI2c.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-SensorI2c.address">"address"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
sensor_i2c_dup_address (SensorI2c *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "address", &value, NULL);
  return value;
}

/**
 * sensor_i2c_set_address: (skip)
 * @object: A #SensorI2c.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorI2c.address">"address"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
sensor_i2c_set_address (SensorI2c *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "address", value, NULL);
}

/* ------------------------------------------------------------------------ */

/**
 * SensorI2cProxy:
 *
 * The #SensorI2cProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * SensorI2cProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #SensorI2cProxy.
 */

struct _SensorI2cProxyPrivate
{
  GData *qdata;
};

static void sensor_i2c_proxy_iface_init (SensorI2cIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (SensorI2cProxy, sensor_i2c_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (SensorI2cProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_I2C, sensor_i2c_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (SensorI2cProxy, sensor_i2c_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_I2C, sensor_i2c_proxy_iface_init));

#endif
static void
sensor_i2c_proxy_finalize (GObject *object)
{
  SensorI2cProxy *proxy = SENSOR_I2C_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (sensor_i2c_proxy_parent_class)->finalize (object);
}

static void
sensor_i2c_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _sensor_i2c_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
sensor_i2c_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.SensorI2c: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
sensor_i2c_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _sensor_i2c_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.SensorI2c", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) sensor_i2c_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
sensor_i2c_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_sensor_i2c_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_SENSOR_I2C);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_SENSOR_I2C);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
sensor_i2c_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  SensorI2cProxy *proxy = SENSOR_I2C_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_i2c_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_i2c_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
sensor_i2c_proxy_get_dev_path (SensorI2c *object)
{
  SensorI2cProxy *proxy = SENSOR_I2C_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "dev_path");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
sensor_i2c_proxy_get_address (SensorI2c *object)
{
  SensorI2cProxy *proxy = SENSOR_I2C_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "address");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
sensor_i2c_proxy_init (SensorI2cProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = sensor_i2c_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_SENSOR_I2C_PROXY, SensorI2cProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), sensor_i2c_interface_info ());
}

static void
sensor_i2c_proxy_class_init (SensorI2cProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = sensor_i2c_proxy_finalize;
  gobject_class->get_property = sensor_i2c_proxy_get_property;
  gobject_class->set_property = sensor_i2c_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = sensor_i2c_proxy_g_signal;
  proxy_class->g_properties_changed = sensor_i2c_proxy_g_properties_changed;

  sensor_i2c_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (SensorI2cProxyPrivate));
#endif
}

static void
sensor_i2c_proxy_iface_init (SensorI2cIface *iface)
{
  iface->get_dev_path = sensor_i2c_proxy_get_dev_path;
  iface->get_address = sensor_i2c_proxy_get_address;
}

/**
 * sensor_i2c_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorI2c.top_of_page">org.openbmc.SensorI2c</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_i2c_proxy_new_finish() to get the result of the operation.
 *
 * See sensor_i2c_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
sensor_i2c_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_SENSOR_I2C_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorI2c", NULL);
}

/**
 * sensor_i2c_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_i2c_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with sensor_i2c_proxy_new().
 *
 * Returns: (transfer full) (type SensorI2cProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorI2c *
sensor_i2c_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return SENSOR_I2C (ret);
  else
    return NULL;
}

/**
 * sensor_i2c_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorI2c.top_of_page">org.openbmc.SensorI2c</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See sensor_i2c_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type SensorI2cProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorI2c *
sensor_i2c_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_SENSOR_I2C_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorI2c", NULL);
  if (ret != NULL)
    return SENSOR_I2C (ret);
  else
    return NULL;
}


/**
 * sensor_i2c_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like sensor_i2c_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_i2c_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See sensor_i2c_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
sensor_i2c_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_SENSOR_I2C_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorI2c", NULL);
}

/**
 * sensor_i2c_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_i2c_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with sensor_i2c_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type SensorI2cProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorI2c *
sensor_i2c_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return SENSOR_I2C (ret);
  else
    return NULL;
}

/**
 * sensor_i2c_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like sensor_i2c_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See sensor_i2c_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type SensorI2cProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorI2c *
sensor_i2c_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_SENSOR_I2C_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorI2c", NULL);
  if (ret != NULL)
    return SENSOR_I2C (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * SensorI2cSkeleton:
 *
 * The #SensorI2cSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * SensorI2cSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #SensorI2cSkeleton.
 */

struct _SensorI2cSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_sensor_i2c_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_SENSOR_I2C);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_SENSOR_I2C);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_sensor_i2c_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_i2c_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_sensor_i2c_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_i2c_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _sensor_i2c_skeleton_vtable =
{
  _sensor_i2c_skeleton_handle_method_call,
  _sensor_i2c_skeleton_handle_get_property,
  _sensor_i2c_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
sensor_i2c_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return sensor_i2c_interface_info ();
}

static GDBusInterfaceVTable *
sensor_i2c_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_sensor_i2c_skeleton_vtable;
}

static GVariant *
sensor_i2c_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_sensor_i2c_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _sensor_i2c_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _sensor_i2c_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _sensor_i2c_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorI2c", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _sensor_i2c_emit_changed (gpointer user_data);

static void
sensor_i2c_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _sensor_i2c_emit_changed (skeleton);
}

static void sensor_i2c_skeleton_iface_init (SensorI2cIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (SensorI2cSkeleton, sensor_i2c_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (SensorI2cSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_I2C, sensor_i2c_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (SensorI2cSkeleton, sensor_i2c_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_I2C, sensor_i2c_skeleton_iface_init));

#endif
static void
sensor_i2c_skeleton_finalize (GObject *object)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (sensor_i2c_skeleton_parent_class)->finalize (object);
}

static void
sensor_i2c_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_sensor_i2c_emit_changed (gpointer user_data)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.SensorI2c",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_sensor_i2c_schedule_emit_changed (SensorI2cSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
sensor_i2c_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _sensor_i2c_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _sensor_i2c_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
sensor_i2c_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _sensor_i2c_schedule_emit_changed (skeleton, _sensor_i2c_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
sensor_i2c_skeleton_init (SensorI2cSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = sensor_i2c_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_SENSOR_I2C_SKELETON, SensorI2cSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static const gchar *
sensor_i2c_skeleton_get_dev_path (SensorI2c *object)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
sensor_i2c_skeleton_get_address (SensorI2c *object)
{
  SensorI2cSkeleton *skeleton = SENSOR_I2C_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
sensor_i2c_skeleton_class_init (SensorI2cSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = sensor_i2c_skeleton_finalize;
  gobject_class->get_property = sensor_i2c_skeleton_get_property;
  gobject_class->set_property = sensor_i2c_skeleton_set_property;
  gobject_class->notify       = sensor_i2c_skeleton_notify;


  sensor_i2c_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = sensor_i2c_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = sensor_i2c_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = sensor_i2c_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = sensor_i2c_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (SensorI2cSkeletonPrivate));
#endif
}

static void
sensor_i2c_skeleton_iface_init (SensorI2cIface *iface)
{
  iface->get_dev_path = sensor_i2c_skeleton_get_dev_path;
  iface->get_address = sensor_i2c_skeleton_get_address;
}

/**
 * sensor_i2c_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorI2c.top_of_page">org.openbmc.SensorI2c</link>.
 *
 * Returns: (transfer full) (type SensorI2cSkeleton): The skeleton object.
 */
SensorI2c *
sensor_i2c_skeleton_new (void)
{
  return SENSOR_I2C (g_object_new (TYPE_SENSOR_I2C_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.SensorMatch
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:SensorMatch
 * @title: SensorMatch
 * @short_description: Generated C code for the org.openbmc.SensorMatch D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-SensorMatch.top_of_page">org.openbmc.SensorMatch</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.SensorMatch ---- */

static const _ExtendedGDBusArgInfo _sensor_match_signal_info_sensor_match_ARG_state =
{
  {
    -1,
    (gchar *) "state",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _sensor_match_signal_info_sensor_match_ARG_pointers[] =
{
  &_sensor_match_signal_info_sensor_match_ARG_state,
  NULL
};

static const _ExtendedGDBusSignalInfo _sensor_match_signal_info_sensor_match =
{
  {
    -1,
    (gchar *) "SensorMatch",
    (GDBusArgInfo **) &_sensor_match_signal_info_sensor_match_ARG_pointers,
    NULL
  },
  "sensor-match"
};

static const _ExtendedGDBusSignalInfo * const _sensor_match_signal_info_pointers[] =
{
  &_sensor_match_signal_info_sensor_match,
  NULL
};

static const _ExtendedGDBusPropertyInfo _sensor_match_property_info_match_value =
{
  {
    -1,
    (gchar *) "match_value",
    (gchar *) "v",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "match-value",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _sensor_match_property_info_state =
{
  {
    -1,
    (gchar *) "state",
    (gchar *) "y",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "state",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _sensor_match_property_info_pointers[] =
{
  &_sensor_match_property_info_match_value,
  &_sensor_match_property_info_state,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _sensor_match_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.SensorMatch",
    NULL,
    (GDBusSignalInfo **) &_sensor_match_signal_info_pointers,
    (GDBusPropertyInfo **) &_sensor_match_property_info_pointers,
    NULL
  },
  "sensor-match",
};


/**
 * sensor_match_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-SensorMatch.top_of_page">org.openbmc.SensorMatch</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
sensor_match_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_sensor_match_interface_info.parent_struct;
}

/**
 * sensor_match_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #SensorMatch interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
sensor_match_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "match-value");
  g_object_class_override_property (klass, property_id_begin++, "state");
  return property_id_begin - 1;
}



/**
 * SensorMatch:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorMatch.top_of_page">org.openbmc.SensorMatch</link>.
 */

/**
 * SensorMatchIface:
 * @parent_iface: The parent interface.
 * @get_match_value: Getter for the #SensorMatch:match-value property.
 * @get_state: Getter for the #SensorMatch:state property.
 * @sensor_match: Handler for the #SensorMatch::sensor-match signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorMatch.top_of_page">org.openbmc.SensorMatch</link>.
 */

typedef SensorMatchIface SensorMatchInterface;
G_DEFINE_INTERFACE (SensorMatch, sensor_match, G_TYPE_OBJECT);

static void
sensor_match_default_init (SensorMatchIface *iface)
{
  /* GObject signals for received D-Bus signals: */
  /**
   * SensorMatch::sensor-match:
   * @object: A #SensorMatch.
   * @arg_state: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-SensorMatch.SensorMatch">"SensorMatch"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("sensor-match",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SensorMatchIface, sensor_match),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_UCHAR);

  /* GObject properties for D-Bus properties: */
  /**
   * SensorMatch:match-value:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorMatch.match_value">"match_value"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("match-value", "match_value", "match_value", G_VARIANT_TYPE ("v"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SensorMatch:state:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SensorMatch.state">"state"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uchar ("state", "state", "state", 0, 255, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * sensor_match_get_match_value: (skip)
 * @object: A #SensorMatch.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorMatch.match_value">"match_value"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use sensor_match_dup_match_value() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
sensor_match_get_match_value (SensorMatch *object)
{
  return SENSOR_MATCH_GET_IFACE (object)->get_match_value (object);
}

/**
 * sensor_match_dup_match_value: (skip)
 * @object: A #SensorMatch.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-SensorMatch.match_value">"match_value"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
sensor_match_dup_match_value (SensorMatch *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "match-value", &value, NULL);
  return value;
}

/**
 * sensor_match_set_match_value: (skip)
 * @object: A #SensorMatch.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorMatch.match_value">"match_value"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
sensor_match_set_match_value (SensorMatch *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "match-value", value, NULL);
}

/**
 * sensor_match_get_state: (skip)
 * @object: A #SensorMatch.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SensorMatch.state">"state"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guchar 
sensor_match_get_state (SensorMatch *object)
{
  return SENSOR_MATCH_GET_IFACE (object)->get_state (object);
}

/**
 * sensor_match_set_state: (skip)
 * @object: A #SensorMatch.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SensorMatch.state">"state"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
sensor_match_set_state (SensorMatch *object, guchar value)
{
  g_object_set (G_OBJECT (object), "state", value, NULL);
}

/**
 * sensor_match_emit_sensor_match:
 * @object: A #SensorMatch.
 * @arg_state: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-SensorMatch.SensorMatch">"SensorMatch"</link> D-Bus signal.
 */
void
sensor_match_emit_sensor_match (
    SensorMatch *object,
    guchar arg_state)
{
  g_signal_emit_by_name (object, "sensor-match", arg_state);
}

/* ------------------------------------------------------------------------ */

/**
 * SensorMatchProxy:
 *
 * The #SensorMatchProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * SensorMatchProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #SensorMatchProxy.
 */

struct _SensorMatchProxyPrivate
{
  GData *qdata;
};

static void sensor_match_proxy_iface_init (SensorMatchIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (SensorMatchProxy, sensor_match_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (SensorMatchProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_MATCH, sensor_match_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (SensorMatchProxy, sensor_match_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_MATCH, sensor_match_proxy_iface_init));

#endif
static void
sensor_match_proxy_finalize (GObject *object)
{
  SensorMatchProxy *proxy = SENSOR_MATCH_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (sensor_match_proxy_parent_class)->finalize (object);
}

static void
sensor_match_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _sensor_match_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
sensor_match_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.SensorMatch: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
sensor_match_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _sensor_match_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.SensorMatch", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) sensor_match_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
sensor_match_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_sensor_match_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_SENSOR_MATCH);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_SENSOR_MATCH);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
sensor_match_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  SensorMatchProxy *proxy = SENSOR_MATCH_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_match_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_match_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static GVariant *
sensor_match_proxy_get_match_value (SensorMatch *object)
{
  SensorMatchProxy *proxy = SENSOR_MATCH_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "match_value");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static guchar 
sensor_match_proxy_get_state (SensorMatch *object)
{
  SensorMatchProxy *proxy = SENSOR_MATCH_PROXY (object);
  GVariant *variant;
  guchar value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "state");
  if (variant != NULL)
    {
      value = g_variant_get_byte (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
sensor_match_proxy_init (SensorMatchProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = sensor_match_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_SENSOR_MATCH_PROXY, SensorMatchProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), sensor_match_interface_info ());
}

static void
sensor_match_proxy_class_init (SensorMatchProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = sensor_match_proxy_finalize;
  gobject_class->get_property = sensor_match_proxy_get_property;
  gobject_class->set_property = sensor_match_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = sensor_match_proxy_g_signal;
  proxy_class->g_properties_changed = sensor_match_proxy_g_properties_changed;

  sensor_match_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (SensorMatchProxyPrivate));
#endif
}

static void
sensor_match_proxy_iface_init (SensorMatchIface *iface)
{
  iface->get_match_value = sensor_match_proxy_get_match_value;
  iface->get_state = sensor_match_proxy_get_state;
}

/**
 * sensor_match_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorMatch.top_of_page">org.openbmc.SensorMatch</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_match_proxy_new_finish() to get the result of the operation.
 *
 * See sensor_match_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
sensor_match_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_SENSOR_MATCH_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorMatch", NULL);
}

/**
 * sensor_match_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_match_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with sensor_match_proxy_new().
 *
 * Returns: (transfer full) (type SensorMatchProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorMatch *
sensor_match_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return SENSOR_MATCH (ret);
  else
    return NULL;
}

/**
 * sensor_match_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorMatch.top_of_page">org.openbmc.SensorMatch</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See sensor_match_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type SensorMatchProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorMatch *
sensor_match_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_SENSOR_MATCH_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorMatch", NULL);
  if (ret != NULL)
    return SENSOR_MATCH (ret);
  else
    return NULL;
}


/**
 * sensor_match_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like sensor_match_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call sensor_match_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See sensor_match_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
sensor_match_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_SENSOR_MATCH_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorMatch", NULL);
}

/**
 * sensor_match_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to sensor_match_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with sensor_match_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type SensorMatchProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorMatch *
sensor_match_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return SENSOR_MATCH (ret);
  else
    return NULL;
}

/**
 * sensor_match_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like sensor_match_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See sensor_match_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type SensorMatchProxy): The constructed proxy object or %NULL if @error is set.
 */
SensorMatch *
sensor_match_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_SENSOR_MATCH_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.SensorMatch", NULL);
  if (ret != NULL)
    return SENSOR_MATCH (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * SensorMatchSkeleton:
 *
 * The #SensorMatchSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * SensorMatchSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #SensorMatchSkeleton.
 */

struct _SensorMatchSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_sensor_match_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_SENSOR_MATCH);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_SENSOR_MATCH);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_sensor_match_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_match_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_sensor_match_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_sensor_match_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _sensor_match_skeleton_vtable =
{
  _sensor_match_skeleton_handle_method_call,
  _sensor_match_skeleton_handle_get_property,
  _sensor_match_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
sensor_match_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return sensor_match_interface_info ();
}

static GDBusInterfaceVTable *
sensor_match_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_sensor_match_skeleton_vtable;
}

static GVariant *
sensor_match_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_sensor_match_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _sensor_match_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _sensor_match_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _sensor_match_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorMatch", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _sensor_match_emit_changed (gpointer user_data);

static void
sensor_match_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _sensor_match_emit_changed (skeleton);
}

static void
_sensor_match_on_signal_sensor_match (
    SensorMatch *object,
    guchar arg_state)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(y)",
                   arg_state));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SensorMatch", "SensorMatch",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void sensor_match_skeleton_iface_init (SensorMatchIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (SensorMatchSkeleton, sensor_match_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (SensorMatchSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_MATCH, sensor_match_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (SensorMatchSkeleton, sensor_match_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_SENSOR_MATCH, sensor_match_skeleton_iface_init));

#endif
static void
sensor_match_skeleton_finalize (GObject *object)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (sensor_match_skeleton_parent_class)->finalize (object);
}

static void
sensor_match_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_sensor_match_emit_changed (gpointer user_data)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.SensorMatch",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_sensor_match_schedule_emit_changed (SensorMatchSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
sensor_match_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _sensor_match_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _sensor_match_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
sensor_match_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _sensor_match_schedule_emit_changed (skeleton, _sensor_match_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
sensor_match_skeleton_init (SensorMatchSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = sensor_match_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_SENSOR_MATCH_SKELETON, SensorMatchSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_UCHAR);
}

static GVariant *
sensor_match_skeleton_get_match_value (SensorMatch *object)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static guchar 
sensor_match_skeleton_get_state (SensorMatch *object)
{
  SensorMatchSkeleton *skeleton = SENSOR_MATCH_SKELETON (object);
  guchar value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_uchar (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
sensor_match_skeleton_class_init (SensorMatchSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = sensor_match_skeleton_finalize;
  gobject_class->get_property = sensor_match_skeleton_get_property;
  gobject_class->set_property = sensor_match_skeleton_set_property;
  gobject_class->notify       = sensor_match_skeleton_notify;


  sensor_match_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = sensor_match_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = sensor_match_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = sensor_match_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = sensor_match_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (SensorMatchSkeletonPrivate));
#endif
}

static void
sensor_match_skeleton_iface_init (SensorMatchIface *iface)
{
  iface->sensor_match = _sensor_match_on_signal_sensor_match;
  iface->get_match_value = sensor_match_skeleton_get_match_value;
  iface->get_state = sensor_match_skeleton_get_state;
}

/**
 * sensor_match_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorMatch.top_of_page">org.openbmc.SensorMatch</link>.
 *
 * Returns: (transfer full) (type SensorMatchSkeleton): The skeleton object.
 */
SensorMatch *
sensor_match_skeleton_new (void)
{
  return SENSOR_MATCH (g_object_new (TYPE_SENSOR_MATCH_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.Process
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:Process
 * @title: Process
 * @short_description: Generated C code for the org.openbmc.Process D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-Process.top_of_page">org.openbmc.Process</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.Process ---- */

static const _ExtendedGDBusMethodInfo _process_method_info_stop =
{
  {
    -1,
    (gchar *) "stop",
    NULL,
    NULL,
    NULL
  },
  "handle-stop",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _process_method_info_pointers[] =
{
  &_process_method_info_stop,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _process_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.Process",
    (GDBusMethodInfo **) &_process_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "process",
};


/**
 * process_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-Process.top_of_page">org.openbmc.Process</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
process_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_process_interface_info.parent_struct;
}

/**
 * process_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #Process interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
process_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * Process:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Process.top_of_page">org.openbmc.Process</link>.
 */

/**
 * ProcessIface:
 * @parent_iface: The parent interface.
 * @handle_stop: Handler for the #Process::handle-stop signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Process.top_of_page">org.openbmc.Process</link>.
 */

typedef ProcessIface ProcessInterface;
G_DEFINE_INTERFACE (Process, process, G_TYPE_OBJECT);

static void
process_default_init (ProcessIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * Process::handle-stop:
   * @object: A #Process.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Process.stop">stop()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call process_complete_stop() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-stop",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ProcessIface, handle_stop),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

/**
 * process_call_stop:
 * @proxy: A #ProcessProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Process.stop">stop()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call process_call_stop_finish() to get the result of the operation.
 *
 * See process_call_stop_sync() for the synchronous, blocking version of this method.
 */
void
process_call_stop (
    Process *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "stop",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * process_call_stop_finish:
 * @proxy: A #ProcessProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to process_call_stop().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with process_call_stop().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
process_call_stop_finish (
    Process *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * process_call_stop_sync:
 * @proxy: A #ProcessProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Process.stop">stop()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See process_call_stop() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
process_call_stop_sync (
    Process *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "stop",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * process_complete_stop:
 * @object: A #Process.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Process.stop">stop()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
process_complete_stop (
    Process *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * ProcessProxy:
 *
 * The #ProcessProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ProcessProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ProcessProxy.
 */

struct _ProcessProxyPrivate
{
  GData *qdata;
};

static void process_proxy_iface_init (ProcessIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ProcessProxy, process_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (ProcessProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_PROCESS, process_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ProcessProxy, process_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_PROCESS, process_proxy_iface_init));

#endif
static void
process_proxy_finalize (GObject *object)
{
  ProcessProxy *proxy = PROCESS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (process_proxy_parent_class)->finalize (object);
}

static void
process_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
process_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
process_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_process_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_PROCESS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_PROCESS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
process_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  ProcessProxy *proxy = PROCESS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_process_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_process_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
process_proxy_init (ProcessProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = process_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_PROCESS_PROXY, ProcessProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), process_interface_info ());
}

static void
process_proxy_class_init (ProcessProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = process_proxy_finalize;
  gobject_class->get_property = process_proxy_get_property;
  gobject_class->set_property = process_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = process_proxy_g_signal;
  proxy_class->g_properties_changed = process_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ProcessProxyPrivate));
#endif
}

static void
process_proxy_iface_init (ProcessIface *iface)
{
}

/**
 * process_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Process.top_of_page">org.openbmc.Process</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call process_proxy_new_finish() to get the result of the operation.
 *
 * See process_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
process_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_PROCESS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Process", NULL);
}

/**
 * process_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to process_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with process_proxy_new().
 *
 * Returns: (transfer full) (type ProcessProxy): The constructed proxy object or %NULL if @error is set.
 */
Process *
process_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return PROCESS (ret);
  else
    return NULL;
}

/**
 * process_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Process.top_of_page">org.openbmc.Process</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See process_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ProcessProxy): The constructed proxy object or %NULL if @error is set.
 */
Process *
process_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_PROCESS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Process", NULL);
  if (ret != NULL)
    return PROCESS (ret);
  else
    return NULL;
}


/**
 * process_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like process_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call process_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See process_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
process_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_PROCESS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Process", NULL);
}

/**
 * process_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to process_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with process_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type ProcessProxy): The constructed proxy object or %NULL if @error is set.
 */
Process *
process_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return PROCESS (ret);
  else
    return NULL;
}

/**
 * process_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like process_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See process_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ProcessProxy): The constructed proxy object or %NULL if @error is set.
 */
Process *
process_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_PROCESS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Process", NULL);
  if (ret != NULL)
    return PROCESS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * ProcessSkeleton:
 *
 * The #ProcessSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ProcessSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ProcessSkeleton.
 */

struct _ProcessSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_process_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  ProcessSkeleton *skeleton = PROCESS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_PROCESS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_PROCESS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_process_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  ProcessSkeleton *skeleton = PROCESS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_process_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_process_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  ProcessSkeleton *skeleton = PROCESS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_process_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _process_skeleton_vtable =
{
  _process_skeleton_handle_method_call,
  _process_skeleton_handle_get_property,
  _process_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
process_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return process_interface_info ();
}

static GDBusInterfaceVTable *
process_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_process_skeleton_vtable;
}

static GVariant *
process_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  ProcessSkeleton *skeleton = PROCESS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_process_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _process_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _process_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _process_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Process", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
process_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void process_skeleton_iface_init (ProcessIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ProcessSkeleton, process_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (ProcessSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_PROCESS, process_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ProcessSkeleton, process_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_PROCESS, process_skeleton_iface_init));

#endif
static void
process_skeleton_finalize (GObject *object)
{
  ProcessSkeleton *skeleton = PROCESS_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (process_skeleton_parent_class)->finalize (object);
}

static void
process_skeleton_init (ProcessSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = process_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_PROCESS_SKELETON, ProcessSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
process_skeleton_class_init (ProcessSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = process_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = process_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = process_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = process_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = process_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ProcessSkeletonPrivate));
#endif
}

static void
process_skeleton_iface_init (ProcessIface *iface)
{
}

/**
 * process_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Process.top_of_page">org.openbmc.Process</link>.
 *
 * Returns: (transfer full) (type ProcessSkeleton): The skeleton object.
 */
Process *
process_skeleton_new (void)
{
  return PROCESS (g_object_new (TYPE_PROCESS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.SharedResource
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:SharedResource
 * @title: SharedResource
 * @short_description: Generated C code for the org.openbmc.SharedResource D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-SharedResource.top_of_page">org.openbmc.SharedResource</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.SharedResource ---- */

static const _ExtendedGDBusArgInfo _shared_resource_method_info_lock_IN_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _shared_resource_method_info_lock_IN_ARG_pointers[] =
{
  &_shared_resource_method_info_lock_IN_ARG_name,
  NULL
};

static const _ExtendedGDBusMethodInfo _shared_resource_method_info_lock =
{
  {
    -1,
    (gchar *) "lock",
    (GDBusArgInfo **) &_shared_resource_method_info_lock_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-lock",
  FALSE
};

static const _ExtendedGDBusMethodInfo _shared_resource_method_info_unlock =
{
  {
    -1,
    (gchar *) "unlock",
    NULL,
    NULL,
    NULL
  },
  "handle-unlock",
  FALSE
};

static const _ExtendedGDBusArgInfo _shared_resource_method_info_is_locked_OUT_ARG_lock =
{
  {
    -1,
    (gchar *) "lock",
    (gchar *) "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _shared_resource_method_info_is_locked_OUT_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _shared_resource_method_info_is_locked_OUT_ARG_pointers[] =
{
  &_shared_resource_method_info_is_locked_OUT_ARG_lock,
  &_shared_resource_method_info_is_locked_OUT_ARG_name,
  NULL
};

static const _ExtendedGDBusMethodInfo _shared_resource_method_info_is_locked =
{
  {
    -1,
    (gchar *) "isLocked",
    NULL,
    (GDBusArgInfo **) &_shared_resource_method_info_is_locked_OUT_ARG_pointers,
    NULL
  },
  "handle-is-locked",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _shared_resource_method_info_pointers[] =
{
  &_shared_resource_method_info_lock,
  &_shared_resource_method_info_unlock,
  &_shared_resource_method_info_is_locked,
  NULL
};

static const _ExtendedGDBusPropertyInfo _shared_resource_property_info_lock =
{
  {
    -1,
    (gchar *) "lock",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "lock",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _shared_resource_property_info_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _shared_resource_property_info_pointers[] =
{
  &_shared_resource_property_info_lock,
  &_shared_resource_property_info_name,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _shared_resource_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.SharedResource",
    (GDBusMethodInfo **) &_shared_resource_method_info_pointers,
    NULL,
    (GDBusPropertyInfo **) &_shared_resource_property_info_pointers,
    NULL
  },
  "shared-resource",
};


/**
 * shared_resource_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-SharedResource.top_of_page">org.openbmc.SharedResource</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
shared_resource_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_shared_resource_interface_info.parent_struct;
}

/**
 * shared_resource_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #SharedResource interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
shared_resource_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "lock");
  g_object_class_override_property (klass, property_id_begin++, "name");
  return property_id_begin - 1;
}



/**
 * SharedResource:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SharedResource.top_of_page">org.openbmc.SharedResource</link>.
 */

/**
 * SharedResourceIface:
 * @parent_iface: The parent interface.
 * @handle_is_locked: Handler for the #SharedResource::handle-is-locked signal.
 * @handle_lock: Handler for the #SharedResource::handle-lock signal.
 * @handle_unlock: Handler for the #SharedResource::handle-unlock signal.
 * @get_lock: Getter for the #SharedResource:lock property.
 * @get_name: Getter for the #SharedResource:name property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SharedResource.top_of_page">org.openbmc.SharedResource</link>.
 */

typedef SharedResourceIface SharedResourceInterface;
G_DEFINE_INTERFACE (SharedResource, shared_resource, G_TYPE_OBJECT);

static void
shared_resource_default_init (SharedResourceIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * SharedResource::handle-lock:
   * @object: A #SharedResource.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_name: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-SharedResource.lock">lock()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call shared_resource_complete_lock() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-lock",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SharedResourceIface, handle_lock),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * SharedResource::handle-unlock:
   * @object: A #SharedResource.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-SharedResource.unlock">unlock()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call shared_resource_complete_unlock() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-unlock",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SharedResourceIface, handle_unlock),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * SharedResource::handle-is-locked:
   * @object: A #SharedResource.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-SharedResource.isLocked">isLocked()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call shared_resource_complete_is_locked() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-is-locked",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (SharedResourceIface, handle_is_locked),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject properties for D-Bus properties: */
  /**
   * SharedResource:lock:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SharedResource.lock">"lock"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("lock", "lock", "lock", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * SharedResource:name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-SharedResource.name">"name"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("name", "name", "name", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * shared_resource_get_lock: (skip)
 * @object: A #SharedResource.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SharedResource.lock">"lock"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
shared_resource_get_lock (SharedResource *object)
{
  return SHARED_RESOURCE_GET_IFACE (object)->get_lock (object);
}

/**
 * shared_resource_set_lock: (skip)
 * @object: A #SharedResource.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SharedResource.lock">"lock"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
shared_resource_set_lock (SharedResource *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "lock", value, NULL);
}

/**
 * shared_resource_get_name: (skip)
 * @object: A #SharedResource.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-SharedResource.name">"name"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use shared_resource_dup_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
shared_resource_get_name (SharedResource *object)
{
  return SHARED_RESOURCE_GET_IFACE (object)->get_name (object);
}

/**
 * shared_resource_dup_name: (skip)
 * @object: A #SharedResource.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-SharedResource.name">"name"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
shared_resource_dup_name (SharedResource *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "name", &value, NULL);
  return value;
}

/**
 * shared_resource_set_name: (skip)
 * @object: A #SharedResource.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-SharedResource.name">"name"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
shared_resource_set_name (SharedResource *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "name", value, NULL);
}

/**
 * shared_resource_call_lock:
 * @proxy: A #SharedResourceProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-SharedResource.lock">lock()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call shared_resource_call_lock_finish() to get the result of the operation.
 *
 * See shared_resource_call_lock_sync() for the synchronous, blocking version of this method.
 */
void
shared_resource_call_lock (
    SharedResource *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "lock",
    g_variant_new ("(s)",
                   arg_name),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * shared_resource_call_lock_finish:
 * @proxy: A #SharedResourceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to shared_resource_call_lock().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with shared_resource_call_lock().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
shared_resource_call_lock_finish (
    SharedResource *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * shared_resource_call_lock_sync:
 * @proxy: A #SharedResourceProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-SharedResource.lock">lock()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See shared_resource_call_lock() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
shared_resource_call_lock_sync (
    SharedResource *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "lock",
    g_variant_new ("(s)",
                   arg_name),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * shared_resource_call_unlock:
 * @proxy: A #SharedResourceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-SharedResource.unlock">unlock()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call shared_resource_call_unlock_finish() to get the result of the operation.
 *
 * See shared_resource_call_unlock_sync() for the synchronous, blocking version of this method.
 */
void
shared_resource_call_unlock (
    SharedResource *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "unlock",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * shared_resource_call_unlock_finish:
 * @proxy: A #SharedResourceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to shared_resource_call_unlock().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with shared_resource_call_unlock().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
shared_resource_call_unlock_finish (
    SharedResource *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * shared_resource_call_unlock_sync:
 * @proxy: A #SharedResourceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-SharedResource.unlock">unlock()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See shared_resource_call_unlock() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
shared_resource_call_unlock_sync (
    SharedResource *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "unlock",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * shared_resource_call_is_locked:
 * @proxy: A #SharedResourceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-SharedResource.isLocked">isLocked()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call shared_resource_call_is_locked_finish() to get the result of the operation.
 *
 * See shared_resource_call_is_locked_sync() for the synchronous, blocking version of this method.
 */
void
shared_resource_call_is_locked (
    SharedResource *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "isLocked",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * shared_resource_call_is_locked_finish:
 * @proxy: A #SharedResourceProxy.
 * @out_lock: (out): Return location for return parameter or %NULL to ignore.
 * @out_name: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to shared_resource_call_is_locked().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with shared_resource_call_is_locked().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
shared_resource_call_is_locked_finish (
    SharedResource *proxy,
    gboolean *out_lock,
    gchar **out_name,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(bs)",
                 out_lock,
                 out_name);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * shared_resource_call_is_locked_sync:
 * @proxy: A #SharedResourceProxy.
 * @out_lock: (out): Return location for return parameter or %NULL to ignore.
 * @out_name: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-SharedResource.isLocked">isLocked()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See shared_resource_call_is_locked() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
shared_resource_call_is_locked_sync (
    SharedResource *proxy,
    gboolean *out_lock,
    gchar **out_name,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "isLocked",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(bs)",
                 out_lock,
                 out_name);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * shared_resource_complete_lock:
 * @object: A #SharedResource.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-SharedResource.lock">lock()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
shared_resource_complete_lock (
    SharedResource *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * shared_resource_complete_unlock:
 * @object: A #SharedResource.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-SharedResource.unlock">unlock()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
shared_resource_complete_unlock (
    SharedResource *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * shared_resource_complete_is_locked:
 * @object: A #SharedResource.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @lock: Parameter to return.
 * @name: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-SharedResource.isLocked">isLocked()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
shared_resource_complete_is_locked (
    SharedResource *object,
    GDBusMethodInvocation *invocation,
    gboolean lock,
    const gchar *name)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(bs)",
                   lock,
                   name));
}

/* ------------------------------------------------------------------------ */

/**
 * SharedResourceProxy:
 *
 * The #SharedResourceProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * SharedResourceProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #SharedResourceProxy.
 */

struct _SharedResourceProxyPrivate
{
  GData *qdata;
};

static void shared_resource_proxy_iface_init (SharedResourceIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (SharedResourceProxy, shared_resource_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (SharedResourceProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_SHARED_RESOURCE, shared_resource_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (SharedResourceProxy, shared_resource_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_SHARED_RESOURCE, shared_resource_proxy_iface_init));

#endif
static void
shared_resource_proxy_finalize (GObject *object)
{
  SharedResourceProxy *proxy = SHARED_RESOURCE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (shared_resource_proxy_parent_class)->finalize (object);
}

static void
shared_resource_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _shared_resource_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
shared_resource_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.SharedResource: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
shared_resource_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _shared_resource_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.SharedResource", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) shared_resource_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
shared_resource_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_shared_resource_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_SHARED_RESOURCE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_SHARED_RESOURCE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
shared_resource_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  SharedResourceProxy *proxy = SHARED_RESOURCE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_shared_resource_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_shared_resource_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gboolean 
shared_resource_proxy_get_lock (SharedResource *object)
{
  SharedResourceProxy *proxy = SHARED_RESOURCE_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "lock");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
shared_resource_proxy_get_name (SharedResource *object)
{
  SharedResourceProxy *proxy = SHARED_RESOURCE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "name");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
shared_resource_proxy_init (SharedResourceProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = shared_resource_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_SHARED_RESOURCE_PROXY, SharedResourceProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), shared_resource_interface_info ());
}

static void
shared_resource_proxy_class_init (SharedResourceProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = shared_resource_proxy_finalize;
  gobject_class->get_property = shared_resource_proxy_get_property;
  gobject_class->set_property = shared_resource_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = shared_resource_proxy_g_signal;
  proxy_class->g_properties_changed = shared_resource_proxy_g_properties_changed;

  shared_resource_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (SharedResourceProxyPrivate));
#endif
}

static void
shared_resource_proxy_iface_init (SharedResourceIface *iface)
{
  iface->get_lock = shared_resource_proxy_get_lock;
  iface->get_name = shared_resource_proxy_get_name;
}

/**
 * shared_resource_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SharedResource.top_of_page">org.openbmc.SharedResource</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call shared_resource_proxy_new_finish() to get the result of the operation.
 *
 * See shared_resource_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
shared_resource_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_SHARED_RESOURCE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.SharedResource", NULL);
}

/**
 * shared_resource_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to shared_resource_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with shared_resource_proxy_new().
 *
 * Returns: (transfer full) (type SharedResourceProxy): The constructed proxy object or %NULL if @error is set.
 */
SharedResource *
shared_resource_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return SHARED_RESOURCE (ret);
  else
    return NULL;
}

/**
 * shared_resource_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SharedResource.top_of_page">org.openbmc.SharedResource</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See shared_resource_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type SharedResourceProxy): The constructed proxy object or %NULL if @error is set.
 */
SharedResource *
shared_resource_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_SHARED_RESOURCE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.SharedResource", NULL);
  if (ret != NULL)
    return SHARED_RESOURCE (ret);
  else
    return NULL;
}


/**
 * shared_resource_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like shared_resource_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call shared_resource_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See shared_resource_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
shared_resource_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_SHARED_RESOURCE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.SharedResource", NULL);
}

/**
 * shared_resource_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to shared_resource_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with shared_resource_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type SharedResourceProxy): The constructed proxy object or %NULL if @error is set.
 */
SharedResource *
shared_resource_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return SHARED_RESOURCE (ret);
  else
    return NULL;
}

/**
 * shared_resource_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like shared_resource_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See shared_resource_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type SharedResourceProxy): The constructed proxy object or %NULL if @error is set.
 */
SharedResource *
shared_resource_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_SHARED_RESOURCE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.SharedResource", NULL);
  if (ret != NULL)
    return SHARED_RESOURCE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * SharedResourceSkeleton:
 *
 * The #SharedResourceSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * SharedResourceSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #SharedResourceSkeleton.
 */

struct _SharedResourceSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_shared_resource_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_SHARED_RESOURCE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_SHARED_RESOURCE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_shared_resource_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_shared_resource_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_shared_resource_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_shared_resource_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _shared_resource_skeleton_vtable =
{
  _shared_resource_skeleton_handle_method_call,
  _shared_resource_skeleton_handle_get_property,
  _shared_resource_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
shared_resource_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return shared_resource_interface_info ();
}

static GDBusInterfaceVTable *
shared_resource_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_shared_resource_skeleton_vtable;
}

static GVariant *
shared_resource_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_shared_resource_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _shared_resource_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _shared_resource_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _shared_resource_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.SharedResource", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _shared_resource_emit_changed (gpointer user_data);

static void
shared_resource_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _shared_resource_emit_changed (skeleton);
}

static void shared_resource_skeleton_iface_init (SharedResourceIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (SharedResourceSkeleton, shared_resource_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (SharedResourceSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_SHARED_RESOURCE, shared_resource_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (SharedResourceSkeleton, shared_resource_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_SHARED_RESOURCE, shared_resource_skeleton_iface_init));

#endif
static void
shared_resource_skeleton_finalize (GObject *object)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (shared_resource_skeleton_parent_class)->finalize (object);
}

static void
shared_resource_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_shared_resource_emit_changed (gpointer user_data)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.SharedResource",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_shared_resource_schedule_emit_changed (SharedResourceSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
shared_resource_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _shared_resource_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _shared_resource_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
shared_resource_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _shared_resource_schedule_emit_changed (skeleton, _shared_resource_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
shared_resource_skeleton_init (SharedResourceSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = shared_resource_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_SHARED_RESOURCE_SKELETON, SharedResourceSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static gboolean 
shared_resource_skeleton_get_lock (SharedResource *object)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
shared_resource_skeleton_get_name (SharedResource *object)
{
  SharedResourceSkeleton *skeleton = SHARED_RESOURCE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
shared_resource_skeleton_class_init (SharedResourceSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = shared_resource_skeleton_finalize;
  gobject_class->get_property = shared_resource_skeleton_get_property;
  gobject_class->set_property = shared_resource_skeleton_set_property;
  gobject_class->notify       = shared_resource_skeleton_notify;


  shared_resource_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = shared_resource_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = shared_resource_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = shared_resource_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = shared_resource_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (SharedResourceSkeletonPrivate));
#endif
}

static void
shared_resource_skeleton_iface_init (SharedResourceIface *iface)
{
  iface->get_lock = shared_resource_skeleton_get_lock;
  iface->get_name = shared_resource_skeleton_get_name;
}

/**
 * shared_resource_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SharedResource.top_of_page">org.openbmc.SharedResource</link>.
 *
 * Returns: (transfer full) (type SharedResourceSkeleton): The skeleton object.
 */
SharedResource *
shared_resource_skeleton_new (void)
{
  return SHARED_RESOURCE (g_object_new (TYPE_SHARED_RESOURCE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.Control
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:Control
 * @title: Control
 * @short_description: Generated C code for the org.openbmc.Control D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-Control.top_of_page">org.openbmc.Control</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.Control ---- */

static const _ExtendedGDBusMethodInfo _control_method_info_init =
{
  {
    -1,
    (gchar *) "init",
    NULL,
    NULL,
    NULL
  },
  "handle-init",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _control_method_info_pointers[] =
{
  &_control_method_info_init,
  NULL
};

static const _ExtendedGDBusArgInfo _control_signal_info_heartbeat_ARG_bus_name =
{
  {
    -1,
    (gchar *) "bus_name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _control_signal_info_heartbeat_ARG_pointers[] =
{
  &_control_signal_info_heartbeat_ARG_bus_name,
  NULL
};

static const _ExtendedGDBusSignalInfo _control_signal_info_heartbeat =
{
  {
    -1,
    (gchar *) "Heartbeat",
    (GDBusArgInfo **) &_control_signal_info_heartbeat_ARG_pointers,
    NULL
  },
  "heartbeat"
};

static const _ExtendedGDBusSignalInfo _control_signal_info_started =
{
  {
    -1,
    (gchar *) "Started",
    NULL,
    NULL
  },
  "started"
};

static const _ExtendedGDBusSignalInfo * const _control_signal_info_pointers[] =
{
  &_control_signal_info_heartbeat,
  &_control_signal_info_started,
  NULL
};

static const _ExtendedGDBusPropertyInfo _control_property_info_poll_interval =
{
  {
    -1,
    (gchar *) "poll_interval",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "poll-interval",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _control_property_info_heatbeat =
{
  {
    -1,
    (gchar *) "heatbeat",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "heatbeat",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _control_property_info_pointers[] =
{
  &_control_property_info_poll_interval,
  &_control_property_info_heatbeat,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _control_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.Control",
    (GDBusMethodInfo **) &_control_method_info_pointers,
    (GDBusSignalInfo **) &_control_signal_info_pointers,
    (GDBusPropertyInfo **) &_control_property_info_pointers,
    NULL
  },
  "control",
};


/**
 * control_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-Control.top_of_page">org.openbmc.Control</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
control_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_control_interface_info.parent_struct;
}

/**
 * control_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #Control interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
control_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "poll-interval");
  g_object_class_override_property (klass, property_id_begin++, "heatbeat");
  return property_id_begin - 1;
}



/**
 * Control:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Control.top_of_page">org.openbmc.Control</link>.
 */

/**
 * ControlIface:
 * @parent_iface: The parent interface.
 * @handle_init: Handler for the #Control::handle-init signal.
 * @get_heatbeat: Getter for the #Control:heatbeat property.
 * @get_poll_interval: Getter for the #Control:poll-interval property.
 * @heartbeat: Handler for the #Control::heartbeat signal.
 * @started: Handler for the #Control::started signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Control.top_of_page">org.openbmc.Control</link>.
 */

typedef ControlIface ControlInterface;
G_DEFINE_INTERFACE (Control, control, G_TYPE_OBJECT);

static void
control_default_init (ControlIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * Control::handle-init:
   * @object: A #Control.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Control.init">init()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call control_complete_init() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-init",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlIface, handle_init),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * Control::heartbeat:
   * @object: A #Control.
   * @arg_bus_name: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-Control.Heartbeat">"Heartbeat"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("heartbeat",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlIface, heartbeat),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * Control::started:
   * @object: A #Control.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-Control.Started">"Started"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("started",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlIface, started),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * Control:poll-interval:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Control.poll_interval">"poll_interval"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("poll-interval", "poll_interval", "poll_interval", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Control:heatbeat:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Control.heatbeat">"heatbeat"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("heatbeat", "heatbeat", "heatbeat", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * control_get_poll_interval: (skip)
 * @object: A #Control.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Control.poll_interval">"poll_interval"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
control_get_poll_interval (Control *object)
{
  return CONTROL_GET_IFACE (object)->get_poll_interval (object);
}

/**
 * control_set_poll_interval: (skip)
 * @object: A #Control.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Control.poll_interval">"poll_interval"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
control_set_poll_interval (Control *object, gint value)
{
  g_object_set (G_OBJECT (object), "poll-interval", value, NULL);
}

/**
 * control_get_heatbeat: (skip)
 * @object: A #Control.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Control.heatbeat">"heatbeat"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
control_get_heatbeat (Control *object)
{
  return CONTROL_GET_IFACE (object)->get_heatbeat (object);
}

/**
 * control_set_heatbeat: (skip)
 * @object: A #Control.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Control.heatbeat">"heatbeat"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
control_set_heatbeat (Control *object, gint value)
{
  g_object_set (G_OBJECT (object), "heatbeat", value, NULL);
}

/**
 * control_emit_heartbeat:
 * @object: A #Control.
 * @arg_bus_name: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-Control.Heartbeat">"Heartbeat"</link> D-Bus signal.
 */
void
control_emit_heartbeat (
    Control *object,
    const gchar *arg_bus_name)
{
  g_signal_emit_by_name (object, "heartbeat", arg_bus_name);
}

/**
 * control_emit_started:
 * @object: A #Control.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-Control.Started">"Started"</link> D-Bus signal.
 */
void
control_emit_started (
    Control *object)
{
  g_signal_emit_by_name (object, "started");
}

/**
 * control_call_init:
 * @proxy: A #ControlProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Control.init">init()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_call_init_finish() to get the result of the operation.
 *
 * See control_call_init_sync() for the synchronous, blocking version of this method.
 */
void
control_call_init (
    Control *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "init",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * control_call_init_finish:
 * @proxy: A #ControlProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_call_init().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with control_call_init().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_call_init_finish (
    Control *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_call_init_sync:
 * @proxy: A #ControlProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Control.init">init()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See control_call_init() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_call_init_sync (
    Control *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "init",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_complete_init:
 * @object: A #Control.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Control.init">init()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
control_complete_init (
    Control *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * ControlProxy:
 *
 * The #ControlProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ControlProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ControlProxy.
 */

struct _ControlProxyPrivate
{
  GData *qdata;
};

static void control_proxy_iface_init (ControlIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ControlProxy, control_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (ControlProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL, control_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ControlProxy, control_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL, control_proxy_iface_init));

#endif
static void
control_proxy_finalize (GObject *object)
{
  ControlProxy *proxy = CONTROL_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (control_proxy_parent_class)->finalize (object);
}

static void
control_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _control_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
control_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.Control: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
control_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _control_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.Control", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) control_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
control_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_control_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_CONTROL);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTROL);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
control_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  ControlProxy *proxy = CONTROL_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gint 
control_proxy_get_poll_interval (Control *object)
{
  ControlProxy *proxy = CONTROL_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "poll_interval");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
control_proxy_get_heatbeat (Control *object)
{
  ControlProxy *proxy = CONTROL_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "heatbeat");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
control_proxy_init (ControlProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = control_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_CONTROL_PROXY, ControlProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), control_interface_info ());
}

static void
control_proxy_class_init (ControlProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = control_proxy_finalize;
  gobject_class->get_property = control_proxy_get_property;
  gobject_class->set_property = control_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = control_proxy_g_signal;
  proxy_class->g_properties_changed = control_proxy_g_properties_changed;

  control_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ControlProxyPrivate));
#endif
}

static void
control_proxy_iface_init (ControlIface *iface)
{
  iface->get_poll_interval = control_proxy_get_poll_interval;
  iface->get_heatbeat = control_proxy_get_heatbeat;
}

/**
 * control_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Control.top_of_page">org.openbmc.Control</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_proxy_new_finish() to get the result of the operation.
 *
 * See control_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
control_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_CONTROL_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Control", NULL);
}

/**
 * control_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with control_proxy_new().
 *
 * Returns: (transfer full) (type ControlProxy): The constructed proxy object or %NULL if @error is set.
 */
Control *
control_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return CONTROL (ret);
  else
    return NULL;
}

/**
 * control_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Control.top_of_page">org.openbmc.Control</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See control_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ControlProxy): The constructed proxy object or %NULL if @error is set.
 */
Control *
control_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_CONTROL_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Control", NULL);
  if (ret != NULL)
    return CONTROL (ret);
  else
    return NULL;
}


/**
 * control_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like control_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See control_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
control_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_CONTROL_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Control", NULL);
}

/**
 * control_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with control_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type ControlProxy): The constructed proxy object or %NULL if @error is set.
 */
Control *
control_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return CONTROL (ret);
  else
    return NULL;
}

/**
 * control_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like control_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See control_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ControlProxy): The constructed proxy object or %NULL if @error is set.
 */
Control *
control_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_CONTROL_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Control", NULL);
  if (ret != NULL)
    return CONTROL (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * ControlSkeleton:
 *
 * The #ControlSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ControlSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ControlSkeleton.
 */

struct _ControlSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_control_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_CONTROL);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTROL);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_control_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_control_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _control_skeleton_vtable =
{
  _control_skeleton_handle_method_call,
  _control_skeleton_handle_get_property,
  _control_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
control_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return control_interface_info ();
}

static GDBusInterfaceVTable *
control_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_control_skeleton_vtable;
}

static GVariant *
control_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_control_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _control_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _control_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _control_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Control", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _control_emit_changed (gpointer user_data);

static void
control_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _control_emit_changed (skeleton);
}

static void
_control_on_signal_heartbeat (
    Control *object,
    const gchar *arg_bus_name)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
                   arg_bus_name));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Control", "Heartbeat",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_control_on_signal_started (
    Control *object)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Control", "Started",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void control_skeleton_iface_init (ControlIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ControlSkeleton, control_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (ControlSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL, control_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ControlSkeleton, control_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL, control_skeleton_iface_init));

#endif
static void
control_skeleton_finalize (GObject *object)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (control_skeleton_parent_class)->finalize (object);
}

static void
control_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_control_emit_changed (gpointer user_data)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.Control",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_control_schedule_emit_changed (ControlSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
control_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _control_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _control_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
control_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _control_schedule_emit_changed (skeleton, _control_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
control_skeleton_init (ControlSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = control_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_CONTROL_SKELETON, ControlSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_INT);
}

static gint 
control_skeleton_get_poll_interval (Control *object)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
control_skeleton_get_heatbeat (Control *object)
{
  ControlSkeleton *skeleton = CONTROL_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
control_skeleton_class_init (ControlSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = control_skeleton_finalize;
  gobject_class->get_property = control_skeleton_get_property;
  gobject_class->set_property = control_skeleton_set_property;
  gobject_class->notify       = control_skeleton_notify;


  control_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = control_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = control_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = control_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = control_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ControlSkeletonPrivate));
#endif
}

static void
control_skeleton_iface_init (ControlIface *iface)
{
  iface->heartbeat = _control_on_signal_heartbeat;
  iface->started = _control_on_signal_started;
  iface->get_poll_interval = control_skeleton_get_poll_interval;
  iface->get_heatbeat = control_skeleton_get_heatbeat;
}

/**
 * control_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Control.top_of_page">org.openbmc.Control</link>.
 *
 * Returns: (transfer full) (type ControlSkeleton): The skeleton object.
 */
Control *
control_skeleton_new (void)
{
  return CONTROL (g_object_new (TYPE_CONTROL_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.control.Bmc
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:ControlBmc
 * @title: ControlBmc
 * @short_description: Generated C code for the org.openbmc.control.Bmc D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-control-Bmc.top_of_page">org.openbmc.control.Bmc</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.control.Bmc ---- */

static const _ExtendedGDBusMethodInfo _control_bmc_method_info_cold_reset =
{
  {
    -1,
    (gchar *) "coldReset",
    NULL,
    NULL,
    NULL
  },
  "handle-cold-reset",
  FALSE
};

static const _ExtendedGDBusMethodInfo _control_bmc_method_info_warm_reset =
{
  {
    -1,
    (gchar *) "warmReset",
    NULL,
    NULL,
    NULL
  },
  "handle-warm-reset",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _control_bmc_method_info_pointers[] =
{
  &_control_bmc_method_info_cold_reset,
  &_control_bmc_method_info_warm_reset,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _control_bmc_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.control.Bmc",
    (GDBusMethodInfo **) &_control_bmc_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "control-bmc",
};


/**
 * control_bmc_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-control-Bmc.top_of_page">org.openbmc.control.Bmc</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
control_bmc_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_control_bmc_interface_info.parent_struct;
}

/**
 * control_bmc_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #ControlBmc interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
control_bmc_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * ControlBmc:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Bmc.top_of_page">org.openbmc.control.Bmc</link>.
 */

/**
 * ControlBmcIface:
 * @parent_iface: The parent interface.
 * @handle_cold_reset: Handler for the #ControlBmc::handle-cold-reset signal.
 * @handle_warm_reset: Handler for the #ControlBmc::handle-warm-reset signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Bmc.top_of_page">org.openbmc.control.Bmc</link>.
 */

typedef ControlBmcIface ControlBmcInterface;
G_DEFINE_INTERFACE (ControlBmc, control_bmc, G_TYPE_OBJECT);

static void
control_bmc_default_init (ControlBmcIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * ControlBmc::handle-cold-reset:
   * @object: A #ControlBmc.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-control-Bmc.coldReset">coldReset()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call control_bmc_complete_cold_reset() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-cold-reset",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlBmcIface, handle_cold_reset),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * ControlBmc::handle-warm-reset:
   * @object: A #ControlBmc.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-control-Bmc.warmReset">warmReset()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call control_bmc_complete_warm_reset() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-warm-reset",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlBmcIface, handle_warm_reset),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

/**
 * control_bmc_call_cold_reset:
 * @proxy: A #ControlBmcProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Bmc.coldReset">coldReset()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_bmc_call_cold_reset_finish() to get the result of the operation.
 *
 * See control_bmc_call_cold_reset_sync() for the synchronous, blocking version of this method.
 */
void
control_bmc_call_cold_reset (
    ControlBmc *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "coldReset",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * control_bmc_call_cold_reset_finish:
 * @proxy: A #ControlBmcProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_bmc_call_cold_reset().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with control_bmc_call_cold_reset().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_bmc_call_cold_reset_finish (
    ControlBmc *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_bmc_call_cold_reset_sync:
 * @proxy: A #ControlBmcProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Bmc.coldReset">coldReset()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See control_bmc_call_cold_reset() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_bmc_call_cold_reset_sync (
    ControlBmc *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "coldReset",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_bmc_call_warm_reset:
 * @proxy: A #ControlBmcProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Bmc.warmReset">warmReset()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_bmc_call_warm_reset_finish() to get the result of the operation.
 *
 * See control_bmc_call_warm_reset_sync() for the synchronous, blocking version of this method.
 */
void
control_bmc_call_warm_reset (
    ControlBmc *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "warmReset",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * control_bmc_call_warm_reset_finish:
 * @proxy: A #ControlBmcProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_bmc_call_warm_reset().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with control_bmc_call_warm_reset().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_bmc_call_warm_reset_finish (
    ControlBmc *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_bmc_call_warm_reset_sync:
 * @proxy: A #ControlBmcProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Bmc.warmReset">warmReset()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See control_bmc_call_warm_reset() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_bmc_call_warm_reset_sync (
    ControlBmc *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "warmReset",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_bmc_complete_cold_reset:
 * @object: A #ControlBmc.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-control-Bmc.coldReset">coldReset()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
control_bmc_complete_cold_reset (
    ControlBmc *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * control_bmc_complete_warm_reset:
 * @object: A #ControlBmc.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-control-Bmc.warmReset">warmReset()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
control_bmc_complete_warm_reset (
    ControlBmc *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * ControlBmcProxy:
 *
 * The #ControlBmcProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ControlBmcProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ControlBmcProxy.
 */

struct _ControlBmcProxyPrivate
{
  GData *qdata;
};

static void control_bmc_proxy_iface_init (ControlBmcIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ControlBmcProxy, control_bmc_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (ControlBmcProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_BMC, control_bmc_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ControlBmcProxy, control_bmc_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_BMC, control_bmc_proxy_iface_init));

#endif
static void
control_bmc_proxy_finalize (GObject *object)
{
  ControlBmcProxy *proxy = CONTROL_BMC_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (control_bmc_proxy_parent_class)->finalize (object);
}

static void
control_bmc_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
control_bmc_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
control_bmc_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_control_bmc_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_CONTROL_BMC);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTROL_BMC);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
control_bmc_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  ControlBmcProxy *proxy = CONTROL_BMC_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_bmc_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_bmc_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
control_bmc_proxy_init (ControlBmcProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = control_bmc_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_CONTROL_BMC_PROXY, ControlBmcProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), control_bmc_interface_info ());
}

static void
control_bmc_proxy_class_init (ControlBmcProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = control_bmc_proxy_finalize;
  gobject_class->get_property = control_bmc_proxy_get_property;
  gobject_class->set_property = control_bmc_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = control_bmc_proxy_g_signal;
  proxy_class->g_properties_changed = control_bmc_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ControlBmcProxyPrivate));
#endif
}

static void
control_bmc_proxy_iface_init (ControlBmcIface *iface)
{
}

/**
 * control_bmc_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Bmc.top_of_page">org.openbmc.control.Bmc</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_bmc_proxy_new_finish() to get the result of the operation.
 *
 * See control_bmc_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
control_bmc_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_CONTROL_BMC_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Bmc", NULL);
}

/**
 * control_bmc_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_bmc_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with control_bmc_proxy_new().
 *
 * Returns: (transfer full) (type ControlBmcProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlBmc *
control_bmc_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return CONTROL_BMC (ret);
  else
    return NULL;
}

/**
 * control_bmc_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Bmc.top_of_page">org.openbmc.control.Bmc</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See control_bmc_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ControlBmcProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlBmc *
control_bmc_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_CONTROL_BMC_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Bmc", NULL);
  if (ret != NULL)
    return CONTROL_BMC (ret);
  else
    return NULL;
}


/**
 * control_bmc_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like control_bmc_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_bmc_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See control_bmc_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
control_bmc_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_CONTROL_BMC_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Bmc", NULL);
}

/**
 * control_bmc_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_bmc_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with control_bmc_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type ControlBmcProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlBmc *
control_bmc_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return CONTROL_BMC (ret);
  else
    return NULL;
}

/**
 * control_bmc_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like control_bmc_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See control_bmc_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ControlBmcProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlBmc *
control_bmc_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_CONTROL_BMC_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Bmc", NULL);
  if (ret != NULL)
    return CONTROL_BMC (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * ControlBmcSkeleton:
 *
 * The #ControlBmcSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ControlBmcSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ControlBmcSkeleton.
 */

struct _ControlBmcSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_control_bmc_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  ControlBmcSkeleton *skeleton = CONTROL_BMC_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_CONTROL_BMC);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTROL_BMC);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_control_bmc_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  ControlBmcSkeleton *skeleton = CONTROL_BMC_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_bmc_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_control_bmc_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  ControlBmcSkeleton *skeleton = CONTROL_BMC_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_bmc_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _control_bmc_skeleton_vtable =
{
  _control_bmc_skeleton_handle_method_call,
  _control_bmc_skeleton_handle_get_property,
  _control_bmc_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
control_bmc_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return control_bmc_interface_info ();
}

static GDBusInterfaceVTable *
control_bmc_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_control_bmc_skeleton_vtable;
}

static GVariant *
control_bmc_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  ControlBmcSkeleton *skeleton = CONTROL_BMC_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_control_bmc_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _control_bmc_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _control_bmc_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _control_bmc_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.control.Bmc", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
control_bmc_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void control_bmc_skeleton_iface_init (ControlBmcIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ControlBmcSkeleton, control_bmc_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (ControlBmcSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_BMC, control_bmc_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ControlBmcSkeleton, control_bmc_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_BMC, control_bmc_skeleton_iface_init));

#endif
static void
control_bmc_skeleton_finalize (GObject *object)
{
  ControlBmcSkeleton *skeleton = CONTROL_BMC_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (control_bmc_skeleton_parent_class)->finalize (object);
}

static void
control_bmc_skeleton_init (ControlBmcSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = control_bmc_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_CONTROL_BMC_SKELETON, ControlBmcSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
control_bmc_skeleton_class_init (ControlBmcSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = control_bmc_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = control_bmc_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = control_bmc_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = control_bmc_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = control_bmc_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ControlBmcSkeletonPrivate));
#endif
}

static void
control_bmc_skeleton_iface_init (ControlBmcIface *iface)
{
}

/**
 * control_bmc_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Bmc.top_of_page">org.openbmc.control.Bmc</link>.
 *
 * Returns: (transfer full) (type ControlBmcSkeleton): The skeleton object.
 */
ControlBmc *
control_bmc_skeleton_new (void)
{
  return CONTROL_BMC (g_object_new (TYPE_CONTROL_BMC_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.control.Host
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:ControlHost
 * @title: ControlHost
 * @short_description: Generated C code for the org.openbmc.control.Host D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-control-Host.top_of_page">org.openbmc.control.Host</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.control.Host ---- */

static const _ExtendedGDBusMethodInfo _control_host_method_info_boot =
{
  {
    -1,
    (gchar *) "boot",
    NULL,
    NULL,
    NULL
  },
  "handle-boot",
  FALSE
};

static const _ExtendedGDBusMethodInfo _control_host_method_info_shutdown =
{
  {
    -1,
    (gchar *) "shutdown",
    NULL,
    NULL,
    NULL
  },
  "handle-shutdown",
  FALSE
};

static const _ExtendedGDBusMethodInfo _control_host_method_info_reboot =
{
  {
    -1,
    (gchar *) "reboot",
    NULL,
    NULL,
    NULL
  },
  "handle-reboot",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _control_host_method_info_pointers[] =
{
  &_control_host_method_info_boot,
  &_control_host_method_info_shutdown,
  &_control_host_method_info_reboot,
  NULL
};

static const _ExtendedGDBusSignalInfo _control_host_signal_info_booted =
{
  {
    -1,
    (gchar *) "Booted",
    NULL,
    NULL
  },
  "booted"
};

static const _ExtendedGDBusSignalInfo * const _control_host_signal_info_pointers[] =
{
  &_control_host_signal_info_booted,
  NULL
};

static const _ExtendedGDBusPropertyInfo _control_host_property_info_debug_mode =
{
  {
    -1,
    (gchar *) "debug_mode",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "debug-mode",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _control_host_property_info_flash_side =
{
  {
    -1,
    (gchar *) "flash_side",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "flash-side",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _control_host_property_info_pointers[] =
{
  &_control_host_property_info_debug_mode,
  &_control_host_property_info_flash_side,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _control_host_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.control.Host",
    (GDBusMethodInfo **) &_control_host_method_info_pointers,
    (GDBusSignalInfo **) &_control_host_signal_info_pointers,
    (GDBusPropertyInfo **) &_control_host_property_info_pointers,
    NULL
  },
  "control-host",
};


/**
 * control_host_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-control-Host.top_of_page">org.openbmc.control.Host</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
control_host_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_control_host_interface_info.parent_struct;
}

/**
 * control_host_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #ControlHost interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
control_host_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "debug-mode");
  g_object_class_override_property (klass, property_id_begin++, "flash-side");
  return property_id_begin - 1;
}



/**
 * ControlHost:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Host.top_of_page">org.openbmc.control.Host</link>.
 */

/**
 * ControlHostIface:
 * @parent_iface: The parent interface.
 * @handle_boot: Handler for the #ControlHost::handle-boot signal.
 * @handle_reboot: Handler for the #ControlHost::handle-reboot signal.
 * @handle_shutdown: Handler for the #ControlHost::handle-shutdown signal.
 * @get_debug_mode: Getter for the #ControlHost:debug-mode property.
 * @get_flash_side: Getter for the #ControlHost:flash-side property.
 * @booted: Handler for the #ControlHost::booted signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Host.top_of_page">org.openbmc.control.Host</link>.
 */

typedef ControlHostIface ControlHostInterface;
G_DEFINE_INTERFACE (ControlHost, control_host, G_TYPE_OBJECT);

static void
control_host_default_init (ControlHostIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * ControlHost::handle-boot:
   * @object: A #ControlHost.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-control-Host.boot">boot()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call control_host_complete_boot() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-boot",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlHostIface, handle_boot),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * ControlHost::handle-shutdown:
   * @object: A #ControlHost.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-control-Host.shutdown">shutdown()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call control_host_complete_shutdown() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-shutdown",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlHostIface, handle_shutdown),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * ControlHost::handle-reboot:
   * @object: A #ControlHost.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-control-Host.reboot">reboot()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call control_host_complete_reboot() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-reboot",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlHostIface, handle_reboot),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * ControlHost::booted:
   * @object: A #ControlHost.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-control-Host.Booted">"Booted"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("booted",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlHostIface, booted),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * ControlHost:debug-mode:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-control-Host.debug_mode">"debug_mode"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("debug-mode", "debug_mode", "debug_mode", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * ControlHost:flash-side:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-control-Host.flash_side">"flash_side"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("flash-side", "flash_side", "flash_side", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * control_host_get_debug_mode: (skip)
 * @object: A #ControlHost.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-control-Host.debug_mode">"debug_mode"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
control_host_get_debug_mode (ControlHost *object)
{
  return CONTROL_HOST_GET_IFACE (object)->get_debug_mode (object);
}

/**
 * control_host_set_debug_mode: (skip)
 * @object: A #ControlHost.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-control-Host.debug_mode">"debug_mode"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
control_host_set_debug_mode (ControlHost *object, gint value)
{
  g_object_set (G_OBJECT (object), "debug-mode", value, NULL);
}

/**
 * control_host_get_flash_side: (skip)
 * @object: A #ControlHost.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-control-Host.flash_side">"flash_side"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use control_host_dup_flash_side() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
control_host_get_flash_side (ControlHost *object)
{
  return CONTROL_HOST_GET_IFACE (object)->get_flash_side (object);
}

/**
 * control_host_dup_flash_side: (skip)
 * @object: A #ControlHost.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-control-Host.flash_side">"flash_side"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
control_host_dup_flash_side (ControlHost *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "flash-side", &value, NULL);
  return value;
}

/**
 * control_host_set_flash_side: (skip)
 * @object: A #ControlHost.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-control-Host.flash_side">"flash_side"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
control_host_set_flash_side (ControlHost *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "flash-side", value, NULL);
}

/**
 * control_host_emit_booted:
 * @object: A #ControlHost.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-control-Host.Booted">"Booted"</link> D-Bus signal.
 */
void
control_host_emit_booted (
    ControlHost *object)
{
  g_signal_emit_by_name (object, "booted");
}

/**
 * control_host_call_boot:
 * @proxy: A #ControlHostProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Host.boot">boot()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_host_call_boot_finish() to get the result of the operation.
 *
 * See control_host_call_boot_sync() for the synchronous, blocking version of this method.
 */
void
control_host_call_boot (
    ControlHost *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "boot",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * control_host_call_boot_finish:
 * @proxy: A #ControlHostProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_host_call_boot().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with control_host_call_boot().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_host_call_boot_finish (
    ControlHost *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_host_call_boot_sync:
 * @proxy: A #ControlHostProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Host.boot">boot()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See control_host_call_boot() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_host_call_boot_sync (
    ControlHost *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "boot",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_host_call_shutdown:
 * @proxy: A #ControlHostProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Host.shutdown">shutdown()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_host_call_shutdown_finish() to get the result of the operation.
 *
 * See control_host_call_shutdown_sync() for the synchronous, blocking version of this method.
 */
void
control_host_call_shutdown (
    ControlHost *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "shutdown",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * control_host_call_shutdown_finish:
 * @proxy: A #ControlHostProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_host_call_shutdown().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with control_host_call_shutdown().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_host_call_shutdown_finish (
    ControlHost *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_host_call_shutdown_sync:
 * @proxy: A #ControlHostProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Host.shutdown">shutdown()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See control_host_call_shutdown() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_host_call_shutdown_sync (
    ControlHost *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "shutdown",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_host_call_reboot:
 * @proxy: A #ControlHostProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Host.reboot">reboot()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_host_call_reboot_finish() to get the result of the operation.
 *
 * See control_host_call_reboot_sync() for the synchronous, blocking version of this method.
 */
void
control_host_call_reboot (
    ControlHost *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "reboot",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * control_host_call_reboot_finish:
 * @proxy: A #ControlHostProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_host_call_reboot().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with control_host_call_reboot().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_host_call_reboot_finish (
    ControlHost *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_host_call_reboot_sync:
 * @proxy: A #ControlHostProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Host.reboot">reboot()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See control_host_call_reboot() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_host_call_reboot_sync (
    ControlHost *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "reboot",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_host_complete_boot:
 * @object: A #ControlHost.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-control-Host.boot">boot()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
control_host_complete_boot (
    ControlHost *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * control_host_complete_shutdown:
 * @object: A #ControlHost.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-control-Host.shutdown">shutdown()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
control_host_complete_shutdown (
    ControlHost *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * control_host_complete_reboot:
 * @object: A #ControlHost.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-control-Host.reboot">reboot()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
control_host_complete_reboot (
    ControlHost *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * ControlHostProxy:
 *
 * The #ControlHostProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ControlHostProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ControlHostProxy.
 */

struct _ControlHostProxyPrivate
{
  GData *qdata;
};

static void control_host_proxy_iface_init (ControlHostIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ControlHostProxy, control_host_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (ControlHostProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_HOST, control_host_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ControlHostProxy, control_host_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_HOST, control_host_proxy_iface_init));

#endif
static void
control_host_proxy_finalize (GObject *object)
{
  ControlHostProxy *proxy = CONTROL_HOST_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (control_host_proxy_parent_class)->finalize (object);
}

static void
control_host_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _control_host_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
control_host_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.control.Host: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
control_host_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _control_host_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.control.Host", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) control_host_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
control_host_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_control_host_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_CONTROL_HOST);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTROL_HOST);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
control_host_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  ControlHostProxy *proxy = CONTROL_HOST_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_host_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_host_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gint 
control_host_proxy_get_debug_mode (ControlHost *object)
{
  ControlHostProxy *proxy = CONTROL_HOST_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "debug_mode");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
control_host_proxy_get_flash_side (ControlHost *object)
{
  ControlHostProxy *proxy = CONTROL_HOST_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "flash_side");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
control_host_proxy_init (ControlHostProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = control_host_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_CONTROL_HOST_PROXY, ControlHostProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), control_host_interface_info ());
}

static void
control_host_proxy_class_init (ControlHostProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = control_host_proxy_finalize;
  gobject_class->get_property = control_host_proxy_get_property;
  gobject_class->set_property = control_host_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = control_host_proxy_g_signal;
  proxy_class->g_properties_changed = control_host_proxy_g_properties_changed;

  control_host_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ControlHostProxyPrivate));
#endif
}

static void
control_host_proxy_iface_init (ControlHostIface *iface)
{
  iface->get_debug_mode = control_host_proxy_get_debug_mode;
  iface->get_flash_side = control_host_proxy_get_flash_side;
}

/**
 * control_host_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Host.top_of_page">org.openbmc.control.Host</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_host_proxy_new_finish() to get the result of the operation.
 *
 * See control_host_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
control_host_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_CONTROL_HOST_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Host", NULL);
}

/**
 * control_host_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_host_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with control_host_proxy_new().
 *
 * Returns: (transfer full) (type ControlHostProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlHost *
control_host_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return CONTROL_HOST (ret);
  else
    return NULL;
}

/**
 * control_host_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Host.top_of_page">org.openbmc.control.Host</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See control_host_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ControlHostProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlHost *
control_host_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_CONTROL_HOST_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Host", NULL);
  if (ret != NULL)
    return CONTROL_HOST (ret);
  else
    return NULL;
}


/**
 * control_host_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like control_host_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_host_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See control_host_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
control_host_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_CONTROL_HOST_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Host", NULL);
}

/**
 * control_host_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_host_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with control_host_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type ControlHostProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlHost *
control_host_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return CONTROL_HOST (ret);
  else
    return NULL;
}

/**
 * control_host_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like control_host_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See control_host_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ControlHostProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlHost *
control_host_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_CONTROL_HOST_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Host", NULL);
  if (ret != NULL)
    return CONTROL_HOST (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * ControlHostSkeleton:
 *
 * The #ControlHostSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ControlHostSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ControlHostSkeleton.
 */

struct _ControlHostSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_control_host_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_CONTROL_HOST);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTROL_HOST);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_control_host_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_host_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_control_host_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_host_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _control_host_skeleton_vtable =
{
  _control_host_skeleton_handle_method_call,
  _control_host_skeleton_handle_get_property,
  _control_host_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
control_host_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return control_host_interface_info ();
}

static GDBusInterfaceVTable *
control_host_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_control_host_skeleton_vtable;
}

static GVariant *
control_host_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_control_host_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _control_host_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _control_host_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _control_host_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.control.Host", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _control_host_emit_changed (gpointer user_data);

static void
control_host_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _control_host_emit_changed (skeleton);
}

static void
_control_host_on_signal_booted (
    ControlHost *object)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.control.Host", "Booted",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void control_host_skeleton_iface_init (ControlHostIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ControlHostSkeleton, control_host_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (ControlHostSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_HOST, control_host_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ControlHostSkeleton, control_host_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_HOST, control_host_skeleton_iface_init));

#endif
static void
control_host_skeleton_finalize (GObject *object)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (control_host_skeleton_parent_class)->finalize (object);
}

static void
control_host_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_control_host_emit_changed (gpointer user_data)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.control.Host",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_control_host_schedule_emit_changed (ControlHostSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
control_host_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _control_host_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _control_host_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
control_host_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _control_host_schedule_emit_changed (skeleton, _control_host_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
control_host_skeleton_init (ControlHostSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = control_host_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_CONTROL_HOST_SKELETON, ControlHostSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static gint 
control_host_skeleton_get_debug_mode (ControlHost *object)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
control_host_skeleton_get_flash_side (ControlHost *object)
{
  ControlHostSkeleton *skeleton = CONTROL_HOST_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
control_host_skeleton_class_init (ControlHostSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = control_host_skeleton_finalize;
  gobject_class->get_property = control_host_skeleton_get_property;
  gobject_class->set_property = control_host_skeleton_set_property;
  gobject_class->notify       = control_host_skeleton_notify;


  control_host_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = control_host_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = control_host_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = control_host_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = control_host_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ControlHostSkeletonPrivate));
#endif
}

static void
control_host_skeleton_iface_init (ControlHostIface *iface)
{
  iface->booted = _control_host_on_signal_booted;
  iface->get_debug_mode = control_host_skeleton_get_debug_mode;
  iface->get_flash_side = control_host_skeleton_get_flash_side;
}

/**
 * control_host_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Host.top_of_page">org.openbmc.control.Host</link>.
 *
 * Returns: (transfer full) (type ControlHostSkeleton): The skeleton object.
 */
ControlHost *
control_host_skeleton_new (void)
{
  return CONTROL_HOST (g_object_new (TYPE_CONTROL_HOST_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.control.Power
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:ControlPower
 * @title: ControlPower
 * @short_description: Generated C code for the org.openbmc.control.Power D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-control-Power.top_of_page">org.openbmc.control.Power</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.control.Power ---- */

static const _ExtendedGDBusArgInfo _control_power_method_info_set_power_state_IN_ARG_state =
{
  {
    -1,
    (gchar *) "state",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _control_power_method_info_set_power_state_IN_ARG_pointers[] =
{
  &_control_power_method_info_set_power_state_IN_ARG_state,
  NULL
};

static const _ExtendedGDBusMethodInfo _control_power_method_info_set_power_state =
{
  {
    -1,
    (gchar *) "setPowerState",
    (GDBusArgInfo **) &_control_power_method_info_set_power_state_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set-power-state",
  FALSE
};

static const _ExtendedGDBusArgInfo _control_power_method_info_get_power_state_OUT_ARG_state =
{
  {
    -1,
    (gchar *) "state",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _control_power_method_info_get_power_state_OUT_ARG_pointers[] =
{
  &_control_power_method_info_get_power_state_OUT_ARG_state,
  NULL
};

static const _ExtendedGDBusMethodInfo _control_power_method_info_get_power_state =
{
  {
    -1,
    (gchar *) "getPowerState",
    NULL,
    (GDBusArgInfo **) &_control_power_method_info_get_power_state_OUT_ARG_pointers,
    NULL
  },
  "handle-get-power-state",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _control_power_method_info_pointers[] =
{
  &_control_power_method_info_set_power_state,
  &_control_power_method_info_get_power_state,
  NULL
};

static const _ExtendedGDBusSignalInfo _control_power_signal_info_power_good =
{
  {
    -1,
    (gchar *) "PowerGood",
    NULL,
    NULL
  },
  "power-good"
};

static const _ExtendedGDBusSignalInfo _control_power_signal_info_power_lost =
{
  {
    -1,
    (gchar *) "PowerLost",
    NULL,
    NULL
  },
  "power-lost"
};

static const _ExtendedGDBusSignalInfo * const _control_power_signal_info_pointers[] =
{
  &_control_power_signal_info_power_good,
  &_control_power_signal_info_power_lost,
  NULL
};

static const _ExtendedGDBusPropertyInfo _control_power_property_info_pgood =
{
  {
    -1,
    (gchar *) "pgood",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "pgood",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _control_power_property_info_state =
{
  {
    -1,
    (gchar *) "state",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "state",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _control_power_property_info_pgood_timeout =
{
  {
    -1,
    (gchar *) "pgood_timeout",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "pgood-timeout",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _control_power_property_info_pointers[] =
{
  &_control_power_property_info_pgood,
  &_control_power_property_info_state,
  &_control_power_property_info_pgood_timeout,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _control_power_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.control.Power",
    (GDBusMethodInfo **) &_control_power_method_info_pointers,
    (GDBusSignalInfo **) &_control_power_signal_info_pointers,
    (GDBusPropertyInfo **) &_control_power_property_info_pointers,
    NULL
  },
  "control-power",
};


/**
 * control_power_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-control-Power.top_of_page">org.openbmc.control.Power</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
control_power_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_control_power_interface_info.parent_struct;
}

/**
 * control_power_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #ControlPower interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
control_power_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "pgood");
  g_object_class_override_property (klass, property_id_begin++, "state");
  g_object_class_override_property (klass, property_id_begin++, "pgood-timeout");
  return property_id_begin - 1;
}



/**
 * ControlPower:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Power.top_of_page">org.openbmc.control.Power</link>.
 */

/**
 * ControlPowerIface:
 * @parent_iface: The parent interface.
 * @handle_get_power_state: Handler for the #ControlPower::handle-get-power-state signal.
 * @handle_set_power_state: Handler for the #ControlPower::handle-set-power-state signal.
 * @get_pgood: Getter for the #ControlPower:pgood property.
 * @get_pgood_timeout: Getter for the #ControlPower:pgood-timeout property.
 * @get_state: Getter for the #ControlPower:state property.
 * @power_good: Handler for the #ControlPower::power-good signal.
 * @power_lost: Handler for the #ControlPower::power-lost signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Power.top_of_page">org.openbmc.control.Power</link>.
 */

typedef ControlPowerIface ControlPowerInterface;
G_DEFINE_INTERFACE (ControlPower, control_power, G_TYPE_OBJECT);

static void
control_power_default_init (ControlPowerIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * ControlPower::handle-set-power-state:
   * @object: A #ControlPower.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_state: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-control-Power.setPowerState">setPowerState()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call control_power_complete_set_power_state() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-power-state",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlPowerIface, handle_set_power_state),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);

  /**
   * ControlPower::handle-get-power-state:
   * @object: A #ControlPower.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-control-Power.getPowerState">getPowerState()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call control_power_complete_get_power_state() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-power-state",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlPowerIface, handle_get_power_state),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * ControlPower::power-good:
   * @object: A #ControlPower.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-control-Power.PowerGood">"PowerGood"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("power-good",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlPowerIface, power_good),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * ControlPower::power-lost:
   * @object: A #ControlPower.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-control-Power.PowerLost">"PowerLost"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("power-lost",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ControlPowerIface, power_lost),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * ControlPower:pgood:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-control-Power.pgood">"pgood"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("pgood", "pgood", "pgood", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * ControlPower:state:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-control-Power.state">"state"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("state", "state", "state", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * ControlPower:pgood-timeout:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-control-Power.pgood_timeout">"pgood_timeout"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("pgood-timeout", "pgood_timeout", "pgood_timeout", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * control_power_get_pgood: (skip)
 * @object: A #ControlPower.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-control-Power.pgood">"pgood"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
control_power_get_pgood (ControlPower *object)
{
  return CONTROL_POWER_GET_IFACE (object)->get_pgood (object);
}

/**
 * control_power_set_pgood: (skip)
 * @object: A #ControlPower.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-control-Power.pgood">"pgood"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
control_power_set_pgood (ControlPower *object, gint value)
{
  g_object_set (G_OBJECT (object), "pgood", value, NULL);
}

/**
 * control_power_get_state: (skip)
 * @object: A #ControlPower.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-control-Power.state">"state"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
control_power_get_state (ControlPower *object)
{
  return CONTROL_POWER_GET_IFACE (object)->get_state (object);
}

/**
 * control_power_set_state: (skip)
 * @object: A #ControlPower.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-control-Power.state">"state"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
control_power_set_state (ControlPower *object, gint value)
{
  g_object_set (G_OBJECT (object), "state", value, NULL);
}

/**
 * control_power_get_pgood_timeout: (skip)
 * @object: A #ControlPower.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-control-Power.pgood_timeout">"pgood_timeout"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
control_power_get_pgood_timeout (ControlPower *object)
{
  return CONTROL_POWER_GET_IFACE (object)->get_pgood_timeout (object);
}

/**
 * control_power_set_pgood_timeout: (skip)
 * @object: A #ControlPower.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-control-Power.pgood_timeout">"pgood_timeout"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
control_power_set_pgood_timeout (ControlPower *object, gint value)
{
  g_object_set (G_OBJECT (object), "pgood-timeout", value, NULL);
}

/**
 * control_power_emit_power_good:
 * @object: A #ControlPower.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-control-Power.PowerGood">"PowerGood"</link> D-Bus signal.
 */
void
control_power_emit_power_good (
    ControlPower *object)
{
  g_signal_emit_by_name (object, "power-good");
}

/**
 * control_power_emit_power_lost:
 * @object: A #ControlPower.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-control-Power.PowerLost">"PowerLost"</link> D-Bus signal.
 */
void
control_power_emit_power_lost (
    ControlPower *object)
{
  g_signal_emit_by_name (object, "power-lost");
}

/**
 * control_power_call_set_power_state:
 * @proxy: A #ControlPowerProxy.
 * @arg_state: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Power.setPowerState">setPowerState()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_power_call_set_power_state_finish() to get the result of the operation.
 *
 * See control_power_call_set_power_state_sync() for the synchronous, blocking version of this method.
 */
void
control_power_call_set_power_state (
    ControlPower *proxy,
    gint arg_state,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setPowerState",
    g_variant_new ("(i)",
                   arg_state),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * control_power_call_set_power_state_finish:
 * @proxy: A #ControlPowerProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_power_call_set_power_state().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with control_power_call_set_power_state().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_power_call_set_power_state_finish (
    ControlPower *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_power_call_set_power_state_sync:
 * @proxy: A #ControlPowerProxy.
 * @arg_state: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Power.setPowerState">setPowerState()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See control_power_call_set_power_state() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_power_call_set_power_state_sync (
    ControlPower *proxy,
    gint arg_state,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setPowerState",
    g_variant_new ("(i)",
                   arg_state),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_power_call_get_power_state:
 * @proxy: A #ControlPowerProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Power.getPowerState">getPowerState()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_power_call_get_power_state_finish() to get the result of the operation.
 *
 * See control_power_call_get_power_state_sync() for the synchronous, blocking version of this method.
 */
void
control_power_call_get_power_state (
    ControlPower *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getPowerState",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * control_power_call_get_power_state_finish:
 * @proxy: A #ControlPowerProxy.
 * @out_state: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_power_call_get_power_state().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with control_power_call_get_power_state().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_power_call_get_power_state_finish (
    ControlPower *proxy,
    gint *out_state,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_state);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_power_call_get_power_state_sync:
 * @proxy: A #ControlPowerProxy.
 * @out_state: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-control-Power.getPowerState">getPowerState()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See control_power_call_get_power_state() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
control_power_call_get_power_state_sync (
    ControlPower *proxy,
    gint *out_state,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getPowerState",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_state);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * control_power_complete_set_power_state:
 * @object: A #ControlPower.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-control-Power.setPowerState">setPowerState()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
control_power_complete_set_power_state (
    ControlPower *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * control_power_complete_get_power_state:
 * @object: A #ControlPower.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @state: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-control-Power.getPowerState">getPowerState()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
control_power_complete_get_power_state (
    ControlPower *object,
    GDBusMethodInvocation *invocation,
    gint state)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(i)",
                   state));
}

/* ------------------------------------------------------------------------ */

/**
 * ControlPowerProxy:
 *
 * The #ControlPowerProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ControlPowerProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ControlPowerProxy.
 */

struct _ControlPowerProxyPrivate
{
  GData *qdata;
};

static void control_power_proxy_iface_init (ControlPowerIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ControlPowerProxy, control_power_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (ControlPowerProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_POWER, control_power_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ControlPowerProxy, control_power_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_POWER, control_power_proxy_iface_init));

#endif
static void
control_power_proxy_finalize (GObject *object)
{
  ControlPowerProxy *proxy = CONTROL_POWER_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (control_power_proxy_parent_class)->finalize (object);
}

static void
control_power_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _control_power_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
control_power_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.control.Power: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
control_power_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _control_power_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.control.Power", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) control_power_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
control_power_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_control_power_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_CONTROL_POWER);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTROL_POWER);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
control_power_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  ControlPowerProxy *proxy = CONTROL_POWER_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_power_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_power_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gint 
control_power_proxy_get_pgood (ControlPower *object)
{
  ControlPowerProxy *proxy = CONTROL_POWER_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "pgood");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
control_power_proxy_get_state (ControlPower *object)
{
  ControlPowerProxy *proxy = CONTROL_POWER_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "state");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
control_power_proxy_get_pgood_timeout (ControlPower *object)
{
  ControlPowerProxy *proxy = CONTROL_POWER_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "pgood_timeout");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
control_power_proxy_init (ControlPowerProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = control_power_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_CONTROL_POWER_PROXY, ControlPowerProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), control_power_interface_info ());
}

static void
control_power_proxy_class_init (ControlPowerProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = control_power_proxy_finalize;
  gobject_class->get_property = control_power_proxy_get_property;
  gobject_class->set_property = control_power_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = control_power_proxy_g_signal;
  proxy_class->g_properties_changed = control_power_proxy_g_properties_changed;

  control_power_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ControlPowerProxyPrivate));
#endif
}

static void
control_power_proxy_iface_init (ControlPowerIface *iface)
{
  iface->get_pgood = control_power_proxy_get_pgood;
  iface->get_state = control_power_proxy_get_state;
  iface->get_pgood_timeout = control_power_proxy_get_pgood_timeout;
}

/**
 * control_power_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Power.top_of_page">org.openbmc.control.Power</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_power_proxy_new_finish() to get the result of the operation.
 *
 * See control_power_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
control_power_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_CONTROL_POWER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Power", NULL);
}

/**
 * control_power_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_power_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with control_power_proxy_new().
 *
 * Returns: (transfer full) (type ControlPowerProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlPower *
control_power_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return CONTROL_POWER (ret);
  else
    return NULL;
}

/**
 * control_power_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Power.top_of_page">org.openbmc.control.Power</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See control_power_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ControlPowerProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlPower *
control_power_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_CONTROL_POWER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Power", NULL);
  if (ret != NULL)
    return CONTROL_POWER (ret);
  else
    return NULL;
}


/**
 * control_power_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like control_power_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_power_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See control_power_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
control_power_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_CONTROL_POWER_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Power", NULL);
}

/**
 * control_power_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_power_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with control_power_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type ControlPowerProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlPower *
control_power_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return CONTROL_POWER (ret);
  else
    return NULL;
}

/**
 * control_power_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like control_power_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See control_power_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ControlPowerProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlPower *
control_power_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_CONTROL_POWER_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Power", NULL);
  if (ret != NULL)
    return CONTROL_POWER (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * ControlPowerSkeleton:
 *
 * The #ControlPowerSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ControlPowerSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ControlPowerSkeleton.
 */

struct _ControlPowerSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_control_power_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_CONTROL_POWER);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTROL_POWER);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_control_power_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_power_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_control_power_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_power_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _control_power_skeleton_vtable =
{
  _control_power_skeleton_handle_method_call,
  _control_power_skeleton_handle_get_property,
  _control_power_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
control_power_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return control_power_interface_info ();
}

static GDBusInterfaceVTable *
control_power_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_control_power_skeleton_vtable;
}

static GVariant *
control_power_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_control_power_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _control_power_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _control_power_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _control_power_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.control.Power", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _control_power_emit_changed (gpointer user_data);

static void
control_power_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _control_power_emit_changed (skeleton);
}

static void
_control_power_on_signal_power_good (
    ControlPower *object)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.control.Power", "PowerGood",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_control_power_on_signal_power_lost (
    ControlPower *object)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.control.Power", "PowerLost",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void control_power_skeleton_iface_init (ControlPowerIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ControlPowerSkeleton, control_power_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (ControlPowerSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_POWER, control_power_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ControlPowerSkeleton, control_power_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_POWER, control_power_skeleton_iface_init));

#endif
static void
control_power_skeleton_finalize (GObject *object)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (object);
  guint n;
  for (n = 0; n < 3; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (control_power_skeleton_parent_class)->finalize (object);
}

static void
control_power_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_control_power_emit_changed (gpointer user_data)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.control.Power",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_control_power_schedule_emit_changed (ControlPowerSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
control_power_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _control_power_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _control_power_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
control_power_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _control_power_schedule_emit_changed (skeleton, _control_power_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
control_power_skeleton_init (ControlPowerSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = control_power_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_CONTROL_POWER_SKELETON, ControlPowerSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 3);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_INT);
}

static gint 
control_power_skeleton_get_pgood (ControlPower *object)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
control_power_skeleton_get_state (ControlPower *object)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
control_power_skeleton_get_pgood_timeout (ControlPower *object)
{
  ControlPowerSkeleton *skeleton = CONTROL_POWER_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
control_power_skeleton_class_init (ControlPowerSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = control_power_skeleton_finalize;
  gobject_class->get_property = control_power_skeleton_get_property;
  gobject_class->set_property = control_power_skeleton_set_property;
  gobject_class->notify       = control_power_skeleton_notify;


  control_power_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = control_power_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = control_power_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = control_power_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = control_power_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ControlPowerSkeletonPrivate));
#endif
}

static void
control_power_skeleton_iface_init (ControlPowerIface *iface)
{
  iface->power_good = _control_power_on_signal_power_good;
  iface->power_lost = _control_power_on_signal_power_lost;
  iface->get_pgood = control_power_skeleton_get_pgood;
  iface->get_state = control_power_skeleton_get_state;
  iface->get_pgood_timeout = control_power_skeleton_get_pgood_timeout;
}

/**
 * control_power_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Power.top_of_page">org.openbmc.control.Power</link>.
 *
 * Returns: (transfer full) (type ControlPowerSkeleton): The skeleton object.
 */
ControlPower *
control_power_skeleton_new (void)
{
  return CONTROL_POWER (g_object_new (TYPE_CONTROL_POWER_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.control.Checkstop
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:ControlCheckstop
 * @title: ControlCheckstop
 * @short_description: Generated C code for the org.openbmc.control.Checkstop D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-control-Checkstop.top_of_page">org.openbmc.control.Checkstop</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.control.Checkstop ---- */

static const _ExtendedGDBusInterfaceInfo _control_checkstop_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.control.Checkstop",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "control-checkstop",
};


/**
 * control_checkstop_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-control-Checkstop.top_of_page">org.openbmc.control.Checkstop</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
control_checkstop_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_control_checkstop_interface_info.parent_struct;
}

/**
 * control_checkstop_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #ControlCheckstop interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
control_checkstop_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * ControlCheckstop:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Checkstop.top_of_page">org.openbmc.control.Checkstop</link>.
 */

/**
 * ControlCheckstopIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Checkstop.top_of_page">org.openbmc.control.Checkstop</link>.
 */

typedef ControlCheckstopIface ControlCheckstopInterface;
G_DEFINE_INTERFACE (ControlCheckstop, control_checkstop, G_TYPE_OBJECT);

static void
control_checkstop_default_init (ControlCheckstopIface *iface)
{
}

/* ------------------------------------------------------------------------ */

/**
 * ControlCheckstopProxy:
 *
 * The #ControlCheckstopProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ControlCheckstopProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ControlCheckstopProxy.
 */

struct _ControlCheckstopProxyPrivate
{
  GData *qdata;
};

static void control_checkstop_proxy_iface_init (ControlCheckstopIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ControlCheckstopProxy, control_checkstop_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (ControlCheckstopProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_CHECKSTOP, control_checkstop_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ControlCheckstopProxy, control_checkstop_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_CHECKSTOP, control_checkstop_proxy_iface_init));

#endif
static void
control_checkstop_proxy_finalize (GObject *object)
{
  ControlCheckstopProxy *proxy = CONTROL_CHECKSTOP_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (control_checkstop_proxy_parent_class)->finalize (object);
}

static void
control_checkstop_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
control_checkstop_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
control_checkstop_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_control_checkstop_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_CONTROL_CHECKSTOP);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTROL_CHECKSTOP);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
control_checkstop_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  ControlCheckstopProxy *proxy = CONTROL_CHECKSTOP_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_checkstop_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_checkstop_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
control_checkstop_proxy_init (ControlCheckstopProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = control_checkstop_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_CONTROL_CHECKSTOP_PROXY, ControlCheckstopProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), control_checkstop_interface_info ());
}

static void
control_checkstop_proxy_class_init (ControlCheckstopProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = control_checkstop_proxy_finalize;
  gobject_class->get_property = control_checkstop_proxy_get_property;
  gobject_class->set_property = control_checkstop_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = control_checkstop_proxy_g_signal;
  proxy_class->g_properties_changed = control_checkstop_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ControlCheckstopProxyPrivate));
#endif
}

static void
control_checkstop_proxy_iface_init (ControlCheckstopIface *iface)
{
}

/**
 * control_checkstop_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Checkstop.top_of_page">org.openbmc.control.Checkstop</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_checkstop_proxy_new_finish() to get the result of the operation.
 *
 * See control_checkstop_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
control_checkstop_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_CONTROL_CHECKSTOP_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Checkstop", NULL);
}

/**
 * control_checkstop_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_checkstop_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with control_checkstop_proxy_new().
 *
 * Returns: (transfer full) (type ControlCheckstopProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlCheckstop *
control_checkstop_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return CONTROL_CHECKSTOP (ret);
  else
    return NULL;
}

/**
 * control_checkstop_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Checkstop.top_of_page">org.openbmc.control.Checkstop</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See control_checkstop_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ControlCheckstopProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlCheckstop *
control_checkstop_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_CONTROL_CHECKSTOP_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Checkstop", NULL);
  if (ret != NULL)
    return CONTROL_CHECKSTOP (ret);
  else
    return NULL;
}


/**
 * control_checkstop_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like control_checkstop_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call control_checkstop_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See control_checkstop_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
control_checkstop_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_CONTROL_CHECKSTOP_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Checkstop", NULL);
}

/**
 * control_checkstop_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to control_checkstop_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with control_checkstop_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type ControlCheckstopProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlCheckstop *
control_checkstop_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return CONTROL_CHECKSTOP (ret);
  else
    return NULL;
}

/**
 * control_checkstop_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like control_checkstop_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See control_checkstop_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ControlCheckstopProxy): The constructed proxy object or %NULL if @error is set.
 */
ControlCheckstop *
control_checkstop_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_CONTROL_CHECKSTOP_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.control.Checkstop", NULL);
  if (ret != NULL)
    return CONTROL_CHECKSTOP (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * ControlCheckstopSkeleton:
 *
 * The #ControlCheckstopSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ControlCheckstopSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ControlCheckstopSkeleton.
 */

struct _ControlCheckstopSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_control_checkstop_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  ControlCheckstopSkeleton *skeleton = CONTROL_CHECKSTOP_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_CONTROL_CHECKSTOP);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTROL_CHECKSTOP);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_control_checkstop_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  ControlCheckstopSkeleton *skeleton = CONTROL_CHECKSTOP_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_checkstop_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_control_checkstop_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  ControlCheckstopSkeleton *skeleton = CONTROL_CHECKSTOP_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_control_checkstop_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _control_checkstop_skeleton_vtable =
{
  _control_checkstop_skeleton_handle_method_call,
  _control_checkstop_skeleton_handle_get_property,
  _control_checkstop_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
control_checkstop_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return control_checkstop_interface_info ();
}

static GDBusInterfaceVTable *
control_checkstop_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_control_checkstop_skeleton_vtable;
}

static GVariant *
control_checkstop_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  ControlCheckstopSkeleton *skeleton = CONTROL_CHECKSTOP_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_control_checkstop_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _control_checkstop_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _control_checkstop_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _control_checkstop_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.control.Checkstop", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
control_checkstop_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void control_checkstop_skeleton_iface_init (ControlCheckstopIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ControlCheckstopSkeleton, control_checkstop_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (ControlCheckstopSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_CHECKSTOP, control_checkstop_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ControlCheckstopSkeleton, control_checkstop_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_CONTROL_CHECKSTOP, control_checkstop_skeleton_iface_init));

#endif
static void
control_checkstop_skeleton_finalize (GObject *object)
{
  ControlCheckstopSkeleton *skeleton = CONTROL_CHECKSTOP_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (control_checkstop_skeleton_parent_class)->finalize (object);
}

static void
control_checkstop_skeleton_init (ControlCheckstopSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = control_checkstop_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_CONTROL_CHECKSTOP_SKELETON, ControlCheckstopSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
control_checkstop_skeleton_class_init (ControlCheckstopSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = control_checkstop_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = control_checkstop_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = control_checkstop_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = control_checkstop_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = control_checkstop_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ControlCheckstopSkeletonPrivate));
#endif
}

static void
control_checkstop_skeleton_iface_init (ControlCheckstopIface *iface)
{
}

/**
 * control_checkstop_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Checkstop.top_of_page">org.openbmc.control.Checkstop</link>.
 *
 * Returns: (transfer full) (type ControlCheckstopSkeleton): The skeleton object.
 */
ControlCheckstop *
control_checkstop_skeleton_new (void)
{
  return CONTROL_CHECKSTOP (g_object_new (TYPE_CONTROL_CHECKSTOP_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.Watchdog
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:Watchdog
 * @title: Watchdog
 * @short_description: Generated C code for the org.openbmc.Watchdog D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-Watchdog.top_of_page">org.openbmc.Watchdog</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.Watchdog ---- */

static const _ExtendedGDBusMethodInfo _watchdog_method_info_start =
{
  {
    -1,
    (gchar *) "start",
    NULL,
    NULL,
    NULL
  },
  "handle-start",
  FALSE
};

static const _ExtendedGDBusMethodInfo _watchdog_method_info_poke =
{
  {
    -1,
    (gchar *) "poke",
    NULL,
    NULL,
    NULL
  },
  "handle-poke",
  FALSE
};

static const _ExtendedGDBusMethodInfo _watchdog_method_info_stop =
{
  {
    -1,
    (gchar *) "stop",
    NULL,
    NULL,
    NULL
  },
  "handle-stop",
  FALSE
};

static const _ExtendedGDBusArgInfo _watchdog_method_info_set_IN_ARG_interval =
{
  {
    -1,
    (gchar *) "interval",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _watchdog_method_info_set_IN_ARG_pointers[] =
{
  &_watchdog_method_info_set_IN_ARG_interval,
  NULL
};

static const _ExtendedGDBusMethodInfo _watchdog_method_info_set =
{
  {
    -1,
    (gchar *) "set",
    (GDBusArgInfo **) &_watchdog_method_info_set_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _watchdog_method_info_pointers[] =
{
  &_watchdog_method_info_start,
  &_watchdog_method_info_poke,
  &_watchdog_method_info_stop,
  &_watchdog_method_info_set,
  NULL
};

static const _ExtendedGDBusSignalInfo _watchdog_signal_info_watchdog_error =
{
  {
    -1,
    (gchar *) "WatchdogError",
    NULL,
    NULL
  },
  "watchdog-error"
};

static const _ExtendedGDBusSignalInfo * const _watchdog_signal_info_pointers[] =
{
  &_watchdog_signal_info_watchdog_error,
  NULL
};

static const _ExtendedGDBusPropertyInfo _watchdog_property_info_watchdog =
{
  {
    -1,
    (gchar *) "watchdog",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "watchdog",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _watchdog_property_info_poll_interval =
{
  {
    -1,
    (gchar *) "poll_interval",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "poll-interval",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _watchdog_property_info_pointers[] =
{
  &_watchdog_property_info_watchdog,
  &_watchdog_property_info_poll_interval,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _watchdog_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.Watchdog",
    (GDBusMethodInfo **) &_watchdog_method_info_pointers,
    (GDBusSignalInfo **) &_watchdog_signal_info_pointers,
    (GDBusPropertyInfo **) &_watchdog_property_info_pointers,
    NULL
  },
  "watchdog",
};


/**
 * watchdog_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-Watchdog.top_of_page">org.openbmc.Watchdog</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
watchdog_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_watchdog_interface_info.parent_struct;
}

/**
 * watchdog_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #Watchdog interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
watchdog_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "watchdog");
  g_object_class_override_property (klass, property_id_begin++, "poll-interval");
  return property_id_begin - 1;
}



/**
 * Watchdog:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Watchdog.top_of_page">org.openbmc.Watchdog</link>.
 */

/**
 * WatchdogIface:
 * @parent_iface: The parent interface.
 * @handle_poke: Handler for the #Watchdog::handle-poke signal.
 * @handle_set: Handler for the #Watchdog::handle-set signal.
 * @handle_start: Handler for the #Watchdog::handle-start signal.
 * @handle_stop: Handler for the #Watchdog::handle-stop signal.
 * @get_poll_interval: Getter for the #Watchdog:poll-interval property.
 * @get_watchdog: Getter for the #Watchdog:watchdog property.
 * @watchdog_error: Handler for the #Watchdog::watchdog-error signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Watchdog.top_of_page">org.openbmc.Watchdog</link>.
 */

typedef WatchdogIface WatchdogInterface;
G_DEFINE_INTERFACE (Watchdog, watchdog, G_TYPE_OBJECT);

static void
watchdog_default_init (WatchdogIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * Watchdog::handle-start:
   * @object: A #Watchdog.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Watchdog.start">start()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call watchdog_complete_start() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-start",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (WatchdogIface, handle_start),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * Watchdog::handle-poke:
   * @object: A #Watchdog.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Watchdog.poke">poke()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call watchdog_complete_poke() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-poke",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (WatchdogIface, handle_poke),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * Watchdog::handle-stop:
   * @object: A #Watchdog.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Watchdog.stop">stop()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call watchdog_complete_stop() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-stop",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (WatchdogIface, handle_stop),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * Watchdog::handle-set:
   * @object: A #Watchdog.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_interval: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Watchdog.set">set()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call watchdog_complete_set() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (WatchdogIface, handle_set),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);

  /* GObject signals for received D-Bus signals: */
  /**
   * Watchdog::watchdog-error:
   * @object: A #Watchdog.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-Watchdog.WatchdogError">"WatchdogError"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("watchdog-error",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (WatchdogIface, watchdog_error),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * Watchdog:watchdog:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Watchdog.watchdog">"watchdog"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("watchdog", "watchdog", "watchdog", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Watchdog:poll-interval:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Watchdog.poll_interval">"poll_interval"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("poll-interval", "poll_interval", "poll_interval", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * watchdog_get_watchdog: (skip)
 * @object: A #Watchdog.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Watchdog.watchdog">"watchdog"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
watchdog_get_watchdog (Watchdog *object)
{
  return WATCHDOG_GET_IFACE (object)->get_watchdog (object);
}

/**
 * watchdog_set_watchdog: (skip)
 * @object: A #Watchdog.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Watchdog.watchdog">"watchdog"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
watchdog_set_watchdog (Watchdog *object, gint value)
{
  g_object_set (G_OBJECT (object), "watchdog", value, NULL);
}

/**
 * watchdog_get_poll_interval: (skip)
 * @object: A #Watchdog.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Watchdog.poll_interval">"poll_interval"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
watchdog_get_poll_interval (Watchdog *object)
{
  return WATCHDOG_GET_IFACE (object)->get_poll_interval (object);
}

/**
 * watchdog_set_poll_interval: (skip)
 * @object: A #Watchdog.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Watchdog.poll_interval">"poll_interval"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
watchdog_set_poll_interval (Watchdog *object, gint value)
{
  g_object_set (G_OBJECT (object), "poll-interval", value, NULL);
}

/**
 * watchdog_emit_watchdog_error:
 * @object: A #Watchdog.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-Watchdog.WatchdogError">"WatchdogError"</link> D-Bus signal.
 */
void
watchdog_emit_watchdog_error (
    Watchdog *object)
{
  g_signal_emit_by_name (object, "watchdog-error");
}

/**
 * watchdog_call_start:
 * @proxy: A #WatchdogProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Watchdog.start">start()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call watchdog_call_start_finish() to get the result of the operation.
 *
 * See watchdog_call_start_sync() for the synchronous, blocking version of this method.
 */
void
watchdog_call_start (
    Watchdog *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "start",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * watchdog_call_start_finish:
 * @proxy: A #WatchdogProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to watchdog_call_start().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with watchdog_call_start().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
watchdog_call_start_finish (
    Watchdog *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * watchdog_call_start_sync:
 * @proxy: A #WatchdogProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Watchdog.start">start()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See watchdog_call_start() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
watchdog_call_start_sync (
    Watchdog *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "start",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * watchdog_call_poke:
 * @proxy: A #WatchdogProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Watchdog.poke">poke()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call watchdog_call_poke_finish() to get the result of the operation.
 *
 * See watchdog_call_poke_sync() for the synchronous, blocking version of this method.
 */
void
watchdog_call_poke (
    Watchdog *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "poke",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * watchdog_call_poke_finish:
 * @proxy: A #WatchdogProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to watchdog_call_poke().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with watchdog_call_poke().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
watchdog_call_poke_finish (
    Watchdog *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * watchdog_call_poke_sync:
 * @proxy: A #WatchdogProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Watchdog.poke">poke()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See watchdog_call_poke() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
watchdog_call_poke_sync (
    Watchdog *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "poke",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * watchdog_call_stop:
 * @proxy: A #WatchdogProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Watchdog.stop">stop()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call watchdog_call_stop_finish() to get the result of the operation.
 *
 * See watchdog_call_stop_sync() for the synchronous, blocking version of this method.
 */
void
watchdog_call_stop (
    Watchdog *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "stop",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * watchdog_call_stop_finish:
 * @proxy: A #WatchdogProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to watchdog_call_stop().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with watchdog_call_stop().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
watchdog_call_stop_finish (
    Watchdog *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * watchdog_call_stop_sync:
 * @proxy: A #WatchdogProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Watchdog.stop">stop()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See watchdog_call_stop() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
watchdog_call_stop_sync (
    Watchdog *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "stop",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * watchdog_call_set:
 * @proxy: A #WatchdogProxy.
 * @arg_interval: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Watchdog.set">set()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call watchdog_call_set_finish() to get the result of the operation.
 *
 * See watchdog_call_set_sync() for the synchronous, blocking version of this method.
 */
void
watchdog_call_set (
    Watchdog *proxy,
    gint arg_interval,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "set",
    g_variant_new ("(i)",
                   arg_interval),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * watchdog_call_set_finish:
 * @proxy: A #WatchdogProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to watchdog_call_set().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with watchdog_call_set().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
watchdog_call_set_finish (
    Watchdog *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * watchdog_call_set_sync:
 * @proxy: A #WatchdogProxy.
 * @arg_interval: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Watchdog.set">set()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See watchdog_call_set() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
watchdog_call_set_sync (
    Watchdog *proxy,
    gint arg_interval,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "set",
    g_variant_new ("(i)",
                   arg_interval),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * watchdog_complete_start:
 * @object: A #Watchdog.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Watchdog.start">start()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
watchdog_complete_start (
    Watchdog *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * watchdog_complete_poke:
 * @object: A #Watchdog.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Watchdog.poke">poke()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
watchdog_complete_poke (
    Watchdog *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * watchdog_complete_stop:
 * @object: A #Watchdog.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Watchdog.stop">stop()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
watchdog_complete_stop (
    Watchdog *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * watchdog_complete_set:
 * @object: A #Watchdog.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Watchdog.set">set()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
watchdog_complete_set (
    Watchdog *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * WatchdogProxy:
 *
 * The #WatchdogProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * WatchdogProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #WatchdogProxy.
 */

struct _WatchdogProxyPrivate
{
  GData *qdata;
};

static void watchdog_proxy_iface_init (WatchdogIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (WatchdogProxy, watchdog_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (WatchdogProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_WATCHDOG, watchdog_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (WatchdogProxy, watchdog_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_WATCHDOG, watchdog_proxy_iface_init));

#endif
static void
watchdog_proxy_finalize (GObject *object)
{
  WatchdogProxy *proxy = WATCHDOG_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (watchdog_proxy_parent_class)->finalize (object);
}

static void
watchdog_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _watchdog_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
watchdog_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.Watchdog: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
watchdog_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _watchdog_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.Watchdog", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) watchdog_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
watchdog_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_watchdog_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_WATCHDOG);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_WATCHDOG);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
watchdog_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  WatchdogProxy *proxy = WATCHDOG_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_watchdog_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_watchdog_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gint 
watchdog_proxy_get_watchdog (Watchdog *object)
{
  WatchdogProxy *proxy = WATCHDOG_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "watchdog");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
watchdog_proxy_get_poll_interval (Watchdog *object)
{
  WatchdogProxy *proxy = WATCHDOG_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "poll_interval");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
watchdog_proxy_init (WatchdogProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = watchdog_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_WATCHDOG_PROXY, WatchdogProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), watchdog_interface_info ());
}

static void
watchdog_proxy_class_init (WatchdogProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = watchdog_proxy_finalize;
  gobject_class->get_property = watchdog_proxy_get_property;
  gobject_class->set_property = watchdog_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = watchdog_proxy_g_signal;
  proxy_class->g_properties_changed = watchdog_proxy_g_properties_changed;

  watchdog_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (WatchdogProxyPrivate));
#endif
}

static void
watchdog_proxy_iface_init (WatchdogIface *iface)
{
  iface->get_watchdog = watchdog_proxy_get_watchdog;
  iface->get_poll_interval = watchdog_proxy_get_poll_interval;
}

/**
 * watchdog_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Watchdog.top_of_page">org.openbmc.Watchdog</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call watchdog_proxy_new_finish() to get the result of the operation.
 *
 * See watchdog_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
watchdog_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_WATCHDOG_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Watchdog", NULL);
}

/**
 * watchdog_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to watchdog_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with watchdog_proxy_new().
 *
 * Returns: (transfer full) (type WatchdogProxy): The constructed proxy object or %NULL if @error is set.
 */
Watchdog *
watchdog_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WATCHDOG (ret);
  else
    return NULL;
}

/**
 * watchdog_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Watchdog.top_of_page">org.openbmc.Watchdog</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See watchdog_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type WatchdogProxy): The constructed proxy object or %NULL if @error is set.
 */
Watchdog *
watchdog_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_WATCHDOG_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Watchdog", NULL);
  if (ret != NULL)
    return WATCHDOG (ret);
  else
    return NULL;
}


/**
 * watchdog_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like watchdog_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call watchdog_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See watchdog_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
watchdog_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_WATCHDOG_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Watchdog", NULL);
}

/**
 * watchdog_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to watchdog_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with watchdog_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type WatchdogProxy): The constructed proxy object or %NULL if @error is set.
 */
Watchdog *
watchdog_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WATCHDOG (ret);
  else
    return NULL;
}

/**
 * watchdog_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like watchdog_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See watchdog_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type WatchdogProxy): The constructed proxy object or %NULL if @error is set.
 */
Watchdog *
watchdog_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_WATCHDOG_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Watchdog", NULL);
  if (ret != NULL)
    return WATCHDOG (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * WatchdogSkeleton:
 *
 * The #WatchdogSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * WatchdogSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #WatchdogSkeleton.
 */

struct _WatchdogSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_watchdog_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_WATCHDOG);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_WATCHDOG);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_watchdog_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_watchdog_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_watchdog_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_watchdog_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _watchdog_skeleton_vtable =
{
  _watchdog_skeleton_handle_method_call,
  _watchdog_skeleton_handle_get_property,
  _watchdog_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
watchdog_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return watchdog_interface_info ();
}

static GDBusInterfaceVTable *
watchdog_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_watchdog_skeleton_vtable;
}

static GVariant *
watchdog_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_watchdog_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _watchdog_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _watchdog_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _watchdog_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Watchdog", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _watchdog_emit_changed (gpointer user_data);

static void
watchdog_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _watchdog_emit_changed (skeleton);
}

static void
_watchdog_on_signal_watchdog_error (
    Watchdog *object)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Watchdog", "WatchdogError",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void watchdog_skeleton_iface_init (WatchdogIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (WatchdogSkeleton, watchdog_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (WatchdogSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_WATCHDOG, watchdog_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (WatchdogSkeleton, watchdog_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_WATCHDOG, watchdog_skeleton_iface_init));

#endif
static void
watchdog_skeleton_finalize (GObject *object)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (watchdog_skeleton_parent_class)->finalize (object);
}

static void
watchdog_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_watchdog_emit_changed (gpointer user_data)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.Watchdog",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_watchdog_schedule_emit_changed (WatchdogSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
watchdog_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _watchdog_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _watchdog_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
watchdog_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _watchdog_schedule_emit_changed (skeleton, _watchdog_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
watchdog_skeleton_init (WatchdogSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = watchdog_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_WATCHDOG_SKELETON, WatchdogSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_INT);
}

static gint 
watchdog_skeleton_get_watchdog (Watchdog *object)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
watchdog_skeleton_get_poll_interval (Watchdog *object)
{
  WatchdogSkeleton *skeleton = WATCHDOG_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
watchdog_skeleton_class_init (WatchdogSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = watchdog_skeleton_finalize;
  gobject_class->get_property = watchdog_skeleton_get_property;
  gobject_class->set_property = watchdog_skeleton_set_property;
  gobject_class->notify       = watchdog_skeleton_notify;


  watchdog_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = watchdog_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = watchdog_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = watchdog_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = watchdog_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (WatchdogSkeletonPrivate));
#endif
}

static void
watchdog_skeleton_iface_init (WatchdogIface *iface)
{
  iface->watchdog_error = _watchdog_on_signal_watchdog_error;
  iface->get_watchdog = watchdog_skeleton_get_watchdog;
  iface->get_poll_interval = watchdog_skeleton_get_poll_interval;
}

/**
 * watchdog_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Watchdog.top_of_page">org.openbmc.Watchdog</link>.
 *
 * Returns: (transfer full) (type WatchdogSkeleton): The skeleton object.
 */
Watchdog *
watchdog_skeleton_new (void)
{
  return WATCHDOG (g_object_new (TYPE_WATCHDOG_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.EventLog
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:EventLog
 * @title: EventLog
 * @short_description: Generated C code for the org.openbmc.EventLog D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-EventLog.top_of_page">org.openbmc.EventLog</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.EventLog ---- */

static const _ExtendedGDBusArgInfo _event_log_method_info_get_event_log_OUT_ARG_log =
{
  {
    -1,
    (gchar *) "log",
    (gchar *) "a(s)",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _event_log_method_info_get_event_log_OUT_ARG_pointers[] =
{
  &_event_log_method_info_get_event_log_OUT_ARG_log,
  NULL
};

static const _ExtendedGDBusMethodInfo _event_log_method_info_get_event_log =
{
  {
    -1,
    (gchar *) "getEventLog",
    NULL,
    (GDBusArgInfo **) &_event_log_method_info_get_event_log_OUT_ARG_pointers,
    NULL
  },
  "handle-get-event-log",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _event_log_method_info_pointers[] =
{
  &_event_log_method_info_get_event_log,
  NULL
};

static const _ExtendedGDBusArgInfo _event_log_signal_info_event_log_ARG_priority =
{
  {
    -1,
    (gchar *) "priority",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _event_log_signal_info_event_log_ARG_message =
{
  {
    -1,
    (gchar *) "message",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _event_log_signal_info_event_log_ARG_rc =
{
  {
    -1,
    (gchar *) "rc",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _event_log_signal_info_event_log_ARG_pointers[] =
{
  &_event_log_signal_info_event_log_ARG_priority,
  &_event_log_signal_info_event_log_ARG_message,
  &_event_log_signal_info_event_log_ARG_rc,
  NULL
};

static const _ExtendedGDBusSignalInfo _event_log_signal_info_event_log =
{
  {
    -1,
    (gchar *) "EventLog",
    (GDBusArgInfo **) &_event_log_signal_info_event_log_ARG_pointers,
    NULL
  },
  "event-log"
};

static const _ExtendedGDBusSignalInfo * const _event_log_signal_info_pointers[] =
{
  &_event_log_signal_info_event_log,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _event_log_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.EventLog",
    (GDBusMethodInfo **) &_event_log_method_info_pointers,
    (GDBusSignalInfo **) &_event_log_signal_info_pointers,
    NULL,
    NULL
  },
  "event-log",
};


/**
 * event_log_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-EventLog.top_of_page">org.openbmc.EventLog</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
event_log_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_event_log_interface_info.parent_struct;
}

/**
 * event_log_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #EventLog interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
event_log_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * EventLog:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-EventLog.top_of_page">org.openbmc.EventLog</link>.
 */

/**
 * EventLogIface:
 * @parent_iface: The parent interface.
 * @handle_get_event_log: Handler for the #EventLog::handle-get-event-log signal.
 * @event_log: Handler for the #EventLog::event-log signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-EventLog.top_of_page">org.openbmc.EventLog</link>.
 */

typedef EventLogIface EventLogInterface;
G_DEFINE_INTERFACE (EventLog, event_log, G_TYPE_OBJECT);

static void
event_log_default_init (EventLogIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * EventLog::handle-get-event-log:
   * @object: A #EventLog.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-EventLog.getEventLog">getEventLog()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call event_log_complete_get_event_log() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-event-log",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EventLogIface, handle_get_event_log),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * EventLog::event-log:
   * @object: A #EventLog.
   * @arg_priority: Argument.
   * @arg_message: Argument.
   * @arg_rc: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-EventLog.EventLog">"EventLog"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("event-log",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (EventLogIface, event_log),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    3, G_TYPE_INT, G_TYPE_STRING, G_TYPE_INT);

}

/**
 * event_log_emit_event_log:
 * @object: A #EventLog.
 * @arg_priority: Argument to pass with the signal.
 * @arg_message: Argument to pass with the signal.
 * @arg_rc: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-EventLog.EventLog">"EventLog"</link> D-Bus signal.
 */
void
event_log_emit_event_log (
    EventLog *object,
    gint arg_priority,
    const gchar *arg_message,
    gint arg_rc)
{
  g_signal_emit_by_name (object, "event-log", arg_priority, arg_message, arg_rc);
}

/**
 * event_log_call_get_event_log:
 * @proxy: A #EventLogProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-EventLog.getEventLog">getEventLog()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call event_log_call_get_event_log_finish() to get the result of the operation.
 *
 * See event_log_call_get_event_log_sync() for the synchronous, blocking version of this method.
 */
void
event_log_call_get_event_log (
    EventLog *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "getEventLog",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * event_log_call_get_event_log_finish:
 * @proxy: A #EventLogProxy.
 * @out_log: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to event_log_call_get_event_log().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with event_log_call_get_event_log().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
event_log_call_get_event_log_finish (
    EventLog *proxy,
    GVariant **out_log,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@a(s))",
                 out_log);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * event_log_call_get_event_log_sync:
 * @proxy: A #EventLogProxy.
 * @out_log: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-EventLog.getEventLog">getEventLog()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See event_log_call_get_event_log() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
event_log_call_get_event_log_sync (
    EventLog *proxy,
    GVariant **out_log,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "getEventLog",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@a(s))",
                 out_log);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * event_log_complete_get_event_log:
 * @object: A #EventLog.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @log: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-EventLog.getEventLog">getEventLog()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
event_log_complete_get_event_log (
    EventLog *object,
    GDBusMethodInvocation *invocation,
    GVariant *log)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@a(s))",
                   log));
}

/* ------------------------------------------------------------------------ */

/**
 * EventLogProxy:
 *
 * The #EventLogProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * EventLogProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #EventLogProxy.
 */

struct _EventLogProxyPrivate
{
  GData *qdata;
};

static void event_log_proxy_iface_init (EventLogIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (EventLogProxy, event_log_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (EventLogProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_EVENT_LOG, event_log_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (EventLogProxy, event_log_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_EVENT_LOG, event_log_proxy_iface_init));

#endif
static void
event_log_proxy_finalize (GObject *object)
{
  EventLogProxy *proxy = EVENT_LOG_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (event_log_proxy_parent_class)->finalize (object);
}

static void
event_log_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
event_log_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
event_log_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_event_log_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_EVENT_LOG);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_EVENT_LOG);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
event_log_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  EventLogProxy *proxy = EVENT_LOG_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_event_log_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_event_log_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
event_log_proxy_init (EventLogProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = event_log_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_EVENT_LOG_PROXY, EventLogProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), event_log_interface_info ());
}

static void
event_log_proxy_class_init (EventLogProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = event_log_proxy_finalize;
  gobject_class->get_property = event_log_proxy_get_property;
  gobject_class->set_property = event_log_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = event_log_proxy_g_signal;
  proxy_class->g_properties_changed = event_log_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (EventLogProxyPrivate));
#endif
}

static void
event_log_proxy_iface_init (EventLogIface *iface)
{
}

/**
 * event_log_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-EventLog.top_of_page">org.openbmc.EventLog</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call event_log_proxy_new_finish() to get the result of the operation.
 *
 * See event_log_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
event_log_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_EVENT_LOG_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.EventLog", NULL);
}

/**
 * event_log_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to event_log_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with event_log_proxy_new().
 *
 * Returns: (transfer full) (type EventLogProxy): The constructed proxy object or %NULL if @error is set.
 */
EventLog *
event_log_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return EVENT_LOG (ret);
  else
    return NULL;
}

/**
 * event_log_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-EventLog.top_of_page">org.openbmc.EventLog</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See event_log_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type EventLogProxy): The constructed proxy object or %NULL if @error is set.
 */
EventLog *
event_log_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_EVENT_LOG_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.EventLog", NULL);
  if (ret != NULL)
    return EVENT_LOG (ret);
  else
    return NULL;
}


/**
 * event_log_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like event_log_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call event_log_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See event_log_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
event_log_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_EVENT_LOG_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.EventLog", NULL);
}

/**
 * event_log_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to event_log_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with event_log_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type EventLogProxy): The constructed proxy object or %NULL if @error is set.
 */
EventLog *
event_log_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return EVENT_LOG (ret);
  else
    return NULL;
}

/**
 * event_log_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like event_log_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See event_log_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type EventLogProxy): The constructed proxy object or %NULL if @error is set.
 */
EventLog *
event_log_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_EVENT_LOG_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.EventLog", NULL);
  if (ret != NULL)
    return EVENT_LOG (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * EventLogSkeleton:
 *
 * The #EventLogSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * EventLogSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #EventLogSkeleton.
 */

struct _EventLogSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_event_log_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  EventLogSkeleton *skeleton = EVENT_LOG_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_EVENT_LOG);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_EVENT_LOG);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_event_log_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  EventLogSkeleton *skeleton = EVENT_LOG_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_event_log_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_event_log_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  EventLogSkeleton *skeleton = EVENT_LOG_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_event_log_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _event_log_skeleton_vtable =
{
  _event_log_skeleton_handle_method_call,
  _event_log_skeleton_handle_get_property,
  _event_log_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
event_log_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return event_log_interface_info ();
}

static GDBusInterfaceVTable *
event_log_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_event_log_skeleton_vtable;
}

static GVariant *
event_log_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  EventLogSkeleton *skeleton = EVENT_LOG_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_event_log_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _event_log_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _event_log_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _event_log_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.EventLog", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
event_log_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
_event_log_on_signal_event_log (
    EventLog *object,
    gint arg_priority,
    const gchar *arg_message,
    gint arg_rc)
{
  EventLogSkeleton *skeleton = EVENT_LOG_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(isi)",
                   arg_priority,
                   arg_message,
                   arg_rc));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.EventLog", "EventLog",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void event_log_skeleton_iface_init (EventLogIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (EventLogSkeleton, event_log_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (EventLogSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_EVENT_LOG, event_log_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (EventLogSkeleton, event_log_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_EVENT_LOG, event_log_skeleton_iface_init));

#endif
static void
event_log_skeleton_finalize (GObject *object)
{
  EventLogSkeleton *skeleton = EVENT_LOG_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (event_log_skeleton_parent_class)->finalize (object);
}

static void
event_log_skeleton_init (EventLogSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = event_log_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_EVENT_LOG_SKELETON, EventLogSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
event_log_skeleton_class_init (EventLogSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = event_log_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = event_log_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = event_log_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = event_log_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = event_log_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (EventLogSkeletonPrivate));
#endif
}

static void
event_log_skeleton_iface_init (EventLogIface *iface)
{
  iface->event_log = _event_log_on_signal_event_log;
}

/**
 * event_log_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-EventLog.top_of_page">org.openbmc.EventLog</link>.
 *
 * Returns: (transfer full) (type EventLogSkeleton): The skeleton object.
 */
EventLog *
event_log_skeleton_new (void)
{
  return EVENT_LOG (g_object_new (TYPE_EVENT_LOG_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.Flash
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:Flash
 * @title: Flash
 * @short_description: Generated C code for the org.openbmc.Flash D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-Flash.top_of_page">org.openbmc.Flash</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.Flash ---- */

static const _ExtendedGDBusArgInfo _flash_method_info_update_IN_ARG_filename =
{
  {
    -1,
    (gchar *) "filename",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _flash_method_info_update_IN_ARG_pointers[] =
{
  &_flash_method_info_update_IN_ARG_filename,
  NULL
};

static const _ExtendedGDBusMethodInfo _flash_method_info_update =
{
  {
    -1,
    (gchar *) "update",
    (GDBusArgInfo **) &_flash_method_info_update_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-update",
  FALSE
};

static const _ExtendedGDBusArgInfo _flash_method_info_error_IN_ARG_message =
{
  {
    -1,
    (gchar *) "message",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _flash_method_info_error_IN_ARG_pointers[] =
{
  &_flash_method_info_error_IN_ARG_message,
  NULL
};

static const _ExtendedGDBusMethodInfo _flash_method_info_error =
{
  {
    -1,
    (gchar *) "error",
    (GDBusArgInfo **) &_flash_method_info_error_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-error",
  FALSE
};

static const _ExtendedGDBusMethodInfo _flash_method_info_done =
{
  {
    -1,
    (gchar *) "done",
    NULL,
    NULL,
    NULL
  },
  "handle-done",
  FALSE
};

static const _ExtendedGDBusArgInfo _flash_method_info_update_via_tftp_IN_ARG_url =
{
  {
    -1,
    (gchar *) "url",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _flash_method_info_update_via_tftp_IN_ARG_filename =
{
  {
    -1,
    (gchar *) "filename",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _flash_method_info_update_via_tftp_IN_ARG_pointers[] =
{
  &_flash_method_info_update_via_tftp_IN_ARG_url,
  &_flash_method_info_update_via_tftp_IN_ARG_filename,
  NULL
};

static const _ExtendedGDBusMethodInfo _flash_method_info_update_via_tftp =
{
  {
    -1,
    (gchar *) "updateViaTftp",
    (GDBusArgInfo **) &_flash_method_info_update_via_tftp_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-update-via-tftp",
  FALSE
};

static const _ExtendedGDBusMethodInfo _flash_method_info_init =
{
  {
    -1,
    (gchar *) "init",
    NULL,
    NULL,
    NULL
  },
  "handle-init",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _flash_method_info_pointers[] =
{
  &_flash_method_info_update,
  &_flash_method_info_error,
  &_flash_method_info_done,
  &_flash_method_info_update_via_tftp,
  &_flash_method_info_init,
  NULL
};

static const _ExtendedGDBusSignalInfo _flash_signal_info_updated =
{
  {
    -1,
    (gchar *) "Updated",
    NULL,
    NULL
  },
  "updated"
};

static const _ExtendedGDBusArgInfo _flash_signal_info_download_ARG_url =
{
  {
    -1,
    (gchar *) "url",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _flash_signal_info_download_ARG_filename =
{
  {
    -1,
    (gchar *) "filename",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _flash_signal_info_download_ARG_pointers[] =
{
  &_flash_signal_info_download_ARG_url,
  &_flash_signal_info_download_ARG_filename,
  NULL
};

static const _ExtendedGDBusSignalInfo _flash_signal_info_download =
{
  {
    -1,
    (gchar *) "Download",
    (GDBusArgInfo **) &_flash_signal_info_download_ARG_pointers,
    NULL
  },
  "download"
};

static const _ExtendedGDBusSignalInfo * const _flash_signal_info_pointers[] =
{
  &_flash_signal_info_updated,
  &_flash_signal_info_download,
  NULL
};

static const _ExtendedGDBusPropertyInfo _flash_property_info_filename =
{
  {
    -1,
    (gchar *) "filename",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "filename",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _flash_property_info_flasher_path =
{
  {
    -1,
    (gchar *) "flasher_path",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "flasher-path",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _flash_property_info_flasher_name =
{
  {
    -1,
    (gchar *) "flasher_name",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "flasher-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _flash_property_info_flasher_instance =
{
  {
    -1,
    (gchar *) "flasher_instance",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "flasher-instance",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _flash_property_info_status =
{
  {
    -1,
    (gchar *) "status",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "status",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _flash_property_info_pointers[] =
{
  &_flash_property_info_filename,
  &_flash_property_info_flasher_path,
  &_flash_property_info_flasher_name,
  &_flash_property_info_flasher_instance,
  &_flash_property_info_status,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _flash_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.Flash",
    (GDBusMethodInfo **) &_flash_method_info_pointers,
    (GDBusSignalInfo **) &_flash_signal_info_pointers,
    (GDBusPropertyInfo **) &_flash_property_info_pointers,
    NULL
  },
  "flash",
};


/**
 * flash_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-Flash.top_of_page">org.openbmc.Flash</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
flash_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_flash_interface_info.parent_struct;
}

/**
 * flash_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #Flash interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
flash_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "filename");
  g_object_class_override_property (klass, property_id_begin++, "flasher-path");
  g_object_class_override_property (klass, property_id_begin++, "flasher-name");
  g_object_class_override_property (klass, property_id_begin++, "flasher-instance");
  g_object_class_override_property (klass, property_id_begin++, "status");
  return property_id_begin - 1;
}



/**
 * Flash:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Flash.top_of_page">org.openbmc.Flash</link>.
 */

/**
 * FlashIface:
 * @parent_iface: The parent interface.
 * @handle_done: Handler for the #Flash::handle-done signal.
 * @handle_error: Handler for the #Flash::handle-error signal.
 * @handle_init: Handler for the #Flash::handle-init signal.
 * @handle_update: Handler for the #Flash::handle-update signal.
 * @handle_update_via_tftp: Handler for the #Flash::handle-update-via-tftp signal.
 * @get_filename: Getter for the #Flash:filename property.
 * @get_flasher_instance: Getter for the #Flash:flasher-instance property.
 * @get_flasher_name: Getter for the #Flash:flasher-name property.
 * @get_flasher_path: Getter for the #Flash:flasher-path property.
 * @get_status: Getter for the #Flash:status property.
 * @download: Handler for the #Flash::download signal.
 * @updated: Handler for the #Flash::updated signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Flash.top_of_page">org.openbmc.Flash</link>.
 */

typedef FlashIface FlashInterface;
G_DEFINE_INTERFACE (Flash, flash, G_TYPE_OBJECT);

static void
flash_default_init (FlashIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * Flash::handle-update:
   * @object: A #Flash.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_filename: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Flash.update">update()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call flash_complete_update() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-update",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashIface, handle_update),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * Flash::handle-error:
   * @object: A #Flash.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_message: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Flash.error">error()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call flash_complete_error() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-error",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashIface, handle_error),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * Flash::handle-done:
   * @object: A #Flash.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Flash.done">done()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call flash_complete_done() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-done",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashIface, handle_done),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * Flash::handle-update-via-tftp:
   * @object: A #Flash.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_url: Argument passed by remote caller.
   * @arg_filename: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Flash.updateViaTftp">updateViaTftp()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call flash_complete_update_via_tftp() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-update-via-tftp",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashIface, handle_update_via_tftp),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * Flash::handle-init:
   * @object: A #Flash.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Flash.init">init()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call flash_complete_init() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-init",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashIface, handle_init),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * Flash::updated:
   * @object: A #Flash.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-Flash.Updated">"Updated"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("updated",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashIface, updated),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * Flash::download:
   * @object: A #Flash.
   * @arg_url: Argument.
   * @arg_filename: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-Flash.Download">"Download"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("download",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashIface, download),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_STRING);

  /* GObject properties for D-Bus properties: */
  /**
   * Flash:filename:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Flash.filename">"filename"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("filename", "filename", "filename", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Flash:flasher-path:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Flash.flasher_path">"flasher_path"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("flasher-path", "flasher_path", "flasher_path", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Flash:flasher-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Flash.flasher_name">"flasher_name"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("flasher-name", "flasher_name", "flasher_name", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Flash:flasher-instance:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Flash.flasher_instance">"flasher_instance"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("flasher-instance", "flasher_instance", "flasher_instance", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Flash:status:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Flash.status">"status"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("status", "status", "status", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * flash_get_filename: (skip)
 * @object: A #Flash.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Flash.filename">"filename"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use flash_dup_filename() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
flash_get_filename (Flash *object)
{
  return FLASH_GET_IFACE (object)->get_filename (object);
}

/**
 * flash_dup_filename: (skip)
 * @object: A #Flash.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-Flash.filename">"filename"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
flash_dup_filename (Flash *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "filename", &value, NULL);
  return value;
}

/**
 * flash_set_filename: (skip)
 * @object: A #Flash.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Flash.filename">"filename"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
flash_set_filename (Flash *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "filename", value, NULL);
}

/**
 * flash_get_flasher_path: (skip)
 * @object: A #Flash.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Flash.flasher_path">"flasher_path"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use flash_dup_flasher_path() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
flash_get_flasher_path (Flash *object)
{
  return FLASH_GET_IFACE (object)->get_flasher_path (object);
}

/**
 * flash_dup_flasher_path: (skip)
 * @object: A #Flash.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-Flash.flasher_path">"flasher_path"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
flash_dup_flasher_path (Flash *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "flasher-path", &value, NULL);
  return value;
}

/**
 * flash_set_flasher_path: (skip)
 * @object: A #Flash.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Flash.flasher_path">"flasher_path"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
flash_set_flasher_path (Flash *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "flasher-path", value, NULL);
}

/**
 * flash_get_flasher_name: (skip)
 * @object: A #Flash.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Flash.flasher_name">"flasher_name"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use flash_dup_flasher_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
flash_get_flasher_name (Flash *object)
{
  return FLASH_GET_IFACE (object)->get_flasher_name (object);
}

/**
 * flash_dup_flasher_name: (skip)
 * @object: A #Flash.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-Flash.flasher_name">"flasher_name"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
flash_dup_flasher_name (Flash *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "flasher-name", &value, NULL);
  return value;
}

/**
 * flash_set_flasher_name: (skip)
 * @object: A #Flash.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Flash.flasher_name">"flasher_name"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
flash_set_flasher_name (Flash *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "flasher-name", value, NULL);
}

/**
 * flash_get_flasher_instance: (skip)
 * @object: A #Flash.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Flash.flasher_instance">"flasher_instance"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use flash_dup_flasher_instance() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
flash_get_flasher_instance (Flash *object)
{
  return FLASH_GET_IFACE (object)->get_flasher_instance (object);
}

/**
 * flash_dup_flasher_instance: (skip)
 * @object: A #Flash.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-Flash.flasher_instance">"flasher_instance"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
flash_dup_flasher_instance (Flash *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "flasher-instance", &value, NULL);
  return value;
}

/**
 * flash_set_flasher_instance: (skip)
 * @object: A #Flash.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Flash.flasher_instance">"flasher_instance"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
flash_set_flasher_instance (Flash *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "flasher-instance", value, NULL);
}

/**
 * flash_get_status: (skip)
 * @object: A #Flash.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Flash.status">"status"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use flash_dup_status() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
flash_get_status (Flash *object)
{
  return FLASH_GET_IFACE (object)->get_status (object);
}

/**
 * flash_dup_status: (skip)
 * @object: A #Flash.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-Flash.status">"status"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
flash_dup_status (Flash *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "status", &value, NULL);
  return value;
}

/**
 * flash_set_status: (skip)
 * @object: A #Flash.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Flash.status">"status"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
flash_set_status (Flash *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "status", value, NULL);
}

/**
 * flash_emit_updated:
 * @object: A #Flash.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-Flash.Updated">"Updated"</link> D-Bus signal.
 */
void
flash_emit_updated (
    Flash *object)
{
  g_signal_emit_by_name (object, "updated");
}

/**
 * flash_emit_download:
 * @object: A #Flash.
 * @arg_url: Argument to pass with the signal.
 * @arg_filename: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-Flash.Download">"Download"</link> D-Bus signal.
 */
void
flash_emit_download (
    Flash *object,
    const gchar *arg_url,
    const gchar *arg_filename)
{
  g_signal_emit_by_name (object, "download", arg_url, arg_filename);
}

/**
 * flash_call_update:
 * @proxy: A #FlashProxy.
 * @arg_filename: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Flash.update">update()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call flash_call_update_finish() to get the result of the operation.
 *
 * See flash_call_update_sync() for the synchronous, blocking version of this method.
 */
void
flash_call_update (
    Flash *proxy,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "update",
    g_variant_new ("(s)",
                   arg_filename),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * flash_call_update_finish:
 * @proxy: A #FlashProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to flash_call_update().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with flash_call_update().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_call_update_finish (
    Flash *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_call_update_sync:
 * @proxy: A #FlashProxy.
 * @arg_filename: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Flash.update">update()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See flash_call_update() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_call_update_sync (
    Flash *proxy,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "update",
    g_variant_new ("(s)",
                   arg_filename),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_call_error:
 * @proxy: A #FlashProxy.
 * @arg_message: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Flash.error">error()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call flash_call_error_finish() to get the result of the operation.
 *
 * See flash_call_error_sync() for the synchronous, blocking version of this method.
 */
void
flash_call_error (
    Flash *proxy,
    const gchar *arg_message,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "error",
    g_variant_new ("(s)",
                   arg_message),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * flash_call_error_finish:
 * @proxy: A #FlashProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to flash_call_error().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with flash_call_error().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_call_error_finish (
    Flash *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_call_error_sync:
 * @proxy: A #FlashProxy.
 * @arg_message: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Flash.error">error()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See flash_call_error() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_call_error_sync (
    Flash *proxy,
    const gchar *arg_message,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "error",
    g_variant_new ("(s)",
                   arg_message),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_call_done:
 * @proxy: A #FlashProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Flash.done">done()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call flash_call_done_finish() to get the result of the operation.
 *
 * See flash_call_done_sync() for the synchronous, blocking version of this method.
 */
void
flash_call_done (
    Flash *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "done",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * flash_call_done_finish:
 * @proxy: A #FlashProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to flash_call_done().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with flash_call_done().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_call_done_finish (
    Flash *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_call_done_sync:
 * @proxy: A #FlashProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Flash.done">done()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See flash_call_done() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_call_done_sync (
    Flash *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "done",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_call_update_via_tftp:
 * @proxy: A #FlashProxy.
 * @arg_url: Argument to pass with the method invocation.
 * @arg_filename: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Flash.updateViaTftp">updateViaTftp()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call flash_call_update_via_tftp_finish() to get the result of the operation.
 *
 * See flash_call_update_via_tftp_sync() for the synchronous, blocking version of this method.
 */
void
flash_call_update_via_tftp (
    Flash *proxy,
    const gchar *arg_url,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "updateViaTftp",
    g_variant_new ("(ss)",
                   arg_url,
                   arg_filename),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * flash_call_update_via_tftp_finish:
 * @proxy: A #FlashProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to flash_call_update_via_tftp().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with flash_call_update_via_tftp().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_call_update_via_tftp_finish (
    Flash *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_call_update_via_tftp_sync:
 * @proxy: A #FlashProxy.
 * @arg_url: Argument to pass with the method invocation.
 * @arg_filename: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Flash.updateViaTftp">updateViaTftp()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See flash_call_update_via_tftp() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_call_update_via_tftp_sync (
    Flash *proxy,
    const gchar *arg_url,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "updateViaTftp",
    g_variant_new ("(ss)",
                   arg_url,
                   arg_filename),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_call_init:
 * @proxy: A #FlashProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Flash.init">init()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call flash_call_init_finish() to get the result of the operation.
 *
 * See flash_call_init_sync() for the synchronous, blocking version of this method.
 */
void
flash_call_init (
    Flash *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "init",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * flash_call_init_finish:
 * @proxy: A #FlashProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to flash_call_init().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with flash_call_init().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_call_init_finish (
    Flash *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_call_init_sync:
 * @proxy: A #FlashProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Flash.init">init()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See flash_call_init() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_call_init_sync (
    Flash *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "init",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_complete_update:
 * @object: A #Flash.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Flash.update">update()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
flash_complete_update (
    Flash *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * flash_complete_error:
 * @object: A #Flash.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Flash.error">error()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
flash_complete_error (
    Flash *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * flash_complete_done:
 * @object: A #Flash.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Flash.done">done()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
flash_complete_done (
    Flash *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * flash_complete_update_via_tftp:
 * @object: A #Flash.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Flash.updateViaTftp">updateViaTftp()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
flash_complete_update_via_tftp (
    Flash *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * flash_complete_init:
 * @object: A #Flash.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Flash.init">init()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
flash_complete_init (
    Flash *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FlashProxy:
 *
 * The #FlashProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FlashProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FlashProxy.
 */

struct _FlashProxyPrivate
{
  GData *qdata;
};

static void flash_proxy_iface_init (FlashIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FlashProxy, flash_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FlashProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_FLASH, flash_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FlashProxy, flash_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_FLASH, flash_proxy_iface_init));

#endif
static void
flash_proxy_finalize (GObject *object)
{
  FlashProxy *proxy = FLASH_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (flash_proxy_parent_class)->finalize (object);
}

static void
flash_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  info = _flash_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
flash_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.Flash: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
flash_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  info = _flash_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.Flash", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) flash_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
flash_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_flash_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_FLASH);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_FLASH);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
flash_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FlashProxy *proxy = FLASH_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_flash_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_flash_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
flash_proxy_get_filename (Flash *object)
{
  FlashProxy *proxy = FLASH_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "filename");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
flash_proxy_get_flasher_path (Flash *object)
{
  FlashProxy *proxy = FLASH_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "flasher_path");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
flash_proxy_get_flasher_name (Flash *object)
{
  FlashProxy *proxy = FLASH_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "flasher_name");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
flash_proxy_get_flasher_instance (Flash *object)
{
  FlashProxy *proxy = FLASH_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "flasher_instance");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
flash_proxy_get_status (Flash *object)
{
  FlashProxy *proxy = FLASH_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "status");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
flash_proxy_init (FlashProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = flash_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_FLASH_PROXY, FlashProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), flash_interface_info ());
}

static void
flash_proxy_class_init (FlashProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = flash_proxy_finalize;
  gobject_class->get_property = flash_proxy_get_property;
  gobject_class->set_property = flash_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = flash_proxy_g_signal;
  proxy_class->g_properties_changed = flash_proxy_g_properties_changed;

  flash_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FlashProxyPrivate));
#endif
}

static void
flash_proxy_iface_init (FlashIface *iface)
{
  iface->get_filename = flash_proxy_get_filename;
  iface->get_flasher_path = flash_proxy_get_flasher_path;
  iface->get_flasher_name = flash_proxy_get_flasher_name;
  iface->get_flasher_instance = flash_proxy_get_flasher_instance;
  iface->get_status = flash_proxy_get_status;
}

/**
 * flash_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Flash.top_of_page">org.openbmc.Flash</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call flash_proxy_new_finish() to get the result of the operation.
 *
 * See flash_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
flash_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_FLASH_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Flash", NULL);
}

/**
 * flash_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to flash_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with flash_proxy_new().
 *
 * Returns: (transfer full) (type FlashProxy): The constructed proxy object or %NULL if @error is set.
 */
Flash *
flash_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FLASH (ret);
  else
    return NULL;
}

/**
 * flash_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Flash.top_of_page">org.openbmc.Flash</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See flash_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FlashProxy): The constructed proxy object or %NULL if @error is set.
 */
Flash *
flash_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_FLASH_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Flash", NULL);
  if (ret != NULL)
    return FLASH (ret);
  else
    return NULL;
}


/**
 * flash_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like flash_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call flash_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See flash_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
flash_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_FLASH_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Flash", NULL);
}

/**
 * flash_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to flash_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with flash_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FlashProxy): The constructed proxy object or %NULL if @error is set.
 */
Flash *
flash_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FLASH (ret);
  else
    return NULL;
}

/**
 * flash_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like flash_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See flash_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FlashProxy): The constructed proxy object or %NULL if @error is set.
 */
Flash *
flash_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_FLASH_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Flash", NULL);
  if (ret != NULL)
    return FLASH (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FlashSkeleton:
 *
 * The #FlashSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FlashSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FlashSkeleton.
 */

struct _FlashSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_flash_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_FLASH);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_FLASH);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_flash_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_flash_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_flash_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_flash_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _flash_skeleton_vtable =
{
  _flash_skeleton_handle_method_call,
  _flash_skeleton_handle_get_property,
  _flash_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
flash_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return flash_interface_info ();
}

static GDBusInterfaceVTable *
flash_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_flash_skeleton_vtable;
}

static GVariant *
flash_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_flash_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _flash_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _flash_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _flash_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Flash", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _flash_emit_changed (gpointer user_data);

static void
flash_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _flash_emit_changed (skeleton);
}

static void
_flash_on_signal_updated (
    Flash *object)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Flash", "Updated",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_flash_on_signal_download (
    Flash *object,
    const gchar *arg_url,
    const gchar *arg_filename)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(ss)",
                   arg_url,
                   arg_filename));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Flash", "Download",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void flash_skeleton_iface_init (FlashIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FlashSkeleton, flash_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FlashSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_FLASH, flash_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FlashSkeleton, flash_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_FLASH, flash_skeleton_iface_init));

#endif
static void
flash_skeleton_finalize (GObject *object)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);
  guint n;
  for (n = 0; n < 5; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (flash_skeleton_parent_class)->finalize (object);
}

static void
flash_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_flash_emit_changed (gpointer user_data)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.Flash",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_flash_schedule_emit_changed (FlashSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
flash_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _flash_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _flash_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
flash_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 5);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _flash_schedule_emit_changed (skeleton, _flash_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
flash_skeleton_init (FlashSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = flash_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_FLASH_SKELETON, FlashSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 5);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_STRING);
}

static const gchar *
flash_skeleton_get_filename (Flash *object)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
flash_skeleton_get_flasher_path (Flash *object)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
flash_skeleton_get_flasher_name (Flash *object)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
flash_skeleton_get_flasher_instance (Flash *object)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
flash_skeleton_get_status (Flash *object)
{
  FlashSkeleton *skeleton = FLASH_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
flash_skeleton_class_init (FlashSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = flash_skeleton_finalize;
  gobject_class->get_property = flash_skeleton_get_property;
  gobject_class->set_property = flash_skeleton_set_property;
  gobject_class->notify       = flash_skeleton_notify;


  flash_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = flash_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = flash_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = flash_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = flash_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FlashSkeletonPrivate));
#endif
}

static void
flash_skeleton_iface_init (FlashIface *iface)
{
  iface->updated = _flash_on_signal_updated;
  iface->download = _flash_on_signal_download;
  iface->get_filename = flash_skeleton_get_filename;
  iface->get_flasher_path = flash_skeleton_get_flasher_path;
  iface->get_flasher_name = flash_skeleton_get_flasher_name;
  iface->get_flasher_instance = flash_skeleton_get_flasher_instance;
  iface->get_status = flash_skeleton_get_status;
}

/**
 * flash_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Flash.top_of_page">org.openbmc.Flash</link>.
 *
 * Returns: (transfer full) (type FlashSkeleton): The skeleton object.
 */
Flash *
flash_skeleton_new (void)
{
  return FLASH (g_object_new (TYPE_FLASH_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.FlashControl
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FlashControl
 * @title: FlashControl
 * @short_description: Generated C code for the org.openbmc.FlashControl D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-FlashControl.top_of_page">org.openbmc.FlashControl</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.FlashControl ---- */

static const _ExtendedGDBusArgInfo _flash_control_method_info_flash_IN_ARG_type =
{
  {
    -1,
    (gchar *) "type",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _flash_control_method_info_flash_IN_ARG_filename =
{
  {
    -1,
    (gchar *) "filename",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _flash_control_method_info_flash_IN_ARG_pointers[] =
{
  &_flash_control_method_info_flash_IN_ARG_type,
  &_flash_control_method_info_flash_IN_ARG_filename,
  NULL
};

static const _ExtendedGDBusMethodInfo _flash_control_method_info_flash =
{
  {
    -1,
    (gchar *) "flash",
    (GDBusArgInfo **) &_flash_control_method_info_flash_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-flash",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _flash_control_method_info_pointers[] =
{
  &_flash_control_method_info_flash,
  NULL
};

static const _ExtendedGDBusArgInfo _flash_control_signal_info_done_ARG_filename =
{
  {
    -1,
    (gchar *) "filename",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _flash_control_signal_info_done_ARG_pointers[] =
{
  &_flash_control_signal_info_done_ARG_filename,
  NULL
};

static const _ExtendedGDBusSignalInfo _flash_control_signal_info_done =
{
  {
    -1,
    (gchar *) "Done",
    (GDBusArgInfo **) &_flash_control_signal_info_done_ARG_pointers,
    NULL
  },
  "done"
};

static const _ExtendedGDBusArgInfo _flash_control_signal_info_error_ARG_filename =
{
  {
    -1,
    (gchar *) "filename",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _flash_control_signal_info_error_ARG_pointers[] =
{
  &_flash_control_signal_info_error_ARG_filename,
  NULL
};

static const _ExtendedGDBusSignalInfo _flash_control_signal_info_error =
{
  {
    -1,
    (gchar *) "Error",
    (GDBusArgInfo **) &_flash_control_signal_info_error_ARG_pointers,
    NULL
  },
  "error"
};

static const _ExtendedGDBusArgInfo _flash_control_signal_info_progress_ARG_filename =
{
  {
    -1,
    (gchar *) "filename",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _flash_control_signal_info_progress_ARG_progress =
{
  {
    -1,
    (gchar *) "progress",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _flash_control_signal_info_progress_ARG_pointers[] =
{
  &_flash_control_signal_info_progress_ARG_filename,
  &_flash_control_signal_info_progress_ARG_progress,
  NULL
};

static const _ExtendedGDBusSignalInfo _flash_control_signal_info_progress =
{
  {
    -1,
    (gchar *) "Progress",
    (GDBusArgInfo **) &_flash_control_signal_info_progress_ARG_pointers,
    NULL
  },
  "progress"
};

static const _ExtendedGDBusSignalInfo * const _flash_control_signal_info_pointers[] =
{
  &_flash_control_signal_info_done,
  &_flash_control_signal_info_error,
  &_flash_control_signal_info_progress,
  NULL
};

static const _ExtendedGDBusPropertyInfo _flash_control_property_info_filename =
{
  {
    -1,
    (gchar *) "filename",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "filename",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _flash_control_property_info_type_ =
{
  {
    -1,
    (gchar *) "type",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "type",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _flash_control_property_info_pointers[] =
{
  &_flash_control_property_info_filename,
  &_flash_control_property_info_type_,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _flash_control_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.FlashControl",
    (GDBusMethodInfo **) &_flash_control_method_info_pointers,
    (GDBusSignalInfo **) &_flash_control_signal_info_pointers,
    (GDBusPropertyInfo **) &_flash_control_property_info_pointers,
    NULL
  },
  "flash-control",
};


/**
 * flash_control_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-FlashControl.top_of_page">org.openbmc.FlashControl</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
flash_control_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_flash_control_interface_info.parent_struct;
}

/**
 * flash_control_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FlashControl interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
flash_control_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "filename");
  g_object_class_override_property (klass, property_id_begin++, "type");
  return property_id_begin - 1;
}



/**
 * FlashControl:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-FlashControl.top_of_page">org.openbmc.FlashControl</link>.
 */

/**
 * FlashControlIface:
 * @parent_iface: The parent interface.
 * @handle_flash: Handler for the #FlashControl::handle-flash signal.
 * @get_filename: Getter for the #FlashControl:filename property.
 * @get_type_: Getter for the #FlashControl:type property.
 * @done: Handler for the #FlashControl::done signal.
 * @error: Handler for the #FlashControl::error signal.
 * @progress: Handler for the #FlashControl::progress signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-FlashControl.top_of_page">org.openbmc.FlashControl</link>.
 */

typedef FlashControlIface FlashControlInterface;
G_DEFINE_INTERFACE (FlashControl, flash_control, G_TYPE_OBJECT);

static void
flash_control_default_init (FlashControlIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FlashControl::handle-flash:
   * @object: A #FlashControl.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_type: Argument passed by remote caller.
   * @arg_filename: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-FlashControl.flash">flash()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call flash_control_complete_flash() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-flash",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashControlIface, handle_flash),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /* GObject signals for received D-Bus signals: */
  /**
   * FlashControl::done:
   * @object: A #FlashControl.
   * @arg_filename: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-FlashControl.Done">"Done"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("done",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashControlIface, done),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * FlashControl::error:
   * @object: A #FlashControl.
   * @arg_filename: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-FlashControl.Error">"Error"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("error",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashControlIface, error),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * FlashControl::progress:
   * @object: A #FlashControl.
   * @arg_filename: Argument.
   * @arg_progress: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-FlashControl.Progress">"Progress"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("progress",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FlashControlIface, progress),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_UCHAR);

  /* GObject properties for D-Bus properties: */
  /**
   * FlashControl:filename:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-FlashControl.filename">"filename"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("filename", "filename", "filename", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FlashControl:type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-FlashControl.type">"type"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("type", "type", "type", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * flash_control_get_filename: (skip)
 * @object: A #FlashControl.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-FlashControl.filename">"filename"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use flash_control_dup_filename() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
flash_control_get_filename (FlashControl *object)
{
  return FLASH_CONTROL_GET_IFACE (object)->get_filename (object);
}

/**
 * flash_control_dup_filename: (skip)
 * @object: A #FlashControl.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-FlashControl.filename">"filename"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
flash_control_dup_filename (FlashControl *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "filename", &value, NULL);
  return value;
}

/**
 * flash_control_set_filename: (skip)
 * @object: A #FlashControl.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-FlashControl.filename">"filename"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
flash_control_set_filename (FlashControl *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "filename", value, NULL);
}

/**
 * flash_control_get_type_: (skip)
 * @object: A #FlashControl.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-FlashControl.type">"type"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use flash_control_dup_type_() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
flash_control_get_type_ (FlashControl *object)
{
  return FLASH_CONTROL_GET_IFACE (object)->get_type_ (object);
}

/**
 * flash_control_dup_type_: (skip)
 * @object: A #FlashControl.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-FlashControl.type">"type"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
flash_control_dup_type_ (FlashControl *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "type", &value, NULL);
  return value;
}

/**
 * flash_control_set_type_: (skip)
 * @object: A #FlashControl.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-FlashControl.type">"type"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
flash_control_set_type_ (FlashControl *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "type", value, NULL);
}

/**
 * flash_control_emit_done:
 * @object: A #FlashControl.
 * @arg_filename: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-FlashControl.Done">"Done"</link> D-Bus signal.
 */
void
flash_control_emit_done (
    FlashControl *object,
    const gchar *arg_filename)
{
  g_signal_emit_by_name (object, "done", arg_filename);
}

/**
 * flash_control_emit_error:
 * @object: A #FlashControl.
 * @arg_filename: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-FlashControl.Error">"Error"</link> D-Bus signal.
 */
void
flash_control_emit_error (
    FlashControl *object,
    const gchar *arg_filename)
{
  g_signal_emit_by_name (object, "error", arg_filename);
}

/**
 * flash_control_emit_progress:
 * @object: A #FlashControl.
 * @arg_filename: Argument to pass with the signal.
 * @arg_progress: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-FlashControl.Progress">"Progress"</link> D-Bus signal.
 */
void
flash_control_emit_progress (
    FlashControl *object,
    const gchar *arg_filename,
    guchar arg_progress)
{
  g_signal_emit_by_name (object, "progress", arg_filename, arg_progress);
}

/**
 * flash_control_call_flash:
 * @proxy: A #FlashControlProxy.
 * @arg_type: Argument to pass with the method invocation.
 * @arg_filename: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-FlashControl.flash">flash()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call flash_control_call_flash_finish() to get the result of the operation.
 *
 * See flash_control_call_flash_sync() for the synchronous, blocking version of this method.
 */
void
flash_control_call_flash (
    FlashControl *proxy,
    const gchar *arg_type,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "flash",
    g_variant_new ("(ss)",
                   arg_type,
                   arg_filename),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * flash_control_call_flash_finish:
 * @proxy: A #FlashControlProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to flash_control_call_flash().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with flash_control_call_flash().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_control_call_flash_finish (
    FlashControl *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_control_call_flash_sync:
 * @proxy: A #FlashControlProxy.
 * @arg_type: Argument to pass with the method invocation.
 * @arg_filename: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-FlashControl.flash">flash()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See flash_control_call_flash() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
flash_control_call_flash_sync (
    FlashControl *proxy,
    const gchar *arg_type,
    const gchar *arg_filename,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "flash",
    g_variant_new ("(ss)",
                   arg_type,
                   arg_filename),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * flash_control_complete_flash:
 * @object: A #FlashControl.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-FlashControl.flash">flash()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
flash_control_complete_flash (
    FlashControl *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FlashControlProxy:
 *
 * The #FlashControlProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FlashControlProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FlashControlProxy.
 */

struct _FlashControlProxyPrivate
{
  GData *qdata;
};

static void flash_control_proxy_iface_init (FlashControlIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FlashControlProxy, flash_control_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (FlashControlProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_FLASH_CONTROL, flash_control_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FlashControlProxy, flash_control_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_FLASH_CONTROL, flash_control_proxy_iface_init));

#endif
static void
flash_control_proxy_finalize (GObject *object)
{
  FlashControlProxy *proxy = FLASH_CONTROL_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (flash_control_proxy_parent_class)->finalize (object);
}

static void
flash_control_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _flash_control_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
flash_control_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.FlashControl: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
flash_control_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _flash_control_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.FlashControl", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) flash_control_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
flash_control_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_flash_control_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_FLASH_CONTROL);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_FLASH_CONTROL);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
flash_control_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  FlashControlProxy *proxy = FLASH_CONTROL_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_flash_control_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_flash_control_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static const gchar *
flash_control_proxy_get_filename (FlashControl *object)
{
  FlashControlProxy *proxy = FLASH_CONTROL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "filename");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
flash_control_proxy_get_type_ (FlashControl *object)
{
  FlashControlProxy *proxy = FLASH_CONTROL_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "type");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
flash_control_proxy_init (FlashControlProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = flash_control_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_FLASH_CONTROL_PROXY, FlashControlProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), flash_control_interface_info ());
}

static void
flash_control_proxy_class_init (FlashControlProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = flash_control_proxy_finalize;
  gobject_class->get_property = flash_control_proxy_get_property;
  gobject_class->set_property = flash_control_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = flash_control_proxy_g_signal;
  proxy_class->g_properties_changed = flash_control_proxy_g_properties_changed;

  flash_control_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FlashControlProxyPrivate));
#endif
}

static void
flash_control_proxy_iface_init (FlashControlIface *iface)
{
  iface->get_filename = flash_control_proxy_get_filename;
  iface->get_type_ = flash_control_proxy_get_type_;
}

/**
 * flash_control_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-FlashControl.top_of_page">org.openbmc.FlashControl</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call flash_control_proxy_new_finish() to get the result of the operation.
 *
 * See flash_control_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
flash_control_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_FLASH_CONTROL_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.FlashControl", NULL);
}

/**
 * flash_control_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to flash_control_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with flash_control_proxy_new().
 *
 * Returns: (transfer full) (type FlashControlProxy): The constructed proxy object or %NULL if @error is set.
 */
FlashControl *
flash_control_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FLASH_CONTROL (ret);
  else
    return NULL;
}

/**
 * flash_control_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-FlashControl.top_of_page">org.openbmc.FlashControl</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See flash_control_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FlashControlProxy): The constructed proxy object or %NULL if @error is set.
 */
FlashControl *
flash_control_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_FLASH_CONTROL_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.FlashControl", NULL);
  if (ret != NULL)
    return FLASH_CONTROL (ret);
  else
    return NULL;
}


/**
 * flash_control_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like flash_control_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call flash_control_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See flash_control_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
flash_control_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_FLASH_CONTROL_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.FlashControl", NULL);
}

/**
 * flash_control_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to flash_control_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with flash_control_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FlashControlProxy): The constructed proxy object or %NULL if @error is set.
 */
FlashControl *
flash_control_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FLASH_CONTROL (ret);
  else
    return NULL;
}

/**
 * flash_control_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like flash_control_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See flash_control_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FlashControlProxy): The constructed proxy object or %NULL if @error is set.
 */
FlashControl *
flash_control_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_FLASH_CONTROL_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.FlashControl", NULL);
  if (ret != NULL)
    return FLASH_CONTROL (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FlashControlSkeleton:
 *
 * The #FlashControlSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FlashControlSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FlashControlSkeleton.
 */

struct _FlashControlSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_flash_control_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_FLASH_CONTROL);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_FLASH_CONTROL);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_flash_control_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_flash_control_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_flash_control_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_flash_control_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _flash_control_skeleton_vtable =
{
  _flash_control_skeleton_handle_method_call,
  _flash_control_skeleton_handle_get_property,
  _flash_control_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
flash_control_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return flash_control_interface_info ();
}

static GDBusInterfaceVTable *
flash_control_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_flash_control_skeleton_vtable;
}

static GVariant *
flash_control_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_flash_control_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _flash_control_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _flash_control_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _flash_control_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.FlashControl", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _flash_control_emit_changed (gpointer user_data);

static void
flash_control_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _flash_control_emit_changed (skeleton);
}

static void
_flash_control_on_signal_done (
    FlashControl *object,
    const gchar *arg_filename)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
                   arg_filename));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.FlashControl", "Done",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_flash_control_on_signal_error (
    FlashControl *object,
    const gchar *arg_filename)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
                   arg_filename));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.FlashControl", "Error",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_flash_control_on_signal_progress (
    FlashControl *object,
    const gchar *arg_filename,
    guchar arg_progress)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(sy)",
                   arg_filename,
                   arg_progress));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.FlashControl", "Progress",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void flash_control_skeleton_iface_init (FlashControlIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (FlashControlSkeleton, flash_control_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (FlashControlSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_FLASH_CONTROL, flash_control_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (FlashControlSkeleton, flash_control_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_FLASH_CONTROL, flash_control_skeleton_iface_init));

#endif
static void
flash_control_skeleton_finalize (GObject *object)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (flash_control_skeleton_parent_class)->finalize (object);
}

static void
flash_control_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_flash_control_emit_changed (gpointer user_data)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.FlashControl",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_flash_control_schedule_emit_changed (FlashControlSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
flash_control_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _flash_control_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _flash_control_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
flash_control_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _flash_control_schedule_emit_changed (skeleton, _flash_control_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
flash_control_skeleton_init (FlashControlSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = flash_control_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_FLASH_CONTROL_SKELETON, FlashControlSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
}

static const gchar *
flash_control_skeleton_get_filename (FlashControl *object)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
flash_control_skeleton_get_type_ (FlashControl *object)
{
  FlashControlSkeleton *skeleton = FLASH_CONTROL_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
flash_control_skeleton_class_init (FlashControlSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = flash_control_skeleton_finalize;
  gobject_class->get_property = flash_control_skeleton_get_property;
  gobject_class->set_property = flash_control_skeleton_set_property;
  gobject_class->notify       = flash_control_skeleton_notify;


  flash_control_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = flash_control_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = flash_control_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = flash_control_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = flash_control_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (FlashControlSkeletonPrivate));
#endif
}

static void
flash_control_skeleton_iface_init (FlashControlIface *iface)
{
  iface->done = _flash_control_on_signal_done;
  iface->error = _flash_control_on_signal_error;
  iface->progress = _flash_control_on_signal_progress;
  iface->get_filename = flash_control_skeleton_get_filename;
  iface->get_type_ = flash_control_skeleton_get_type_;
}

/**
 * flash_control_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-FlashControl.top_of_page">org.openbmc.FlashControl</link>.
 *
 * Returns: (transfer full) (type FlashControlSkeleton): The skeleton object.
 */
FlashControl *
flash_control_skeleton_new (void)
{
  return FLASH_CONTROL (g_object_new (TYPE_FLASH_CONTROL_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.Button
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:Button
 * @title: Button
 * @short_description: Generated C code for the org.openbmc.Button D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-Button.top_of_page">org.openbmc.Button</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.Button ---- */

static const _ExtendedGDBusArgInfo _button_method_info_is_on_OUT_ARG_state =
{
  {
    -1,
    (gchar *) "state",
    (gchar *) "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _button_method_info_is_on_OUT_ARG_pointers[] =
{
  &_button_method_info_is_on_OUT_ARG_state,
  NULL
};

static const _ExtendedGDBusMethodInfo _button_method_info_is_on =
{
  {
    -1,
    (gchar *) "isOn",
    NULL,
    (GDBusArgInfo **) &_button_method_info_is_on_OUT_ARG_pointers,
    NULL
  },
  "handle-is-on",
  FALSE
};

static const _ExtendedGDBusMethodInfo _button_method_info_sim_press =
{
  {
    -1,
    (gchar *) "simPress",
    NULL,
    NULL,
    NULL
  },
  "handle-sim-press",
  FALSE
};

static const _ExtendedGDBusMethodInfo _button_method_info_sim_long_press =
{
  {
    -1,
    (gchar *) "simLongPress",
    NULL,
    NULL,
    NULL
  },
  "handle-sim-long-press",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _button_method_info_pointers[] =
{
  &_button_method_info_is_on,
  &_button_method_info_sim_press,
  &_button_method_info_sim_long_press,
  NULL
};

static const _ExtendedGDBusSignalInfo _button_signal_info_released =
{
  {
    -1,
    (gchar *) "Released",
    NULL,
    NULL
  },
  "released"
};

static const _ExtendedGDBusSignalInfo _button_signal_info_pressed =
{
  {
    -1,
    (gchar *) "Pressed",
    NULL,
    NULL
  },
  "pressed"
};

static const _ExtendedGDBusSignalInfo _button_signal_info_pressed_long =
{
  {
    -1,
    (gchar *) "PressedLong",
    NULL,
    NULL
  },
  "pressed-long"
};

static const _ExtendedGDBusSignalInfo * const _button_signal_info_pointers[] =
{
  &_button_signal_info_released,
  &_button_signal_info_pressed,
  &_button_signal_info_pressed_long,
  NULL
};

static const _ExtendedGDBusPropertyInfo _button_property_info_state =
{
  {
    -1,
    (gchar *) "state",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "state",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _button_property_info_timer =
{
  {
    -1,
    (gchar *) "timer",
    (gchar *) "t",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "timer",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _button_property_info_pointers[] =
{
  &_button_property_info_state,
  &_button_property_info_timer,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _button_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.Button",
    (GDBusMethodInfo **) &_button_method_info_pointers,
    (GDBusSignalInfo **) &_button_signal_info_pointers,
    (GDBusPropertyInfo **) &_button_property_info_pointers,
    NULL
  },
  "button",
};


/**
 * button_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-Button.top_of_page">org.openbmc.Button</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
button_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_button_interface_info.parent_struct;
}

/**
 * button_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #Button interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
button_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "state");
  g_object_class_override_property (klass, property_id_begin++, "timer");
  return property_id_begin - 1;
}



/**
 * Button:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Button.top_of_page">org.openbmc.Button</link>.
 */

/**
 * ButtonIface:
 * @parent_iface: The parent interface.
 * @handle_is_on: Handler for the #Button::handle-is-on signal.
 * @handle_sim_long_press: Handler for the #Button::handle-sim-long-press signal.
 * @handle_sim_press: Handler for the #Button::handle-sim-press signal.
 * @get_state: Getter for the #Button:state property.
 * @get_timer: Getter for the #Button:timer property.
 * @pressed: Handler for the #Button::pressed signal.
 * @pressed_long: Handler for the #Button::pressed-long signal.
 * @released: Handler for the #Button::released signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Button.top_of_page">org.openbmc.Button</link>.
 */

typedef ButtonIface ButtonInterface;
G_DEFINE_INTERFACE (Button, button, G_TYPE_OBJECT);

static void
button_default_init (ButtonIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * Button::handle-is-on:
   * @object: A #Button.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Button.isOn">isOn()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call button_complete_is_on() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-is-on",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ButtonIface, handle_is_on),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * Button::handle-sim-press:
   * @object: A #Button.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Button.simPress">simPress()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call button_complete_sim_press() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-sim-press",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ButtonIface, handle_sim_press),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * Button::handle-sim-long-press:
   * @object: A #Button.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Button.simLongPress">simLongPress()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call button_complete_sim_long_press() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-sim-long-press",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ButtonIface, handle_sim_long_press),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * Button::released:
   * @object: A #Button.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-Button.Released">"Released"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("released",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ButtonIface, released),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * Button::pressed:
   * @object: A #Button.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-Button.Pressed">"Pressed"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("pressed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ButtonIface, pressed),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * Button::pressed-long:
   * @object: A #Button.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-Button.PressedLong">"PressedLong"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("pressed-long",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (ButtonIface, pressed_long),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * Button:state:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Button.state">"state"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("state", "state", "state", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Button:timer:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Button.timer">"timer"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint64 ("timer", "timer", "timer", 0, G_MAXUINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * button_get_state: (skip)
 * @object: A #Button.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Button.state">"state"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
button_get_state (Button *object)
{
  return BUTTON_GET_IFACE (object)->get_state (object);
}

/**
 * button_set_state: (skip)
 * @object: A #Button.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Button.state">"state"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
button_set_state (Button *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "state", value, NULL);
}

/**
 * button_get_timer: (skip)
 * @object: A #Button.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Button.timer">"timer"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guint64 
button_get_timer (Button *object)
{
  return BUTTON_GET_IFACE (object)->get_timer (object);
}

/**
 * button_set_timer: (skip)
 * @object: A #Button.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Button.timer">"timer"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
button_set_timer (Button *object, guint64 value)
{
  g_object_set (G_OBJECT (object), "timer", value, NULL);
}

/**
 * button_emit_released:
 * @object: A #Button.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-Button.Released">"Released"</link> D-Bus signal.
 */
void
button_emit_released (
    Button *object)
{
  g_signal_emit_by_name (object, "released");
}

/**
 * button_emit_pressed:
 * @object: A #Button.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-Button.Pressed">"Pressed"</link> D-Bus signal.
 */
void
button_emit_pressed (
    Button *object)
{
  g_signal_emit_by_name (object, "pressed");
}

/**
 * button_emit_pressed_long:
 * @object: A #Button.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-Button.PressedLong">"PressedLong"</link> D-Bus signal.
 */
void
button_emit_pressed_long (
    Button *object)
{
  g_signal_emit_by_name (object, "pressed-long");
}

/**
 * button_call_is_on:
 * @proxy: A #ButtonProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Button.isOn">isOn()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call button_call_is_on_finish() to get the result of the operation.
 *
 * See button_call_is_on_sync() for the synchronous, blocking version of this method.
 */
void
button_call_is_on (
    Button *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "isOn",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * button_call_is_on_finish:
 * @proxy: A #ButtonProxy.
 * @out_state: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to button_call_is_on().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with button_call_is_on().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
button_call_is_on_finish (
    Button *proxy,
    gboolean *out_state,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_state);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * button_call_is_on_sync:
 * @proxy: A #ButtonProxy.
 * @out_state: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Button.isOn">isOn()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See button_call_is_on() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
button_call_is_on_sync (
    Button *proxy,
    gboolean *out_state,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "isOn",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(b)",
                 out_state);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * button_call_sim_press:
 * @proxy: A #ButtonProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Button.simPress">simPress()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call button_call_sim_press_finish() to get the result of the operation.
 *
 * See button_call_sim_press_sync() for the synchronous, blocking version of this method.
 */
void
button_call_sim_press (
    Button *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "simPress",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * button_call_sim_press_finish:
 * @proxy: A #ButtonProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to button_call_sim_press().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with button_call_sim_press().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
button_call_sim_press_finish (
    Button *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * button_call_sim_press_sync:
 * @proxy: A #ButtonProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Button.simPress">simPress()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See button_call_sim_press() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
button_call_sim_press_sync (
    Button *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "simPress",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * button_call_sim_long_press:
 * @proxy: A #ButtonProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Button.simLongPress">simLongPress()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call button_call_sim_long_press_finish() to get the result of the operation.
 *
 * See button_call_sim_long_press_sync() for the synchronous, blocking version of this method.
 */
void
button_call_sim_long_press (
    Button *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "simLongPress",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * button_call_sim_long_press_finish:
 * @proxy: A #ButtonProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to button_call_sim_long_press().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with button_call_sim_long_press().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
button_call_sim_long_press_finish (
    Button *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * button_call_sim_long_press_sync:
 * @proxy: A #ButtonProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Button.simLongPress">simLongPress()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See button_call_sim_long_press() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
button_call_sim_long_press_sync (
    Button *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "simLongPress",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * button_complete_is_on:
 * @object: A #Button.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @state: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Button.isOn">isOn()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
button_complete_is_on (
    Button *object,
    GDBusMethodInvocation *invocation,
    gboolean state)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(b)",
                   state));
}

/**
 * button_complete_sim_press:
 * @object: A #Button.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Button.simPress">simPress()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
button_complete_sim_press (
    Button *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * button_complete_sim_long_press:
 * @object: A #Button.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Button.simLongPress">simLongPress()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
button_complete_sim_long_press (
    Button *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * ButtonProxy:
 *
 * The #ButtonProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ButtonProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ButtonProxy.
 */

struct _ButtonProxyPrivate
{
  GData *qdata;
};

static void button_proxy_iface_init (ButtonIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ButtonProxy, button_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (ButtonProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_BUTTON, button_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ButtonProxy, button_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_BUTTON, button_proxy_iface_init));

#endif
static void
button_proxy_finalize (GObject *object)
{
  ButtonProxy *proxy = BUTTON_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (button_proxy_parent_class)->finalize (object);
}

static void
button_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _button_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
button_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.Button: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
button_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  info = _button_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.Button", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) button_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
button_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_button_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_BUTTON);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_BUTTON);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
button_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  ButtonProxy *proxy = BUTTON_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_button_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_button_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gboolean 
button_proxy_get_state (Button *object)
{
  ButtonProxy *proxy = BUTTON_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "state");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static guint64 
button_proxy_get_timer (Button *object)
{
  ButtonProxy *proxy = BUTTON_PROXY (object);
  GVariant *variant;
  guint64 value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "timer");
  if (variant != NULL)
    {
      value = g_variant_get_uint64 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
button_proxy_init (ButtonProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = button_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_BUTTON_PROXY, ButtonProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), button_interface_info ());
}

static void
button_proxy_class_init (ButtonProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = button_proxy_finalize;
  gobject_class->get_property = button_proxy_get_property;
  gobject_class->set_property = button_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = button_proxy_g_signal;
  proxy_class->g_properties_changed = button_proxy_g_properties_changed;

  button_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ButtonProxyPrivate));
#endif
}

static void
button_proxy_iface_init (ButtonIface *iface)
{
  iface->get_state = button_proxy_get_state;
  iface->get_timer = button_proxy_get_timer;
}

/**
 * button_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Button.top_of_page">org.openbmc.Button</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call button_proxy_new_finish() to get the result of the operation.
 *
 * See button_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
button_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_BUTTON_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Button", NULL);
}

/**
 * button_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to button_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with button_proxy_new().
 *
 * Returns: (transfer full) (type ButtonProxy): The constructed proxy object or %NULL if @error is set.
 */
Button *
button_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return BUTTON (ret);
  else
    return NULL;
}

/**
 * button_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Button.top_of_page">org.openbmc.Button</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See button_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ButtonProxy): The constructed proxy object or %NULL if @error is set.
 */
Button *
button_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_BUTTON_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Button", NULL);
  if (ret != NULL)
    return BUTTON (ret);
  else
    return NULL;
}


/**
 * button_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like button_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call button_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See button_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
button_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_BUTTON_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Button", NULL);
}

/**
 * button_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to button_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with button_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type ButtonProxy): The constructed proxy object or %NULL if @error is set.
 */
Button *
button_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return BUTTON (ret);
  else
    return NULL;
}

/**
 * button_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like button_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See button_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ButtonProxy): The constructed proxy object or %NULL if @error is set.
 */
Button *
button_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_BUTTON_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Button", NULL);
  if (ret != NULL)
    return BUTTON (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * ButtonSkeleton:
 *
 * The #ButtonSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ButtonSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ButtonSkeleton.
 */

struct _ButtonSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_button_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_BUTTON);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_BUTTON);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_button_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_button_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_button_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_button_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _button_skeleton_vtable =
{
  _button_skeleton_handle_method_call,
  _button_skeleton_handle_get_property,
  _button_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
button_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return button_interface_info ();
}

static GDBusInterfaceVTable *
button_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_button_skeleton_vtable;
}

static GVariant *
button_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_button_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _button_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _button_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _button_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Button", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _button_emit_changed (gpointer user_data);

static void
button_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _button_emit_changed (skeleton);
}

static void
_button_on_signal_released (
    Button *object)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Button", "Released",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_button_on_signal_pressed (
    Button *object)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Button", "Pressed",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_button_on_signal_pressed_long (
    Button *object)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Button", "PressedLong",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void button_skeleton_iface_init (ButtonIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (ButtonSkeleton, button_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (ButtonSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_BUTTON, button_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (ButtonSkeleton, button_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_BUTTON, button_skeleton_iface_init));

#endif
static void
button_skeleton_finalize (GObject *object)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (object);
  guint n;
  for (n = 0; n < 2; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (button_skeleton_parent_class)->finalize (object);
}

static void
button_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_button_emit_changed (gpointer user_data)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.Button",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_button_schedule_emit_changed (ButtonSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
button_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _button_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _button_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
button_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 2);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _button_schedule_emit_changed (skeleton, _button_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
button_skeleton_init (ButtonSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = button_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_BUTTON_SKELETON, ButtonSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 2);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_UINT64);
}

static gboolean 
button_skeleton_get_state (Button *object)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static guint64 
button_skeleton_get_timer (Button *object)
{
  ButtonSkeleton *skeleton = BUTTON_SKELETON (object);
  guint64 value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_uint64 (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
button_skeleton_class_init (ButtonSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = button_skeleton_finalize;
  gobject_class->get_property = button_skeleton_get_property;
  gobject_class->set_property = button_skeleton_set_property;
  gobject_class->notify       = button_skeleton_notify;


  button_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = button_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = button_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = button_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = button_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (ButtonSkeletonPrivate));
#endif
}

static void
button_skeleton_iface_init (ButtonIface *iface)
{
  iface->released = _button_on_signal_released;
  iface->pressed = _button_on_signal_pressed;
  iface->pressed_long = _button_on_signal_pressed_long;
  iface->get_state = button_skeleton_get_state;
  iface->get_timer = button_skeleton_get_timer;
}

/**
 * button_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Button.top_of_page">org.openbmc.Button</link>.
 *
 * Returns: (transfer full) (type ButtonSkeleton): The skeleton object.
 */
Button *
button_skeleton_new (void)
{
  return BUTTON (g_object_new (TYPE_BUTTON_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.Led
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:Led
 * @title: Led
 * @short_description: Generated C code for the org.openbmc.Led D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-Led.top_of_page">org.openbmc.Led</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.Led ---- */

static const _ExtendedGDBusMethodInfo _led_method_info_set_on =
{
  {
    -1,
    (gchar *) "setOn",
    NULL,
    NULL,
    NULL
  },
  "handle-set-on",
  FALSE
};

static const _ExtendedGDBusMethodInfo _led_method_info_set_off =
{
  {
    -1,
    (gchar *) "setOff",
    NULL,
    NULL,
    NULL
  },
  "handle-set-off",
  FALSE
};

static const _ExtendedGDBusMethodInfo _led_method_info_set_blink_slow =
{
  {
    -1,
    (gchar *) "setBlinkSlow",
    NULL,
    NULL,
    NULL
  },
  "handle-set-blink-slow",
  FALSE
};

static const _ExtendedGDBusMethodInfo _led_method_info_set_blink_fast =
{
  {
    -1,
    (gchar *) "setBlinkFast",
    NULL,
    NULL,
    NULL
  },
  "handle-set-blink-fast",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _led_method_info_pointers[] =
{
  &_led_method_info_set_on,
  &_led_method_info_set_off,
  &_led_method_info_set_blink_slow,
  &_led_method_info_set_blink_fast,
  NULL
};

static const _ExtendedGDBusPropertyInfo _led_property_info_color =
{
  {
    -1,
    (gchar *) "color",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "color",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _led_property_info_function =
{
  {
    -1,
    (gchar *) "function",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "function",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _led_property_info_state =
{
  {
    -1,
    (gchar *) "state",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "state",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _led_property_info_pointers[] =
{
  &_led_property_info_color,
  &_led_property_info_function,
  &_led_property_info_state,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _led_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.Led",
    (GDBusMethodInfo **) &_led_method_info_pointers,
    NULL,
    (GDBusPropertyInfo **) &_led_property_info_pointers,
    NULL
  },
  "led",
};


/**
 * led_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-Led.top_of_page">org.openbmc.Led</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
led_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_led_interface_info.parent_struct;
}

/**
 * led_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #Led interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
led_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "color");
  g_object_class_override_property (klass, property_id_begin++, "function");
  g_object_class_override_property (klass, property_id_begin++, "state");
  return property_id_begin - 1;
}



/**
 * Led:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Led.top_of_page">org.openbmc.Led</link>.
 */

/**
 * LedIface:
 * @parent_iface: The parent interface.
 * @handle_set_blink_fast: Handler for the #Led::handle-set-blink-fast signal.
 * @handle_set_blink_slow: Handler for the #Led::handle-set-blink-slow signal.
 * @handle_set_off: Handler for the #Led::handle-set-off signal.
 * @handle_set_on: Handler for the #Led::handle-set-on signal.
 * @get_color: Getter for the #Led:color property.
 * @get_function: Getter for the #Led:function property.
 * @get_state: Getter for the #Led:state property.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Led.top_of_page">org.openbmc.Led</link>.
 */

typedef LedIface LedInterface;
G_DEFINE_INTERFACE (Led, led, G_TYPE_OBJECT);

static void
led_default_init (LedIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * Led::handle-set-on:
   * @object: A #Led.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Led.setOn">setOn()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call led_complete_set_on() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-on",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (LedIface, handle_set_on),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * Led::handle-set-off:
   * @object: A #Led.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Led.setOff">setOff()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call led_complete_set_off() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-off",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (LedIface, handle_set_off),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * Led::handle-set-blink-slow:
   * @object: A #Led.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Led.setBlinkSlow">setBlinkSlow()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call led_complete_set_blink_slow() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-blink-slow",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (LedIface, handle_set_blink_slow),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * Led::handle-set-blink-fast:
   * @object: A #Led.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-Led.setBlinkFast">setBlinkFast()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call led_complete_set_blink_fast() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-blink-fast",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (LedIface, handle_set_blink_fast),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject properties for D-Bus properties: */
  /**
   * Led:color:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Led.color">"color"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("color", "color", "color", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Led:function:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Led.function">"function"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("function", "function", "function", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * Led:state:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-openbmc-Led.state">"state"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("state", "state", "state", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * led_get_color: (skip)
 * @object: A #Led.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Led.color">"color"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
led_get_color (Led *object)
{
  return LED_GET_IFACE (object)->get_color (object);
}

/**
 * led_set_color: (skip)
 * @object: A #Led.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Led.color">"color"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
led_set_color (Led *object, gint value)
{
  g_object_set (G_OBJECT (object), "color", value, NULL);
}

/**
 * led_get_function: (skip)
 * @object: A #Led.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Led.function">"function"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use led_dup_function() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
led_get_function (Led *object)
{
  return LED_GET_IFACE (object)->get_function (object);
}

/**
 * led_dup_function: (skip)
 * @object: A #Led.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-Led.function">"function"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
led_dup_function (Led *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "function", &value, NULL);
  return value;
}

/**
 * led_set_function: (skip)
 * @object: A #Led.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Led.function">"function"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
led_set_function (Led *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "function", value, NULL);
}

/**
 * led_get_state: (skip)
 * @object: A #Led.
 *
 * Gets the value of the <link linkend="gdbus-property-org-openbmc-Led.state">"state"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use led_dup_state() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
led_get_state (Led *object)
{
  return LED_GET_IFACE (object)->get_state (object);
}

/**
 * led_dup_state: (skip)
 * @object: A #Led.
 *
 * Gets a copy of the <link linkend="gdbus-property-org-openbmc-Led.state">"state"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
led_dup_state (Led *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "state", &value, NULL);
  return value;
}

/**
 * led_set_state: (skip)
 * @object: A #Led.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-openbmc-Led.state">"state"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
led_set_state (Led *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "state", value, NULL);
}

/**
 * led_call_set_on:
 * @proxy: A #LedProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Led.setOn">setOn()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call led_call_set_on_finish() to get the result of the operation.
 *
 * See led_call_set_on_sync() for the synchronous, blocking version of this method.
 */
void
led_call_set_on (
    Led *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setOn",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * led_call_set_on_finish:
 * @proxy: A #LedProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to led_call_set_on().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with led_call_set_on().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
led_call_set_on_finish (
    Led *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * led_call_set_on_sync:
 * @proxy: A #LedProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Led.setOn">setOn()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See led_call_set_on() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
led_call_set_on_sync (
    Led *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setOn",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * led_call_set_off:
 * @proxy: A #LedProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Led.setOff">setOff()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call led_call_set_off_finish() to get the result of the operation.
 *
 * See led_call_set_off_sync() for the synchronous, blocking version of this method.
 */
void
led_call_set_off (
    Led *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setOff",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * led_call_set_off_finish:
 * @proxy: A #LedProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to led_call_set_off().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with led_call_set_off().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
led_call_set_off_finish (
    Led *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * led_call_set_off_sync:
 * @proxy: A #LedProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Led.setOff">setOff()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See led_call_set_off() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
led_call_set_off_sync (
    Led *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setOff",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * led_call_set_blink_slow:
 * @proxy: A #LedProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Led.setBlinkSlow">setBlinkSlow()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call led_call_set_blink_slow_finish() to get the result of the operation.
 *
 * See led_call_set_blink_slow_sync() for the synchronous, blocking version of this method.
 */
void
led_call_set_blink_slow (
    Led *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setBlinkSlow",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * led_call_set_blink_slow_finish:
 * @proxy: A #LedProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to led_call_set_blink_slow().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with led_call_set_blink_slow().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
led_call_set_blink_slow_finish (
    Led *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * led_call_set_blink_slow_sync:
 * @proxy: A #LedProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Led.setBlinkSlow">setBlinkSlow()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See led_call_set_blink_slow() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
led_call_set_blink_slow_sync (
    Led *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setBlinkSlow",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * led_call_set_blink_fast:
 * @proxy: A #LedProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-Led.setBlinkFast">setBlinkFast()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call led_call_set_blink_fast_finish() to get the result of the operation.
 *
 * See led_call_set_blink_fast_sync() for the synchronous, blocking version of this method.
 */
void
led_call_set_blink_fast (
    Led *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "setBlinkFast",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * led_call_set_blink_fast_finish:
 * @proxy: A #LedProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to led_call_set_blink_fast().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with led_call_set_blink_fast().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
led_call_set_blink_fast_finish (
    Led *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * led_call_set_blink_fast_sync:
 * @proxy: A #LedProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-Led.setBlinkFast">setBlinkFast()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See led_call_set_blink_fast() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
led_call_set_blink_fast_sync (
    Led *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "setBlinkFast",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * led_complete_set_on:
 * @object: A #Led.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Led.setOn">setOn()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
led_complete_set_on (
    Led *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * led_complete_set_off:
 * @object: A #Led.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Led.setOff">setOff()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
led_complete_set_off (
    Led *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * led_complete_set_blink_slow:
 * @object: A #Led.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Led.setBlinkSlow">setBlinkSlow()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
led_complete_set_blink_slow (
    Led *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * led_complete_set_blink_fast:
 * @object: A #Led.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-Led.setBlinkFast">setBlinkFast()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
led_complete_set_blink_fast (
    Led *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * LedProxy:
 *
 * The #LedProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * LedProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #LedProxy.
 */

struct _LedProxyPrivate
{
  GData *qdata;
};

static void led_proxy_iface_init (LedIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (LedProxy, led_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (LedProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_LED, led_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (LedProxy, led_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_LED, led_proxy_iface_init));

#endif
static void
led_proxy_finalize (GObject *object)
{
  LedProxy *proxy = LED_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (led_proxy_parent_class)->finalize (object);
}

static void
led_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _led_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
led_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface org.openbmc.Led: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
led_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _led_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.openbmc.Led", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) led_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
led_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_led_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_LED);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_LED);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
led_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  LedProxy *proxy = LED_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_led_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_led_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gint 
led_proxy_get_color (Led *object)
{
  LedProxy *proxy = LED_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "color");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
led_proxy_get_function (Led *object)
{
  LedProxy *proxy = LED_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "function");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
led_proxy_get_state (Led *object)
{
  LedProxy *proxy = LED_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "state");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
led_proxy_init (LedProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = led_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_LED_PROXY, LedProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), led_interface_info ());
}

static void
led_proxy_class_init (LedProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = led_proxy_finalize;
  gobject_class->get_property = led_proxy_get_property;
  gobject_class->set_property = led_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = led_proxy_g_signal;
  proxy_class->g_properties_changed = led_proxy_g_properties_changed;

  led_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (LedProxyPrivate));
#endif
}

static void
led_proxy_iface_init (LedIface *iface)
{
  iface->get_color = led_proxy_get_color;
  iface->get_function = led_proxy_get_function;
  iface->get_state = led_proxy_get_state;
}

/**
 * led_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Led.top_of_page">org.openbmc.Led</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call led_proxy_new_finish() to get the result of the operation.
 *
 * See led_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
led_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_LED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Led", NULL);
}

/**
 * led_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to led_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with led_proxy_new().
 *
 * Returns: (transfer full) (type LedProxy): The constructed proxy object or %NULL if @error is set.
 */
Led *
led_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return LED (ret);
  else
    return NULL;
}

/**
 * led_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Led.top_of_page">org.openbmc.Led</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See led_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type LedProxy): The constructed proxy object or %NULL if @error is set.
 */
Led *
led_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_LED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.Led", NULL);
  if (ret != NULL)
    return LED (ret);
  else
    return NULL;
}


/**
 * led_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like led_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call led_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See led_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
led_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_LED_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Led", NULL);
}

/**
 * led_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to led_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with led_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type LedProxy): The constructed proxy object or %NULL if @error is set.
 */
Led *
led_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return LED (ret);
  else
    return NULL;
}

/**
 * led_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like led_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See led_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type LedProxy): The constructed proxy object or %NULL if @error is set.
 */
Led *
led_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_LED_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.Led", NULL);
  if (ret != NULL)
    return LED (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * LedSkeleton:
 *
 * The #LedSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * LedSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #LedSkeleton.
 */

struct _LedSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_led_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  LedSkeleton *skeleton = LED_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_LED);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_LED);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_led_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  LedSkeleton *skeleton = LED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_led_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_led_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  LedSkeleton *skeleton = LED_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_led_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _led_skeleton_vtable =
{
  _led_skeleton_handle_method_call,
  _led_skeleton_handle_get_property,
  _led_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
led_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return led_interface_info ();
}

static GDBusInterfaceVTable *
led_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_led_skeleton_vtable;
}

static GVariant *
led_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  LedSkeleton *skeleton = LED_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_led_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _led_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _led_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _led_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.Led", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _led_emit_changed (gpointer user_data);

static void
led_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  LedSkeleton *skeleton = LED_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _led_emit_changed (skeleton);
}

static void led_skeleton_iface_init (LedIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (LedSkeleton, led_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (LedSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_LED, led_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (LedSkeleton, led_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_LED, led_skeleton_iface_init));

#endif
static void
led_skeleton_finalize (GObject *object)
{
  LedSkeleton *skeleton = LED_SKELETON (object);
  guint n;
  for (n = 0; n < 3; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (led_skeleton_parent_class)->finalize (object);
}

static void
led_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  LedSkeleton *skeleton = LED_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_led_emit_changed (gpointer user_data)
{
  LedSkeleton *skeleton = LED_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "org.openbmc.Led",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_led_schedule_emit_changed (LedSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
led_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  LedSkeleton *skeleton = LED_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _led_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _led_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
led_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  LedSkeleton *skeleton = LED_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _led_schedule_emit_changed (skeleton, _led_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
led_skeleton_init (LedSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = led_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_LED_SKELETON, LedSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 3);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_STRING);
}

static gint 
led_skeleton_get_color (Led *object)
{
  LedSkeleton *skeleton = LED_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
led_skeleton_get_function (Led *object)
{
  LedSkeleton *skeleton = LED_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
led_skeleton_get_state (Led *object)
{
  LedSkeleton *skeleton = LED_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
led_skeleton_class_init (LedSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = led_skeleton_finalize;
  gobject_class->get_property = led_skeleton_get_property;
  gobject_class->set_property = led_skeleton_set_property;
  gobject_class->notify       = led_skeleton_notify;


  led_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = led_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = led_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = led_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = led_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (LedSkeletonPrivate));
#endif
}

static void
led_skeleton_iface_init (LedIface *iface)
{
  iface->get_color = led_skeleton_get_color;
  iface->get_function = led_skeleton_get_function;
  iface->get_state = led_skeleton_get_state;
}

/**
 * led_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Led.top_of_page">org.openbmc.Led</link>.
 *
 * Returns: (transfer full) (type LedSkeleton): The skeleton object.
 */
Led *
led_skeleton_new (void)
{
  return LED (g_object_new (TYPE_LED_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.openbmc.HostIpmi
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:HostIpmi
 * @title: HostIpmi
 * @short_description: Generated C code for the org.openbmc.HostIpmi D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-openbmc-HostIpmi.top_of_page">org.openbmc.HostIpmi</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.openbmc.HostIpmi ---- */

static const _ExtendedGDBusArgInfo _host_ipmi_method_info_send_message_IN_ARG_seq =
{
  {
    -1,
    (gchar *) "seq",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _host_ipmi_method_info_send_message_IN_ARG_netfn =
{
  {
    -1,
    (gchar *) "netfn",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _host_ipmi_method_info_send_message_IN_ARG_cmd =
{
  {
    -1,
    (gchar *) "cmd",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _host_ipmi_method_info_send_message_IN_ARG_data =
{
  {
    -1,
    (gchar *) "data",
    (gchar *) "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _host_ipmi_method_info_send_message_IN_ARG_pointers[] =
{
  &_host_ipmi_method_info_send_message_IN_ARG_seq,
  &_host_ipmi_method_info_send_message_IN_ARG_netfn,
  &_host_ipmi_method_info_send_message_IN_ARG_cmd,
  &_host_ipmi_method_info_send_message_IN_ARG_data,
  NULL
};

static const _ExtendedGDBusArgInfo _host_ipmi_method_info_send_message_OUT_ARG_unnamed_arg4 =
{
  {
    -1,
    (gchar *) "unnamed_arg4",
    (gchar *) "x",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _host_ipmi_method_info_send_message_OUT_ARG_pointers[] =
{
  &_host_ipmi_method_info_send_message_OUT_ARG_unnamed_arg4,
  NULL
};

static const _ExtendedGDBusMethodInfo _host_ipmi_method_info_send_message =
{
  {
    -1,
    (gchar *) "sendMessage",
    (GDBusArgInfo **) &_host_ipmi_method_info_send_message_IN_ARG_pointers,
    (GDBusArgInfo **) &_host_ipmi_method_info_send_message_OUT_ARG_pointers,
    NULL
  },
  "handle-send-message",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _host_ipmi_method_info_pointers[] =
{
  &_host_ipmi_method_info_send_message,
  NULL
};

static const _ExtendedGDBusArgInfo _host_ipmi_signal_info_received_message_ARG_seq =
{
  {
    -1,
    (gchar *) "seq",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _host_ipmi_signal_info_received_message_ARG_netfn =
{
  {
    -1,
    (gchar *) "netfn",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _host_ipmi_signal_info_received_message_ARG_cmd =
{
  {
    -1,
    (gchar *) "cmd",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _host_ipmi_signal_info_received_message_ARG_data =
{
  {
    -1,
    (gchar *) "data",
    (gchar *) "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _host_ipmi_signal_info_received_message_ARG_pointers[] =
{
  &_host_ipmi_signal_info_received_message_ARG_seq,
  &_host_ipmi_signal_info_received_message_ARG_netfn,
  &_host_ipmi_signal_info_received_message_ARG_cmd,
  &_host_ipmi_signal_info_received_message_ARG_data,
  NULL
};

static const _ExtendedGDBusSignalInfo _host_ipmi_signal_info_received_message =
{
  {
    -1,
    (gchar *) "ReceivedMessage",
    (GDBusArgInfo **) &_host_ipmi_signal_info_received_message_ARG_pointers,
    NULL
  },
  "received-message"
};

static const _ExtendedGDBusSignalInfo * const _host_ipmi_signal_info_pointers[] =
{
  &_host_ipmi_signal_info_received_message,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _host_ipmi_interface_info =
{
  {
    -1,
    (gchar *) "org.openbmc.HostIpmi",
    (GDBusMethodInfo **) &_host_ipmi_method_info_pointers,
    (GDBusSignalInfo **) &_host_ipmi_signal_info_pointers,
    NULL,
    NULL
  },
  "host-ipmi",
};


/**
 * host_ipmi_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-openbmc-HostIpmi.top_of_page">org.openbmc.HostIpmi</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
host_ipmi_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_host_ipmi_interface_info.parent_struct;
}

/**
 * host_ipmi_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #HostIpmi interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
host_ipmi_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * HostIpmi:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-HostIpmi.top_of_page">org.openbmc.HostIpmi</link>.
 */

/**
 * HostIpmiIface:
 * @parent_iface: The parent interface.
 * @handle_send_message: Handler for the #HostIpmi::handle-send-message signal.
 * @received_message: Handler for the #HostIpmi::received-message signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-HostIpmi.top_of_page">org.openbmc.HostIpmi</link>.
 */

typedef HostIpmiIface HostIpmiInterface;
G_DEFINE_INTERFACE (HostIpmi, host_ipmi, G_TYPE_OBJECT);

static void
host_ipmi_default_init (HostIpmiIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * HostIpmi::handle-send-message:
   * @object: A #HostIpmi.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_seq: Argument passed by remote caller.
   * @arg_netfn: Argument passed by remote caller.
   * @arg_cmd: Argument passed by remote caller.
   * @arg_data: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-openbmc-HostIpmi.sendMessage">sendMessage()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call host_ipmi_complete_send_message() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-send-message",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (HostIpmiIface, handle_send_message),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    5,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_STRING);

  /* GObject signals for received D-Bus signals: */
  /**
   * HostIpmi::received-message:
   * @object: A #HostIpmi.
   * @arg_seq: Argument.
   * @arg_netfn: Argument.
   * @arg_cmd: Argument.
   * @arg_data: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-openbmc-HostIpmi.ReceivedMessage">"ReceivedMessage"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("received-message",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (HostIpmiIface, received_message),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    4, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_UCHAR, G_TYPE_STRING);

}

/**
 * host_ipmi_emit_received_message:
 * @object: A #HostIpmi.
 * @arg_seq: Argument to pass with the signal.
 * @arg_netfn: Argument to pass with the signal.
 * @arg_cmd: Argument to pass with the signal.
 * @arg_data: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-openbmc-HostIpmi.ReceivedMessage">"ReceivedMessage"</link> D-Bus signal.
 */
void
host_ipmi_emit_received_message (
    HostIpmi *object,
    guchar arg_seq,
    guchar arg_netfn,
    guchar arg_cmd,
    const gchar *arg_data)
{
  g_signal_emit_by_name (object, "received-message", arg_seq, arg_netfn, arg_cmd, arg_data);
}

/**
 * host_ipmi_call_send_message:
 * @proxy: A #HostIpmiProxy.
 * @arg_seq: Argument to pass with the method invocation.
 * @arg_netfn: Argument to pass with the method invocation.
 * @arg_cmd: Argument to pass with the method invocation.
 * @arg_data: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-openbmc-HostIpmi.sendMessage">sendMessage()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call host_ipmi_call_send_message_finish() to get the result of the operation.
 *
 * See host_ipmi_call_send_message_sync() for the synchronous, blocking version of this method.
 */
void
host_ipmi_call_send_message (
    HostIpmi *proxy,
    guchar arg_seq,
    guchar arg_netfn,
    guchar arg_cmd,
    const gchar *arg_data,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "sendMessage",
    g_variant_new ("(yyy^ay)",
                   arg_seq,
                   arg_netfn,
                   arg_cmd,
                   arg_data),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * host_ipmi_call_send_message_finish:
 * @proxy: A #HostIpmiProxy.
 * @out_unnamed_arg4: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to host_ipmi_call_send_message().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with host_ipmi_call_send_message().
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
host_ipmi_call_send_message_finish (
    HostIpmi *proxy,
    gint64 *out_unnamed_arg4,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(x)",
                 out_unnamed_arg4);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * host_ipmi_call_send_message_sync:
 * @proxy: A #HostIpmiProxy.
 * @arg_seq: Argument to pass with the method invocation.
 * @arg_netfn: Argument to pass with the method invocation.
 * @arg_cmd: Argument to pass with the method invocation.
 * @arg_data: Argument to pass with the method invocation.
 * @out_unnamed_arg4: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-openbmc-HostIpmi.sendMessage">sendMessage()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See host_ipmi_call_send_message() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeeded, %FALSE if @error is set.
 */
gboolean
host_ipmi_call_send_message_sync (
    HostIpmi *proxy,
    guchar arg_seq,
    guchar arg_netfn,
    guchar arg_cmd,
    const gchar *arg_data,
    gint64 *out_unnamed_arg4,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "sendMessage",
    g_variant_new ("(yyy^ay)",
                   arg_seq,
                   arg_netfn,
                   arg_cmd,
                   arg_data),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(x)",
                 out_unnamed_arg4);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * host_ipmi_complete_send_message:
 * @object: A #HostIpmi.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @unnamed_arg4: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-openbmc-HostIpmi.sendMessage">sendMessage()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
host_ipmi_complete_send_message (
    HostIpmi *object,
    GDBusMethodInvocation *invocation,
    gint64 unnamed_arg4)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(x)",
                   unnamed_arg4));
}

/* ------------------------------------------------------------------------ */

/**
 * HostIpmiProxy:
 *
 * The #HostIpmiProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * HostIpmiProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #HostIpmiProxy.
 */

struct _HostIpmiProxyPrivate
{
  GData *qdata;
};

static void host_ipmi_proxy_iface_init (HostIpmiIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (HostIpmiProxy, host_ipmi_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (HostIpmiProxy)
                         G_IMPLEMENT_INTERFACE (TYPE_HOST_IPMI, host_ipmi_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (HostIpmiProxy, host_ipmi_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_HOST_IPMI, host_ipmi_proxy_iface_init));

#endif
static void
host_ipmi_proxy_finalize (GObject *object)
{
  HostIpmiProxy *proxy = HOST_IPMI_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (host_ipmi_proxy_parent_class)->finalize (object);
}

static void
host_ipmi_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
host_ipmi_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
host_ipmi_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_host_ipmi_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], TYPE_HOST_IPMI);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_HOST_IPMI);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
host_ipmi_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  HostIpmiProxy *proxy = HOST_IPMI_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_host_ipmi_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_host_ipmi_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
host_ipmi_proxy_init (HostIpmiProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = host_ipmi_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_HOST_IPMI_PROXY, HostIpmiProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), host_ipmi_interface_info ());
}

static void
host_ipmi_proxy_class_init (HostIpmiProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = host_ipmi_proxy_finalize;
  gobject_class->get_property = host_ipmi_proxy_get_property;
  gobject_class->set_property = host_ipmi_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = host_ipmi_proxy_g_signal;
  proxy_class->g_properties_changed = host_ipmi_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (HostIpmiProxyPrivate));
#endif
}

static void
host_ipmi_proxy_iface_init (HostIpmiIface *iface)
{
}

/**
 * host_ipmi_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-HostIpmi.top_of_page">org.openbmc.HostIpmi</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call host_ipmi_proxy_new_finish() to get the result of the operation.
 *
 * See host_ipmi_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
host_ipmi_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_HOST_IPMI_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.HostIpmi", NULL);
}

/**
 * host_ipmi_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to host_ipmi_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with host_ipmi_proxy_new().
 *
 * Returns: (transfer full) (type HostIpmiProxy): The constructed proxy object or %NULL if @error is set.
 */
HostIpmi *
host_ipmi_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return HOST_IPMI (ret);
  else
    return NULL;
}

/**
 * host_ipmi_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-HostIpmi.top_of_page">org.openbmc.HostIpmi</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See host_ipmi_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type HostIpmiProxy): The constructed proxy object or %NULL if @error is set.
 */
HostIpmi *
host_ipmi_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_HOST_IPMI_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.openbmc.HostIpmi", NULL);
  if (ret != NULL)
    return HOST_IPMI (ret);
  else
    return NULL;
}


/**
 * host_ipmi_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like host_ipmi_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call host_ipmi_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See host_ipmi_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
host_ipmi_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (TYPE_HOST_IPMI_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.HostIpmi", NULL);
}

/**
 * host_ipmi_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to host_ipmi_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with host_ipmi_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type HostIpmiProxy): The constructed proxy object or %NULL if @error is set.
 */
HostIpmi *
host_ipmi_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return HOST_IPMI (ret);
  else
    return NULL;
}

/**
 * host_ipmi_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like host_ipmi_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See host_ipmi_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type HostIpmiProxy): The constructed proxy object or %NULL if @error is set.
 */
HostIpmi *
host_ipmi_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_HOST_IPMI_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.openbmc.HostIpmi", NULL);
  if (ret != NULL)
    return HOST_IPMI (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * HostIpmiSkeleton:
 *
 * The #HostIpmiSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * HostIpmiSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #HostIpmiSkeleton.
 */

struct _HostIpmiSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_host_ipmi_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  HostIpmiSkeleton *skeleton = HOST_IPMI_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], TYPE_HOST_IPMI);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, TYPE_HOST_IPMI);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_host_ipmi_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  HostIpmiSkeleton *skeleton = HOST_IPMI_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_host_ipmi_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_host_ipmi_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  HostIpmiSkeleton *skeleton = HOST_IPMI_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_host_ipmi_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _host_ipmi_skeleton_vtable =
{
  _host_ipmi_skeleton_handle_method_call,
  _host_ipmi_skeleton_handle_get_property,
  _host_ipmi_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
host_ipmi_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return host_ipmi_interface_info ();
}

static GDBusInterfaceVTable *
host_ipmi_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_host_ipmi_skeleton_vtable;
}

static GVariant *
host_ipmi_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  HostIpmiSkeleton *skeleton = HOST_IPMI_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_host_ipmi_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _host_ipmi_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _host_ipmi_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _host_ipmi_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.HostIpmi", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
host_ipmi_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
_host_ipmi_on_signal_received_message (
    HostIpmi *object,
    guchar arg_seq,
    guchar arg_netfn,
    guchar arg_cmd,
    const gchar *arg_data)
{
  HostIpmiSkeleton *skeleton = HOST_IPMI_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(yyy^ay)",
                   arg_seq,
                   arg_netfn,
                   arg_cmd,
                   arg_data));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.openbmc.HostIpmi", "ReceivedMessage",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void host_ipmi_skeleton_iface_init (HostIpmiIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (HostIpmiSkeleton, host_ipmi_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (HostIpmiSkeleton)
                         G_IMPLEMENT_INTERFACE (TYPE_HOST_IPMI, host_ipmi_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (HostIpmiSkeleton, host_ipmi_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_HOST_IPMI, host_ipmi_skeleton_iface_init));

#endif
static void
host_ipmi_skeleton_finalize (GObject *object)
{
  HostIpmiSkeleton *skeleton = HOST_IPMI_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (host_ipmi_skeleton_parent_class)->finalize (object);
}

static void
host_ipmi_skeleton_init (HostIpmiSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = host_ipmi_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_HOST_IPMI_SKELETON, HostIpmiSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
host_ipmi_skeleton_class_init (HostIpmiSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = host_ipmi_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = host_ipmi_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = host_ipmi_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = host_ipmi_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = host_ipmi_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (HostIpmiSkeletonPrivate));
#endif
}

static void
host_ipmi_skeleton_iface_init (HostIpmiIface *iface)
{
  iface->received_message = _host_ipmi_on_signal_received_message;
}

/**
 * host_ipmi_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-HostIpmi.top_of_page">org.openbmc.HostIpmi</link>.
 *
 * Returns: (transfer full) (type HostIpmiSkeleton): The skeleton object.
 */
HostIpmi *
host_ipmi_skeleton_new (void)
{
  return HOST_IPMI (g_object_new (TYPE_HOST_IPMI_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for Object, ObjectProxy and ObjectSkeleton
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:Object
 * @title: Object
 * @short_description: Specialized GDBusObject types
 *
 * This section contains the #Object, #ObjectProxy, and #ObjectSkeleton types which make it easier to work with objects implementing generated types for D-Bus interfaces.
 */

/**
 * Object:
 *
 * The #Object type is a specialized container of interfaces.
 */

/**
 * ObjectIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the #Object interface.
 */

typedef ObjectIface ObjectInterface;
G_DEFINE_INTERFACE_WITH_CODE (Object, object, G_TYPE_OBJECT, g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_DBUS_OBJECT));

static void
object_default_init (ObjectIface *iface)
{
  /**
   * Object:hwmon:
   *
   * The #Hwmon instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Hwmon.top_of_page">org.openbmc.Hwmon</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("hwmon", "hwmon", "hwmon", TYPE_HWMON, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:fan:
   *
   * The #Fan instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Fan.top_of_page">org.openbmc.Fan</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("fan", "fan", "fan", TYPE_FAN, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:sensor-value:
   *
   * The #SensorValue instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorValue.top_of_page">org.openbmc.SensorValue</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("sensor-value", "sensor-value", "sensor-value", TYPE_SENSOR_VALUE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:sensor-threshold:
   *
   * The #SensorThreshold instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorThreshold.top_of_page">org.openbmc.SensorThreshold</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("sensor-threshold", "sensor-threshold", "sensor-threshold", TYPE_SENSOR_THRESHOLD, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:sensor-i2c:
   *
   * The #SensorI2c instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorI2c.top_of_page">org.openbmc.SensorI2c</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("sensor-i2c", "sensor-i2c", "sensor-i2c", TYPE_SENSOR_I2C, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:sensor-match:
   *
   * The #SensorMatch instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorMatch.top_of_page">org.openbmc.SensorMatch</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("sensor-match", "sensor-match", "sensor-match", TYPE_SENSOR_MATCH, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:process:
   *
   * The #Process instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Process.top_of_page">org.openbmc.Process</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("process", "process", "process", TYPE_PROCESS, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:shared-resource:
   *
   * The #SharedResource instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SharedResource.top_of_page">org.openbmc.SharedResource</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("shared-resource", "shared-resource", "shared-resource", TYPE_SHARED_RESOURCE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:control:
   *
   * The #Control instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Control.top_of_page">org.openbmc.Control</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("control", "control", "control", TYPE_CONTROL, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:control-bmc:
   *
   * The #ControlBmc instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Bmc.top_of_page">org.openbmc.control.Bmc</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("control-bmc", "control-bmc", "control-bmc", TYPE_CONTROL_BMC, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:control-host:
   *
   * The #ControlHost instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Host.top_of_page">org.openbmc.control.Host</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("control-host", "control-host", "control-host", TYPE_CONTROL_HOST, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:control-power:
   *
   * The #ControlPower instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Power.top_of_page">org.openbmc.control.Power</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("control-power", "control-power", "control-power", TYPE_CONTROL_POWER, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:control-checkstop:
   *
   * The #ControlCheckstop instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Checkstop.top_of_page">org.openbmc.control.Checkstop</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("control-checkstop", "control-checkstop", "control-checkstop", TYPE_CONTROL_CHECKSTOP, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:watchdog:
   *
   * The #Watchdog instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Watchdog.top_of_page">org.openbmc.Watchdog</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("watchdog", "watchdog", "watchdog", TYPE_WATCHDOG, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:event-log:
   *
   * The #EventLog instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-EventLog.top_of_page">org.openbmc.EventLog</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("event-log", "event-log", "event-log", TYPE_EVENT_LOG, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:flash:
   *
   * The #Flash instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Flash.top_of_page">org.openbmc.Flash</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("flash", "flash", "flash", TYPE_FLASH, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:flash-control:
   *
   * The #FlashControl instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-FlashControl.top_of_page">org.openbmc.FlashControl</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("flash-control", "flash-control", "flash-control", TYPE_FLASH_CONTROL, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:button:
   *
   * The #Button instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Button.top_of_page">org.openbmc.Button</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("button", "button", "button", TYPE_BUTTON, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:led:
   *
   * The #Led instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Led.top_of_page">org.openbmc.Led</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("led", "led", "led", TYPE_LED, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * Object:host-ipmi:
   *
   * The #HostIpmi instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-openbmc-HostIpmi.top_of_page">org.openbmc.HostIpmi</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("host-ipmi", "host-ipmi", "host-ipmi", TYPE_HOST_IPMI, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

}

/**
 * object_get_hwmon:
 * @object: A #Object.
 *
 * Gets the #Hwmon instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Hwmon.top_of_page">org.openbmc.Hwmon</link> on @object, if any.
 *
 * Returns: (transfer full): A #Hwmon that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
Hwmon *object_get_hwmon (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Hwmon");
  if (ret == NULL)
    return NULL;
  return HWMON (ret);
}

/**
 * object_get_fan:
 * @object: A #Object.
 *
 * Gets the #Fan instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Fan.top_of_page">org.openbmc.Fan</link> on @object, if any.
 *
 * Returns: (transfer full): A #Fan that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
Fan *object_get_fan (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Fan");
  if (ret == NULL)
    return NULL;
  return FAN (ret);
}

/**
 * object_get_sensor_value:
 * @object: A #Object.
 *
 * Gets the #SensorValue instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorValue.top_of_page">org.openbmc.SensorValue</link> on @object, if any.
 *
 * Returns: (transfer full): A #SensorValue that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
SensorValue *object_get_sensor_value (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorValue");
  if (ret == NULL)
    return NULL;
  return SENSOR_VALUE (ret);
}

/**
 * object_get_sensor_threshold:
 * @object: A #Object.
 *
 * Gets the #SensorThreshold instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorThreshold.top_of_page">org.openbmc.SensorThreshold</link> on @object, if any.
 *
 * Returns: (transfer full): A #SensorThreshold that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
SensorThreshold *object_get_sensor_threshold (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorThreshold");
  if (ret == NULL)
    return NULL;
  return SENSOR_THRESHOLD (ret);
}

/**
 * object_get_sensor_i2c:
 * @object: A #Object.
 *
 * Gets the #SensorI2c instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorI2c.top_of_page">org.openbmc.SensorI2c</link> on @object, if any.
 *
 * Returns: (transfer full): A #SensorI2c that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
SensorI2c *object_get_sensor_i2c (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorI2c");
  if (ret == NULL)
    return NULL;
  return SENSOR_I2C (ret);
}

/**
 * object_get_sensor_match:
 * @object: A #Object.
 *
 * Gets the #SensorMatch instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorMatch.top_of_page">org.openbmc.SensorMatch</link> on @object, if any.
 *
 * Returns: (transfer full): A #SensorMatch that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
SensorMatch *object_get_sensor_match (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorMatch");
  if (ret == NULL)
    return NULL;
  return SENSOR_MATCH (ret);
}

/**
 * object_get_process:
 * @object: A #Object.
 *
 * Gets the #Process instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Process.top_of_page">org.openbmc.Process</link> on @object, if any.
 *
 * Returns: (transfer full): A #Process that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
Process *object_get_process (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Process");
  if (ret == NULL)
    return NULL;
  return PROCESS (ret);
}

/**
 * object_get_shared_resource:
 * @object: A #Object.
 *
 * Gets the #SharedResource instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SharedResource.top_of_page">org.openbmc.SharedResource</link> on @object, if any.
 *
 * Returns: (transfer full): A #SharedResource that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
SharedResource *object_get_shared_resource (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SharedResource");
  if (ret == NULL)
    return NULL;
  return SHARED_RESOURCE (ret);
}

/**
 * object_get_control:
 * @object: A #Object.
 *
 * Gets the #Control instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Control.top_of_page">org.openbmc.Control</link> on @object, if any.
 *
 * Returns: (transfer full): A #Control that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
Control *object_get_control (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Control");
  if (ret == NULL)
    return NULL;
  return CONTROL (ret);
}

/**
 * object_get_control_bmc:
 * @object: A #Object.
 *
 * Gets the #ControlBmc instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Bmc.top_of_page">org.openbmc.control.Bmc</link> on @object, if any.
 *
 * Returns: (transfer full): A #ControlBmc that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
ControlBmc *object_get_control_bmc (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Bmc");
  if (ret == NULL)
    return NULL;
  return CONTROL_BMC (ret);
}

/**
 * object_get_control_host:
 * @object: A #Object.
 *
 * Gets the #ControlHost instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Host.top_of_page">org.openbmc.control.Host</link> on @object, if any.
 *
 * Returns: (transfer full): A #ControlHost that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
ControlHost *object_get_control_host (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Host");
  if (ret == NULL)
    return NULL;
  return CONTROL_HOST (ret);
}

/**
 * object_get_control_power:
 * @object: A #Object.
 *
 * Gets the #ControlPower instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Power.top_of_page">org.openbmc.control.Power</link> on @object, if any.
 *
 * Returns: (transfer full): A #ControlPower that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
ControlPower *object_get_control_power (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Power");
  if (ret == NULL)
    return NULL;
  return CONTROL_POWER (ret);
}

/**
 * object_get_control_checkstop:
 * @object: A #Object.
 *
 * Gets the #ControlCheckstop instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Checkstop.top_of_page">org.openbmc.control.Checkstop</link> on @object, if any.
 *
 * Returns: (transfer full): A #ControlCheckstop that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
ControlCheckstop *object_get_control_checkstop (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Checkstop");
  if (ret == NULL)
    return NULL;
  return CONTROL_CHECKSTOP (ret);
}

/**
 * object_get_watchdog:
 * @object: A #Object.
 *
 * Gets the #Watchdog instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Watchdog.top_of_page">org.openbmc.Watchdog</link> on @object, if any.
 *
 * Returns: (transfer full): A #Watchdog that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
Watchdog *object_get_watchdog (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Watchdog");
  if (ret == NULL)
    return NULL;
  return WATCHDOG (ret);
}

/**
 * object_get_event_log:
 * @object: A #Object.
 *
 * Gets the #EventLog instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-EventLog.top_of_page">org.openbmc.EventLog</link> on @object, if any.
 *
 * Returns: (transfer full): A #EventLog that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
EventLog *object_get_event_log (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.EventLog");
  if (ret == NULL)
    return NULL;
  return EVENT_LOG (ret);
}

/**
 * object_get_flash:
 * @object: A #Object.
 *
 * Gets the #Flash instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Flash.top_of_page">org.openbmc.Flash</link> on @object, if any.
 *
 * Returns: (transfer full): A #Flash that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
Flash *object_get_flash (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Flash");
  if (ret == NULL)
    return NULL;
  return FLASH (ret);
}

/**
 * object_get_flash_control:
 * @object: A #Object.
 *
 * Gets the #FlashControl instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-FlashControl.top_of_page">org.openbmc.FlashControl</link> on @object, if any.
 *
 * Returns: (transfer full): A #FlashControl that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FlashControl *object_get_flash_control (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.FlashControl");
  if (ret == NULL)
    return NULL;
  return FLASH_CONTROL (ret);
}

/**
 * object_get_button:
 * @object: A #Object.
 *
 * Gets the #Button instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Button.top_of_page">org.openbmc.Button</link> on @object, if any.
 *
 * Returns: (transfer full): A #Button that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
Button *object_get_button (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Button");
  if (ret == NULL)
    return NULL;
  return BUTTON (ret);
}

/**
 * object_get_led:
 * @object: A #Object.
 *
 * Gets the #Led instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Led.top_of_page">org.openbmc.Led</link> on @object, if any.
 *
 * Returns: (transfer full): A #Led that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
Led *object_get_led (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Led");
  if (ret == NULL)
    return NULL;
  return LED (ret);
}

/**
 * object_get_host_ipmi:
 * @object: A #Object.
 *
 * Gets the #HostIpmi instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-HostIpmi.top_of_page">org.openbmc.HostIpmi</link> on @object, if any.
 *
 * Returns: (transfer full): A #HostIpmi that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
HostIpmi *object_get_host_ipmi (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.HostIpmi");
  if (ret == NULL)
    return NULL;
  return HOST_IPMI (ret);
}


/**
 * object_peek_hwmon: (skip)
 * @object: A #Object.
 *
 * Like object_get_hwmon() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #Hwmon or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
Hwmon *object_peek_hwmon (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Hwmon");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return HWMON (ret);
}

/**
 * object_peek_fan: (skip)
 * @object: A #Object.
 *
 * Like object_get_fan() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #Fan or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
Fan *object_peek_fan (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Fan");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FAN (ret);
}

/**
 * object_peek_sensor_value: (skip)
 * @object: A #Object.
 *
 * Like object_get_sensor_value() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #SensorValue or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
SensorValue *object_peek_sensor_value (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorValue");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return SENSOR_VALUE (ret);
}

/**
 * object_peek_sensor_threshold: (skip)
 * @object: A #Object.
 *
 * Like object_get_sensor_threshold() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #SensorThreshold or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
SensorThreshold *object_peek_sensor_threshold (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorThreshold");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return SENSOR_THRESHOLD (ret);
}

/**
 * object_peek_sensor_i2c: (skip)
 * @object: A #Object.
 *
 * Like object_get_sensor_i2c() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #SensorI2c or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
SensorI2c *object_peek_sensor_i2c (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorI2c");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return SENSOR_I2C (ret);
}

/**
 * object_peek_sensor_match: (skip)
 * @object: A #Object.
 *
 * Like object_get_sensor_match() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #SensorMatch or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
SensorMatch *object_peek_sensor_match (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorMatch");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return SENSOR_MATCH (ret);
}

/**
 * object_peek_process: (skip)
 * @object: A #Object.
 *
 * Like object_get_process() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #Process or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
Process *object_peek_process (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Process");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return PROCESS (ret);
}

/**
 * object_peek_shared_resource: (skip)
 * @object: A #Object.
 *
 * Like object_get_shared_resource() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #SharedResource or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
SharedResource *object_peek_shared_resource (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SharedResource");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return SHARED_RESOURCE (ret);
}

/**
 * object_peek_control: (skip)
 * @object: A #Object.
 *
 * Like object_get_control() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #Control or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
Control *object_peek_control (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Control");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return CONTROL (ret);
}

/**
 * object_peek_control_bmc: (skip)
 * @object: A #Object.
 *
 * Like object_get_control_bmc() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #ControlBmc or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
ControlBmc *object_peek_control_bmc (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Bmc");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return CONTROL_BMC (ret);
}

/**
 * object_peek_control_host: (skip)
 * @object: A #Object.
 *
 * Like object_get_control_host() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #ControlHost or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
ControlHost *object_peek_control_host (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Host");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return CONTROL_HOST (ret);
}

/**
 * object_peek_control_power: (skip)
 * @object: A #Object.
 *
 * Like object_get_control_power() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #ControlPower or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
ControlPower *object_peek_control_power (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Power");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return CONTROL_POWER (ret);
}

/**
 * object_peek_control_checkstop: (skip)
 * @object: A #Object.
 *
 * Like object_get_control_checkstop() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #ControlCheckstop or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
ControlCheckstop *object_peek_control_checkstop (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Checkstop");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return CONTROL_CHECKSTOP (ret);
}

/**
 * object_peek_watchdog: (skip)
 * @object: A #Object.
 *
 * Like object_get_watchdog() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #Watchdog or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
Watchdog *object_peek_watchdog (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Watchdog");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return WATCHDOG (ret);
}

/**
 * object_peek_event_log: (skip)
 * @object: A #Object.
 *
 * Like object_get_event_log() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #EventLog or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
EventLog *object_peek_event_log (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.EventLog");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return EVENT_LOG (ret);
}

/**
 * object_peek_flash: (skip)
 * @object: A #Object.
 *
 * Like object_get_flash() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #Flash or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
Flash *object_peek_flash (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Flash");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FLASH (ret);
}

/**
 * object_peek_flash_control: (skip)
 * @object: A #Object.
 *
 * Like object_get_flash_control() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FlashControl or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FlashControl *object_peek_flash_control (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.FlashControl");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FLASH_CONTROL (ret);
}

/**
 * object_peek_button: (skip)
 * @object: A #Object.
 *
 * Like object_get_button() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #Button or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
Button *object_peek_button (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Button");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return BUTTON (ret);
}

/**
 * object_peek_led: (skip)
 * @object: A #Object.
 *
 * Like object_get_led() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #Led or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
Led *object_peek_led (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Led");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return LED (ret);
}

/**
 * object_peek_host_ipmi: (skip)
 * @object: A #Object.
 *
 * Like object_get_host_ipmi() but doesn't increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #HostIpmi or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
HostIpmi *object_peek_host_ipmi (Object *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.HostIpmi");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return HOST_IPMI (ret);
}


static void
object_notify (GDBusObject *object, GDBusInterface *interface)
{
  _ExtendedGDBusInterfaceInfo *info = (_ExtendedGDBusInterfaceInfo *) g_dbus_interface_get_info (interface);
  /* info can be NULL if the other end is using a D-Bus interface we don't know
   * anything about, for example old generated code in this process talking to
   * newer generated code in the other process. */
  if (info != NULL)
    g_object_notify (G_OBJECT (object), info->hyphen_name);
}

/**
 * ObjectProxy:
 *
 * The #ObjectProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ObjectProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ObjectProxy.
 */

static void
object_proxy__object_iface_init (ObjectIface *iface G_GNUC_UNUSED)
{
}

static void
object_proxy__g_dbus_object_iface_init (GDBusObjectIface *iface)
{
  iface->interface_added = object_notify;
  iface->interface_removed = object_notify;
}


G_DEFINE_TYPE_WITH_CODE (ObjectProxy, object_proxy, G_TYPE_DBUS_OBJECT_PROXY,
                         G_IMPLEMENT_INTERFACE (TYPE_OBJECT, object_proxy__object_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, object_proxy__g_dbus_object_iface_init));

static void
object_proxy_init (ObjectProxy *object G_GNUC_UNUSED)
{
}

static void
object_proxy_set_property (GObject      *gobject,
  guint         prop_id,
  const GValue *value G_GNUC_UNUSED,
  GParamSpec   *pspec)
{
  G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
}

static void
object_proxy_get_property (GObject      *gobject,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  ObjectProxy *object = OBJECT_PROXY (gobject);
  GDBusInterface *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Hwmon");
      g_value_take_object (value, interface);
      break;

    case 2:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Fan");
      g_value_take_object (value, interface);
      break;

    case 3:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorValue");
      g_value_take_object (value, interface);
      break;

    case 4:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorThreshold");
      g_value_take_object (value, interface);
      break;

    case 5:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorI2c");
      g_value_take_object (value, interface);
      break;

    case 6:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorMatch");
      g_value_take_object (value, interface);
      break;

    case 7:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Process");
      g_value_take_object (value, interface);
      break;

    case 8:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SharedResource");
      g_value_take_object (value, interface);
      break;

    case 9:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Control");
      g_value_take_object (value, interface);
      break;

    case 10:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Bmc");
      g_value_take_object (value, interface);
      break;

    case 11:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Host");
      g_value_take_object (value, interface);
      break;

    case 12:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Power");
      g_value_take_object (value, interface);
      break;

    case 13:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Checkstop");
      g_value_take_object (value, interface);
      break;

    case 14:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Watchdog");
      g_value_take_object (value, interface);
      break;

    case 15:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.EventLog");
      g_value_take_object (value, interface);
      break;

    case 16:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Flash");
      g_value_take_object (value, interface);
      break;

    case 17:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.FlashControl");
      g_value_take_object (value, interface);
      break;

    case 18:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Button");
      g_value_take_object (value, interface);
      break;

    case 19:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Led");
      g_value_take_object (value, interface);
      break;

    case 20:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.HostIpmi");
      g_value_take_object (value, interface);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
object_proxy_class_init (ObjectProxyClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = object_proxy_set_property;
  gobject_class->get_property = object_proxy_get_property;

  g_object_class_override_property (gobject_class, 1, "hwmon");
  g_object_class_override_property (gobject_class, 2, "fan");
  g_object_class_override_property (gobject_class, 3, "sensor-value");
  g_object_class_override_property (gobject_class, 4, "sensor-threshold");
  g_object_class_override_property (gobject_class, 5, "sensor-i2c");
  g_object_class_override_property (gobject_class, 6, "sensor-match");
  g_object_class_override_property (gobject_class, 7, "process");
  g_object_class_override_property (gobject_class, 8, "shared-resource");
  g_object_class_override_property (gobject_class, 9, "control");
  g_object_class_override_property (gobject_class, 10, "control-bmc");
  g_object_class_override_property (gobject_class, 11, "control-host");
  g_object_class_override_property (gobject_class, 12, "control-power");
  g_object_class_override_property (gobject_class, 13, "control-checkstop");
  g_object_class_override_property (gobject_class, 14, "watchdog");
  g_object_class_override_property (gobject_class, 15, "event-log");
  g_object_class_override_property (gobject_class, 16, "flash");
  g_object_class_override_property (gobject_class, 17, "flash-control");
  g_object_class_override_property (gobject_class, 18, "button");
  g_object_class_override_property (gobject_class, 19, "led");
  g_object_class_override_property (gobject_class, 20, "host-ipmi");
}

/**
 * object_proxy_new:
 * @connection: A #GDBusConnection.
 * @object_path: An object path.
 *
 * Creates a new proxy object.
 *
 * Returns: (transfer full): The proxy object.
 */
ObjectProxy *
object_proxy_new (GDBusConnection *connection,
  const gchar *object_path)
{
  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);
  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
  return OBJECT_PROXY (g_object_new (TYPE_OBJECT_PROXY, "g-connection", connection, "g-object-path", object_path, NULL));
}

/**
 * ObjectSkeleton:
 *
 * The #ObjectSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ObjectSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ObjectSkeleton.
 */

static void
object_skeleton__object_iface_init (ObjectIface *iface G_GNUC_UNUSED)
{
}


static void
object_skeleton__g_dbus_object_iface_init (GDBusObjectIface *iface)
{
  iface->interface_added = object_notify;
  iface->interface_removed = object_notify;
}

G_DEFINE_TYPE_WITH_CODE (ObjectSkeleton, object_skeleton, G_TYPE_DBUS_OBJECT_SKELETON,
                         G_IMPLEMENT_INTERFACE (TYPE_OBJECT, object_skeleton__object_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, object_skeleton__g_dbus_object_iface_init));

static void
object_skeleton_init (ObjectSkeleton *object G_GNUC_UNUSED)
{
}

static void
object_skeleton_set_property (GObject      *gobject,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  ObjectSkeleton *object = OBJECT_SKELETON (gobject);
  GDBusInterfaceSkeleton *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_HWMON (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.Hwmon");
        }
      break;

    case 2:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_FAN (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.Fan");
        }
      break;

    case 3:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_SENSOR_VALUE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.SensorValue");
        }
      break;

    case 4:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_SENSOR_THRESHOLD (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.SensorThreshold");
        }
      break;

    case 5:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_SENSOR_I2C (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.SensorI2c");
        }
      break;

    case 6:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_SENSOR_MATCH (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.SensorMatch");
        }
      break;

    case 7:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_PROCESS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.Process");
        }
      break;

    case 8:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_SHARED_RESOURCE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.SharedResource");
        }
      break;

    case 9:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_CONTROL (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.Control");
        }
      break;

    case 10:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_CONTROL_BMC (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.control.Bmc");
        }
      break;

    case 11:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_CONTROL_HOST (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.control.Host");
        }
      break;

    case 12:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_CONTROL_POWER (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.control.Power");
        }
      break;

    case 13:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_CONTROL_CHECKSTOP (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.control.Checkstop");
        }
      break;

    case 14:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_WATCHDOG (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.Watchdog");
        }
      break;

    case 15:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_EVENT_LOG (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.EventLog");
        }
      break;

    case 16:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_FLASH (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.Flash");
        }
      break;

    case 17:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_FLASH_CONTROL (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.FlashControl");
        }
      break;

    case 18:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_BUTTON (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.Button");
        }
      break;

    case 19:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_LED (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.Led");
        }
      break;

    case 20:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (IS_HOST_IPMI (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.openbmc.HostIpmi");
        }
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
object_skeleton_get_property (GObject      *gobject,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  ObjectSkeleton *object = OBJECT_SKELETON (gobject);
  GDBusInterface *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Hwmon");
      g_value_take_object (value, interface);
      break;

    case 2:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Fan");
      g_value_take_object (value, interface);
      break;

    case 3:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorValue");
      g_value_take_object (value, interface);
      break;

    case 4:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorThreshold");
      g_value_take_object (value, interface);
      break;

    case 5:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorI2c");
      g_value_take_object (value, interface);
      break;

    case 6:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SensorMatch");
      g_value_take_object (value, interface);
      break;

    case 7:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Process");
      g_value_take_object (value, interface);
      break;

    case 8:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.SharedResource");
      g_value_take_object (value, interface);
      break;

    case 9:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Control");
      g_value_take_object (value, interface);
      break;

    case 10:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Bmc");
      g_value_take_object (value, interface);
      break;

    case 11:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Host");
      g_value_take_object (value, interface);
      break;

    case 12:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Power");
      g_value_take_object (value, interface);
      break;

    case 13:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.control.Checkstop");
      g_value_take_object (value, interface);
      break;

    case 14:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Watchdog");
      g_value_take_object (value, interface);
      break;

    case 15:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.EventLog");
      g_value_take_object (value, interface);
      break;

    case 16:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Flash");
      g_value_take_object (value, interface);
      break;

    case 17:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.FlashControl");
      g_value_take_object (value, interface);
      break;

    case 18:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Button");
      g_value_take_object (value, interface);
      break;

    case 19:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.Led");
      g_value_take_object (value, interface);
      break;

    case 20:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.openbmc.HostIpmi");
      g_value_take_object (value, interface);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
      break;
  }
}

static void
object_skeleton_class_init (ObjectSkeletonClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = object_skeleton_set_property;
  gobject_class->get_property = object_skeleton_get_property;

  g_object_class_override_property (gobject_class, 1, "hwmon");
  g_object_class_override_property (gobject_class, 2, "fan");
  g_object_class_override_property (gobject_class, 3, "sensor-value");
  g_object_class_override_property (gobject_class, 4, "sensor-threshold");
  g_object_class_override_property (gobject_class, 5, "sensor-i2c");
  g_object_class_override_property (gobject_class, 6, "sensor-match");
  g_object_class_override_property (gobject_class, 7, "process");
  g_object_class_override_property (gobject_class, 8, "shared-resource");
  g_object_class_override_property (gobject_class, 9, "control");
  g_object_class_override_property (gobject_class, 10, "control-bmc");
  g_object_class_override_property (gobject_class, 11, "control-host");
  g_object_class_override_property (gobject_class, 12, "control-power");
  g_object_class_override_property (gobject_class, 13, "control-checkstop");
  g_object_class_override_property (gobject_class, 14, "watchdog");
  g_object_class_override_property (gobject_class, 15, "event-log");
  g_object_class_override_property (gobject_class, 16, "flash");
  g_object_class_override_property (gobject_class, 17, "flash-control");
  g_object_class_override_property (gobject_class, 18, "button");
  g_object_class_override_property (gobject_class, 19, "led");
  g_object_class_override_property (gobject_class, 20, "host-ipmi");
}

/**
 * object_skeleton_new:
 * @object_path: An object path.
 *
 * Creates a new skeleton object.
 *
 * Returns: (transfer full): The skeleton object.
 */
ObjectSkeleton *
object_skeleton_new (const gchar *object_path)
{
  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
  return OBJECT_SKELETON (g_object_new (TYPE_OBJECT_SKELETON, "g-object-path", object_path, NULL));
}

/**
 * object_skeleton_set_hwmon:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #Hwmon or %NULL to clear the interface.
 *
 * Sets the #Hwmon instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Hwmon.top_of_page">org.openbmc.Hwmon</link> on @object.
 */
void object_skeleton_set_hwmon (ObjectSkeleton *object, Hwmon *interface_)
{
  g_object_set (G_OBJECT (object), "hwmon", interface_, NULL);
}

/**
 * object_skeleton_set_fan:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #Fan or %NULL to clear the interface.
 *
 * Sets the #Fan instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Fan.top_of_page">org.openbmc.Fan</link> on @object.
 */
void object_skeleton_set_fan (ObjectSkeleton *object, Fan *interface_)
{
  g_object_set (G_OBJECT (object), "fan", interface_, NULL);
}

/**
 * object_skeleton_set_sensor_value:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #SensorValue or %NULL to clear the interface.
 *
 * Sets the #SensorValue instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorValue.top_of_page">org.openbmc.SensorValue</link> on @object.
 */
void object_skeleton_set_sensor_value (ObjectSkeleton *object, SensorValue *interface_)
{
  g_object_set (G_OBJECT (object), "sensor-value", interface_, NULL);
}

/**
 * object_skeleton_set_sensor_threshold:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #SensorThreshold or %NULL to clear the interface.
 *
 * Sets the #SensorThreshold instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorThreshold.top_of_page">org.openbmc.SensorThreshold</link> on @object.
 */
void object_skeleton_set_sensor_threshold (ObjectSkeleton *object, SensorThreshold *interface_)
{
  g_object_set (G_OBJECT (object), "sensor-threshold", interface_, NULL);
}

/**
 * object_skeleton_set_sensor_i2c:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #SensorI2c or %NULL to clear the interface.
 *
 * Sets the #SensorI2c instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorI2c.top_of_page">org.openbmc.SensorI2c</link> on @object.
 */
void object_skeleton_set_sensor_i2c (ObjectSkeleton *object, SensorI2c *interface_)
{
  g_object_set (G_OBJECT (object), "sensor-i2c", interface_, NULL);
}

/**
 * object_skeleton_set_sensor_match:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #SensorMatch or %NULL to clear the interface.
 *
 * Sets the #SensorMatch instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SensorMatch.top_of_page">org.openbmc.SensorMatch</link> on @object.
 */
void object_skeleton_set_sensor_match (ObjectSkeleton *object, SensorMatch *interface_)
{
  g_object_set (G_OBJECT (object), "sensor-match", interface_, NULL);
}

/**
 * object_skeleton_set_process:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #Process or %NULL to clear the interface.
 *
 * Sets the #Process instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Process.top_of_page">org.openbmc.Process</link> on @object.
 */
void object_skeleton_set_process (ObjectSkeleton *object, Process *interface_)
{
  g_object_set (G_OBJECT (object), "process", interface_, NULL);
}

/**
 * object_skeleton_set_shared_resource:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #SharedResource or %NULL to clear the interface.
 *
 * Sets the #SharedResource instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-SharedResource.top_of_page">org.openbmc.SharedResource</link> on @object.
 */
void object_skeleton_set_shared_resource (ObjectSkeleton *object, SharedResource *interface_)
{
  g_object_set (G_OBJECT (object), "shared-resource", interface_, NULL);
}

/**
 * object_skeleton_set_control:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #Control or %NULL to clear the interface.
 *
 * Sets the #Control instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Control.top_of_page">org.openbmc.Control</link> on @object.
 */
void object_skeleton_set_control (ObjectSkeleton *object, Control *interface_)
{
  g_object_set (G_OBJECT (object), "control", interface_, NULL);
}

/**
 * object_skeleton_set_control_bmc:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #ControlBmc or %NULL to clear the interface.
 *
 * Sets the #ControlBmc instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Bmc.top_of_page">org.openbmc.control.Bmc</link> on @object.
 */
void object_skeleton_set_control_bmc (ObjectSkeleton *object, ControlBmc *interface_)
{
  g_object_set (G_OBJECT (object), "control-bmc", interface_, NULL);
}

/**
 * object_skeleton_set_control_host:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #ControlHost or %NULL to clear the interface.
 *
 * Sets the #ControlHost instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Host.top_of_page">org.openbmc.control.Host</link> on @object.
 */
void object_skeleton_set_control_host (ObjectSkeleton *object, ControlHost *interface_)
{
  g_object_set (G_OBJECT (object), "control-host", interface_, NULL);
}

/**
 * object_skeleton_set_control_power:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #ControlPower or %NULL to clear the interface.
 *
 * Sets the #ControlPower instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Power.top_of_page">org.openbmc.control.Power</link> on @object.
 */
void object_skeleton_set_control_power (ObjectSkeleton *object, ControlPower *interface_)
{
  g_object_set (G_OBJECT (object), "control-power", interface_, NULL);
}

/**
 * object_skeleton_set_control_checkstop:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #ControlCheckstop or %NULL to clear the interface.
 *
 * Sets the #ControlCheckstop instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-control-Checkstop.top_of_page">org.openbmc.control.Checkstop</link> on @object.
 */
void object_skeleton_set_control_checkstop (ObjectSkeleton *object, ControlCheckstop *interface_)
{
  g_object_set (G_OBJECT (object), "control-checkstop", interface_, NULL);
}

/**
 * object_skeleton_set_watchdog:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #Watchdog or %NULL to clear the interface.
 *
 * Sets the #Watchdog instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Watchdog.top_of_page">org.openbmc.Watchdog</link> on @object.
 */
void object_skeleton_set_watchdog (ObjectSkeleton *object, Watchdog *interface_)
{
  g_object_set (G_OBJECT (object), "watchdog", interface_, NULL);
}

/**
 * object_skeleton_set_event_log:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #EventLog or %NULL to clear the interface.
 *
 * Sets the #EventLog instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-EventLog.top_of_page">org.openbmc.EventLog</link> on @object.
 */
void object_skeleton_set_event_log (ObjectSkeleton *object, EventLog *interface_)
{
  g_object_set (G_OBJECT (object), "event-log", interface_, NULL);
}

/**
 * object_skeleton_set_flash:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #Flash or %NULL to clear the interface.
 *
 * Sets the #Flash instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Flash.top_of_page">org.openbmc.Flash</link> on @object.
 */
void object_skeleton_set_flash (ObjectSkeleton *object, Flash *interface_)
{
  g_object_set (G_OBJECT (object), "flash", interface_, NULL);
}

/**
 * object_skeleton_set_flash_control:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #FlashControl or %NULL to clear the interface.
 *
 * Sets the #FlashControl instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-FlashControl.top_of_page">org.openbmc.FlashControl</link> on @object.
 */
void object_skeleton_set_flash_control (ObjectSkeleton *object, FlashControl *interface_)
{
  g_object_set (G_OBJECT (object), "flash-control", interface_, NULL);
}

/**
 * object_skeleton_set_button:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #Button or %NULL to clear the interface.
 *
 * Sets the #Button instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Button.top_of_page">org.openbmc.Button</link> on @object.
 */
void object_skeleton_set_button (ObjectSkeleton *object, Button *interface_)
{
  g_object_set (G_OBJECT (object), "button", interface_, NULL);
}

/**
 * object_skeleton_set_led:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #Led or %NULL to clear the interface.
 *
 * Sets the #Led instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-Led.top_of_page">org.openbmc.Led</link> on @object.
 */
void object_skeleton_set_led (ObjectSkeleton *object, Led *interface_)
{
  g_object_set (G_OBJECT (object), "led", interface_, NULL);
}

/**
 * object_skeleton_set_host_ipmi:
 * @object: A #ObjectSkeleton.
 * @interface_: (allow-none): A #HostIpmi or %NULL to clear the interface.
 *
 * Sets the #HostIpmi instance for the D-Bus interface <link linkend="gdbus-interface-org-openbmc-HostIpmi.top_of_page">org.openbmc.HostIpmi</link> on @object.
 */
void object_skeleton_set_host_ipmi (ObjectSkeleton *object, HostIpmi *interface_)
{
  g_object_set (G_OBJECT (object), "host-ipmi", interface_, NULL);
}


/* ------------------------------------------------------------------------
 * Code for ObjectManager client
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:ObjectManagerClient
 * @title: ObjectManagerClient
 * @short_description: Generated GDBusObjectManagerClient type
 *
 * This section contains a #GDBusObjectManagerClient that uses object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc.
 */

/**
 * ObjectManagerClient:
 *
 * The #ObjectManagerClient structure contains only private data and should only be accessed using the provided API.
 */

/**
 * ObjectManagerClientClass:
 * @parent_class: The parent class.
 *
 * Class structure for #ObjectManagerClient.
 */

G_DEFINE_TYPE (ObjectManagerClient, object_manager_client, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT);

static void
object_manager_client_init (ObjectManagerClient *manager G_GNUC_UNUSED)
{
}

static void
object_manager_client_class_init (ObjectManagerClientClass *klass G_GNUC_UNUSED)
{
}

/**
 * object_manager_client_get_proxy_type:
 * @manager: A #GDBusObjectManagerClient.
 * @object_path: The object path of the remote object (unused).
 * @interface_name: (allow-none): Interface name of the remote object or %NULL to get the object proxy #GType.
 * @user_data: User data (unused).
 *
 * A #GDBusProxyTypeFunc that maps @interface_name to the generated #GDBusObjectProxy<!-- -->- and #GDBusProxy<!-- -->-derived types.
 *
 * Returns: A #GDBusProxy<!-- -->-derived #GType if @interface_name is not %NULL, otherwise the #GType for #ObjectProxy.
 */
GType
object_manager_client_get_proxy_type (GDBusObjectManagerClient *manager G_GNUC_UNUSED, const gchar *object_path G_GNUC_UNUSED, const gchar *interface_name, gpointer user_data G_GNUC_UNUSED)
{
  static gsize once_init_value = 0;
  static GHashTable *lookup_hash;
  GType ret;

  if (interface_name == NULL)
    return TYPE_OBJECT_PROXY;
  if (g_once_init_enter (&once_init_value))
    {
      lookup_hash = g_hash_table_new (g_str_hash, g_str_equal);
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.Hwmon", GSIZE_TO_POINTER (TYPE_HWMON_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.Fan", GSIZE_TO_POINTER (TYPE_FAN_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.SensorValue", GSIZE_TO_POINTER (TYPE_SENSOR_VALUE_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.SensorThreshold", GSIZE_TO_POINTER (TYPE_SENSOR_THRESHOLD_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.SensorI2c", GSIZE_TO_POINTER (TYPE_SENSOR_I2C_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.SensorMatch", GSIZE_TO_POINTER (TYPE_SENSOR_MATCH_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.Process", GSIZE_TO_POINTER (TYPE_PROCESS_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.SharedResource", GSIZE_TO_POINTER (TYPE_SHARED_RESOURCE_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.Control", GSIZE_TO_POINTER (TYPE_CONTROL_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.control.Bmc", GSIZE_TO_POINTER (TYPE_CONTROL_BMC_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.control.Host", GSIZE_TO_POINTER (TYPE_CONTROL_HOST_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.control.Power", GSIZE_TO_POINTER (TYPE_CONTROL_POWER_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.control.Checkstop", GSIZE_TO_POINTER (TYPE_CONTROL_CHECKSTOP_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.Watchdog", GSIZE_TO_POINTER (TYPE_WATCHDOG_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.EventLog", GSIZE_TO_POINTER (TYPE_EVENT_LOG_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.Flash", GSIZE_TO_POINTER (TYPE_FLASH_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.FlashControl", GSIZE_TO_POINTER (TYPE_FLASH_CONTROL_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.Button", GSIZE_TO_POINTER (TYPE_BUTTON_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.Led", GSIZE_TO_POINTER (TYPE_LED_PROXY));
      g_hash_table_insert (lookup_hash, (gpointer) "org.openbmc.HostIpmi", GSIZE_TO_POINTER (TYPE_HOST_IPMI_PROXY));
      g_once_init_leave (&once_init_value, 1);
    }
  ret = (GType) GPOINTER_TO_SIZE (g_hash_table_lookup (lookup_hash, interface_name));
  if (ret == (GType) 0)
    ret = G_TYPE_DBUS_PROXY;
  return ret;
}

/**
 * object_manager_client_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates #GDBusObjectManagerClient using object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call object_manager_client_new_finish() to get the result of the operation.
 *
 * See object_manager_client_new_sync() for the synchronous, blocking version of this constructor.
 */
void
object_manager_client_new (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data)
{
  g_async_initable_new_async (TYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", object_manager_client_get_proxy_type, NULL);
}

/**
 * object_manager_client_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to object_manager_client_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with object_manager_client_new().
 *
 * Returns: (transfer full) (type ObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
object_manager_client_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}

/**
 * object_manager_client_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates #GDBusObjectManagerClient using object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See object_manager_client_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
object_manager_client_new_sync (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", object_manager_client_get_proxy_type, NULL);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}


/**
 * object_manager_client_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like object_manager_client_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call object_manager_client_new_for_bus_finish() to get the result of the operation.
 *
 * See object_manager_client_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
object_manager_client_new_for_bus (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data)
{
  g_async_initable_new_async (TYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", object_manager_client_get_proxy_type, NULL);
}

/**
 * object_manager_client_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to object_manager_client_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with object_manager_client_new_for_bus().
 *
 * Returns: (transfer full) (type ObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
object_manager_client_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}

/**
 * object_manager_client_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like object_manager_client_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See object_manager_client_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type ObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
object_manager_client_new_for_bus_sync (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error)
{
  GInitable *ret;
  ret = g_initable_new (TYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", object_manager_client_get_proxy_type, NULL);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}


